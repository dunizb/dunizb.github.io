<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[我遇到的前端面试题2017]]></title>
      <url>/2017/09/08/interview-questions-2017/</url>
      <content type="html"><![CDATA[<p><img src="http://dunizb.b0.upaiyun.com/article/201709/interview-questions-2017.png" alt=""></p>
<p>前段时间找工作，经历了好几个公司的面试，得到一些信息，和大家分享：</p>
<ol>
<li>大部分公司（创业公司）都趋向于招一个牛逼的前端而不是三四个平庸的前端</li>
<li>性能优化、ES6必问</li>
<li>招聘要求上清一色的要求有一门后端语言的经验</li>
<li>招聘要求写的和面试相关性并不是很高</li>
<li>招人的要求越来越高，不要轻易离职，特别是裸辞</li>
</ol>
<p>以下是我整理我面试遇到的一些我觉得具有代表性的题目，刚好30题，吐血献上！</p>
<h2 id="0-谈谈对前端安全的理解，有什么，怎么防范"><a href="#0-谈谈对前端安全的理解，有什么，怎么防范" class="headerlink" title="0.谈谈对前端安全的理解，有什么，怎么防范"></a>0.谈谈对前端安全的理解，有什么，怎么防范</h2><p>前端安全问题主要有XSS、CSRF攻击<br><strong>XSS：跨站脚本攻击</strong><br>它允许用户将恶意代码植入到提供给其他用户使用的页面中，可以简单的理解为一种javascript代码注入。<br>XSS的防御措施：</p>
<ol>
<li>过滤转义输入输出</li>
<li>避免使用<code>eval</code>、<code>new Function</code>等执行字符串的方法，除非确定字符串和用户输入无关</li>
<li>使用cookie的httpOnly属性，加上了这个属性的cookie字段，js是无法进行读写的</li>
<li>使用innerHTML、document.write的时候，如果数据是用户输入的，那么需要对象关键字符进行过滤与转义</li>
</ol>
<p><strong>CRSF：跨站请求伪造</strong><br>其实就是网站中的一些提交行为，被黑客利用，在你访问黑客的网站的时候进行操作，会被操作到其他网站上<br>CRSF防御措施：</p>
<ol>
<li>检测http referer是否是同域名</li>
<li>避免登录的session长时间存储在客户端中</li>
<li>关键请求使用验证码或者token机制</li>
</ol>
<p>其他的一些攻击方法还有HTTP劫持、界面操作劫持</p>
<h2 id="1-使用箭头函数需要注意的地方"><a href="#1-使用箭头函数需要注意的地方" class="headerlink" title="1.使用箭头函数需要注意的地方"></a>1.使用箭头函数需要注意的地方</h2><p>当要求动态上下文的时候，你就不能使用箭头函数，比如：定义方法，用构造器创建对象，处理时间时用 <code>this</code> 获取目标。</p>
<h2 id="2-webpack-load的原理"><a href="#2-webpack-load的原理" class="headerlink" title="2.webpack.load的原理"></a>2.webpack.load的原理</h2><p>loaders是你用在app源码上的转换元件。他们是用node.js运行的，把源文件作为参数，返回新的资源的函数。 </p>
<h2 id="3-ES6-let、const"><a href="#3-ES6-let、const" class="headerlink" title="3.ES6 let、const"></a>3.ES6 let、const</h2><p><strong>let</strong><br>let是更完美的var</p>
<ol>
<li>let声明的变量拥有块级作用域,let声明仍然保留了提升的特性，但不会盲目提升。</li>
<li>let声明的全局变量不是全局对象的属性。不可以通过<code>window.变量名</code>的方式访问</li>
<li>形如<code>for (let x…)</code>的循环在每次迭代时都为<code>x</code>创建新的绑定</li>
<li>let声明的变量直到控制流到达该变量被定义的代码行时才会被装载，所以在到达之前使用该变量会触发错误。</li>
</ol>
<p><strong>const</strong><br>定义常量值，不可以重新赋值，但是如果值是一个对象，可以改变对象里的属性值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> OBJ = &#123;<span class="string">"a"</span>:<span class="number">1</span>, <span class="string">"b"</span>:<span class="number">2</span>&#125;;</div><div class="line">OBJ.a = <span class="number">3</span>;</div><div class="line">OBJ = &#123;&#125;;<span class="comment">// 重新赋值，报错！</span></div><div class="line"><span class="built_in">console</span>.log(OBJ.a); <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<h2 id="4-CSS3-box-sizing的作用"><a href="#4-CSS3-box-sizing的作用" class="headerlink" title="4.CSS3 box-sizing的作用"></a>4.CSS3 box-sizing的作用</h2><p>设置CSS盒模型为标准模型或IE模型。标准模型的宽度只包括content，二IE模型包括border和padding</p>
<p>box-sizing属性可以为三个值之一：</p>
<ol>
<li>content-box，默认值，border和padding不计算入width之内</li>
<li>padding-box，padding计算入width内</li>
<li>border-box，border和padding计算入width之内</li>
</ol>
<h2 id="5-说说HTML5中有趣的标签（新标签及语义化）"><a href="#5-说说HTML5中有趣的标签（新标签及语义化）" class="headerlink" title="5.说说HTML5中有趣的标签（新标签及语义化）"></a>5.说说HTML5中有趣的标签（新标签及语义化）</h2><p>如果代码写的语义化，有利于SEO。搜索引擎就会很容易的读懂该网页要表达的意思。例如文本模块要有大标题，合理利用h1-h6，列表形式的代码使用ul或ol，重要的文字使用strong等等。总之就是要充分利用各种HTML标签完成他们本职的工作</p>
<h2 id="6-git命令，如何批量删除分支"><a href="#6-git命令，如何批量删除分支" class="headerlink" title="6.git命令，如何批量删除分支"></a>6.git命令，如何批量删除分支</h2><p><code>git branch |grep &#39;branchName&#39; |xargs git branch -D</code>,从分支列表中匹配到指定分支，然后一个一个(分成小块)传递给删除分支的命令，最后进行删除。(参考<a href="http://www.jianshu.com/p/3602f666799a" target="_blank" rel="external">这里</a>)</p>
<h2 id="7-创建对象的三种方法"><a href="#7-创建对象的三种方法" class="headerlink" title="7.创建对象的三种方法"></a>7.创建对象的三种方法</h2><p>第一种方式，字面量<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">name</span>: <span class="string">"o1"</span>&#125;</div><div class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;<span class="attr">name</span>: <span class="string">"o2"</span>&#125;)</div></pre></td></tr></table></figure></p>
<p>第二种方式，通过构造函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> M = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123; <span class="keyword">this</span>.name = name &#125;</div><div class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> M(<span class="string">"o3"</span>)</div></pre></td></tr></table></figure></p>
<p>第三种方式，Object.create<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span>  p = &#123;<span class="attr">name</span>: <span class="string">"p"</span>&#125;</div><div class="line"><span class="keyword">var</span> o4 = <span class="built_in">Object</span>.create(p)</div></pre></td></tr></table></figure></p>
<p>新创建的对o4的原型就是p，同时o4也拥有了属性name</p>
<h2 id="8-JS实现继承的几种方式"><a href="#8-JS实现继承的几种方式" class="headerlink" title="8.JS实现继承的几种方式"></a>8.JS实现继承的几种方式</h2><p><strong>借用构造函数实现继承</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">"parent1"</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    Parent1.call(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">this</span>.type = <span class="string">"child1"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>缺点：Child1无法继承Parent1的原型对象，并没有真正的实现继承（部分继承）</p>
<p><strong>借用原型链实现继承</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">"parent2"</span>;</div><div class="line">    <span class="keyword">this</span>.play = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.type = <span class="string">"child2"</span>;</div><div class="line">&#125;</div><div class="line">Child2.prototype = <span class="keyword">new</span> Parent2();</div></pre></td></tr></table></figure></p>
<p>缺点：原型对象的属性是共享的</p>
<p><strong>组合式继承</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent3</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">"parent3"</span>;</div><div class="line">    <span class="keyword">this</span>.play = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child3</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    Parent3.call(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">this</span>.type = <span class="string">"child3"</span>;</div><div class="line">&#125;</div><div class="line">Child3.prototype = <span class="built_in">Object</span>.create(Parent3.prototype);</div><div class="line">Child3.prototype.constructor = Child3;</div></pre></td></tr></table></figure></p>
<h2 id="9-当new-Foo-时发生了什么"><a href="#9-当new-Foo-时发生了什么" class="headerlink" title="9.当new Foo()时发生了什么"></a>9.当new Foo()时发生了什么</h2><p>1.创建了一个新对象<br>2.将this指向这个新对象<br>3.执行构造函数里面的代码<br>4.返回新对象（this）<br>参考《JS高程》6.6.2</p>
<h2 id="10-你做过哪些性能优化"><a href="#10-你做过哪些性能优化" class="headerlink" title="10.你做过哪些性能优化"></a>10.你做过哪些性能优化</h2><p>雪碧图，移动端响应式图片，静态资源CDN，减少Dom操作（事件代理、fragment），压缩JS和CSS、HTML等，DNS预解析</p>
<h2 id="11-浏览器渲染原理"><a href="#11-浏览器渲染原理" class="headerlink" title="11.浏览器渲染原理"></a>11.浏览器渲染原理</h2><p>首先来看一张图：<br><img src="http://taligarsiel.com/Projects/webkitflow.png?_=6640761" alt=""></p>
<ol>
<li>HTML被解析成DOM Tree，CSS被解析成CSS Rule Tree</li>
<li>把DOM Tree和CSS Rule Tree经过整合生成Render Tree（布局阶段）</li>
<li>元素按照算出来的规则，把元素放到它该出现的位置，通过显卡画到屏幕上</li>
</ol>
<blockquote>
<p>更多详情看<a href="http://www.cnblogs.com/slly/p/6640761.html" target="_blank" rel="external">这里</a></p>
</blockquote>
<h2 id="12-前端路由的原理"><a href="#12-前端路由的原理" class="headerlink" title="12.前端路由的原理"></a>12.前端路由的原理</h2><p><strong>什么是路由？</strong>简单的说，路由是根据不同的 url 地址展示不同的内容或页面</p>
<p><strong>使用场景？</strong>前端路由更多用在单页应用上, 也就是SPA, 因为单页应用, 基本上都是前后端分离的, 后端自然也就不会给前端提供路由。</p>
<p>前端的路由和后端的路由在实现技术上不一样，但是原理都是一样的。在 HTML5 的 history API 出现之前，前端的路由都是通过 hash 来实现的，hash 能兼容低版本的浏览器。</p>
<p><strong>两种实现前端路由的方式</strong><br><strong>HTML5 History</strong>两个新增的API：<code>history.pushState</code> 和 <code>history.replaceState</code>，两个 API 都会操作浏览器的历史记录，而不会引起页面的刷新。</p>
<p><strong>Hash</strong>就是url 中看到 <code>#</code> ,我们需要一个根据监听哈希变化触发的事件( <code>hashchange</code>) 事件。我们用 <code>window.location</code> 处理哈希的改变时不会重新渲染页面，而是当作新页面加到历史记录中，这样我们跳转页面就可以在 hashchange 事件中注册 ajax 从而改变页面内容。</p>
<p><strong>优点</strong><br>从性能和用户体验的层面来比较的话，后端路由每次访问一个新页面的时候都要向服务器发送请求，然后服务器再响应请求，这个过程肯定会有延迟。而前端路由在访问一个新页面的时候仅仅是变换了一下路径而已，没有了网络延迟，对于用户体验来说会有相当大的提升。</p>
<blockquote>
<p>更多内容请看<a href="http://www.cnblogs.com/yuqing6/p/6731980.html" target="_blank" rel="external">这里</a></p>
</blockquote>
<p><strong>缺点</strong><br>使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存。</p>
<h2 id="13-Restful-API是什么"><a href="#13-Restful-API是什么" class="headerlink" title="13.Restful API是什么"></a>13.Restful API是什么</h2><ol>
<li>Restful的意思就是表现层状态转化。</li>
<li>“表现层”其实指的是”资源”（Resources）的”表现层”，把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。</li>
<li>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在，每一个URI代表一种资源。</li>
<li>如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</li>
<li>Restful就是客户端和服务器之间，传递这种资源的某种表现层</li>
<li>客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”</li>
</ol>
<p>Restful API就是符合Restful架构的API设计。</p>
<p>Restful API一些具体实践：</p>
<ol>
<li>应该尽量将API部署在专用域名之下。如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</li>
<li>应该将API的版本号放入URL。</li>
<li>对于资源的具体操作类型，由HTTP动词表示</li>
<li>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果</li>
<li>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名<br>…..</li>
</ol>
<h2 id="14-script标签的defer、async的区别"><a href="#14-script标签的defer、async的区别" class="headerlink" title="14.script标签的defer、async的区别"></a>14.script标签的defer、async的区别</h2><p>defer是在HTML解析完之后才会执行，如果是多个，按照加载的顺序依次执行<br>async是在加载完成后立即执行，如果是多个，执行顺序和加载顺序无关</p>
<h2 id="15-同源与跨域"><a href="#15-同源与跨域" class="headerlink" title="15.同源与跨域"></a>15.同源与跨域</h2><p><strong>什么是同源策略？</strong><br>限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。<br>一个源指的是主机名、协议和端口号的组合，必须相同</p>
<p><strong>跨域通信的几种方式</strong></p>
<ul>
<li>JSONP</li>
<li>Hash</li>
<li>postMessage</li>
<li>WebSocket</li>
<li>CORS</li>
</ul>
<p><strong>JSONP原理</strong><br>基本原理：利用<code>script</code>标签的异步加载特性实现<br>给服务端传一个回调函数，服务器返回一个传递过去的回调函数名称的JS代码</p>
<blockquote>
<p>更多请查看：<a href="http://34585f3f.wiz03.com/share/s/0Qm5Y_0RRQtc2F-3Zy2piy1K1bpkC_0tckUz2WUwOp2JCve5" target="_blank" rel="external">《前后端通信类知识》</a></p>
</blockquote>
<h2 id="16-原型与闭包相关问题"><a href="#16-原型与闭包相关问题" class="headerlink" title="16.原型与闭包相关问题"></a>16.原型与闭包相关问题</h2><p><strong>原型是什么</strong><br>原型就是一个普通的对象，每个对象都有一个原型（Object除外），原型能存储我们的方法，构造函数创建出来的实例对象能够引用原型中的方法。<br><strong>查看原型</strong><br>以前一般使用对象的<code>__proto__</code>属性，ES6推出后，推荐用<code>Object.getPrototypeOf()</code>方法来获取对象的原型</p>
<p><strong>闭包是什么？</strong><br>专业说法：当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。</p>
<p>还可以这么理解：<br>闭包就是一个具有封闭功能与包裹功能的结构，是为了实现具有私有访问空间的函数的，函数可以构成闭包，因为函数内部定义的数据函数外部无法访问，即函数具有封闭性；函数可以封装代码即具有包裹性，所以函数可以构成闭包。<br>创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量<br><strong>闭包的特性</strong><br>闭包有三个特性：</p>
<ol>
<li>函数嵌套函数</li>
<li>函数内部可以引用外部的参数和变量</li>
<li>参数和变量不会被垃圾回收机制回收</li>
</ol>
<p><strong>闭包有什么用，使用场景</strong><br>当我们需要在模块中定义一些变量，并希望这些变量<strong>一直保存在内存中</strong>但又<strong>不会“污染”全局</strong>的变量时，就可以用闭包来定义这个模块。</p>
<p><strong>闭包的缺点</strong><br>闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</p>
<p><strong>函数套函数就是闭包吗？</strong>不是！，当一个内部函数被其外部函数之外的变量引用时，才会形成了一个闭包。</p>
<blockquote>
<p>更多内容请看<a href="http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651551344&amp;idx=1&amp;sn=f6493bc7d3305139fae7c9059d52e846&amp;chksm=8025a1b1b75228a711eb8089ebd19802fff51eb1b16ee00e3fa70401ffde664fc3e0173bb8f3&amp;mpshare=1&amp;scene=1&amp;srcid=1014PQeGkxJBchXg2fpatR4W#rd" target="_blank" rel="external">这里</a></p>
</blockquote>
<h2 id="17-如何进行错误监控"><a href="#17-如何进行错误监控" class="headerlink" title="17.如何进行错误监控"></a>17.如何进行错误监控</h2><p><strong>前端错误的分类</strong></p>
<ul>
<li>即时运行错误（代码错误）</li>
<li>资源加载错误</li>
</ul>
<p><strong>错误的捕获方式</strong><br>即时运行错误的捕获方式：</p>
<ul>
<li>try…catch</li>
<li>window.onerror</li>
</ul>
<p>资源加载错误：</p>
<ul>
<li>object.onerror（如img,script）</li>
<li>performance.getEntries()</li>
<li>Error事件捕获</li>
</ul>
<blockquote>
<p>延伸：跨域的js运行错误可以捕获吗，错误提示什么，应该怎么处理？<br>可以。<br>Script error<br>1.在script标签增加crossorigin属性<br>  2.设置js资源响应头Access-Control-Allow-Orgin:*</p>
</blockquote>
<p><strong>上报错误的基本原理</strong><br>采用Ajax通信方式上报<br>利用Image对象上报</p>
<h2 id="18-DOM事件类"><a href="#18-DOM事件类" class="headerlink" title="18.DOM事件类"></a>18.DOM事件类</h2><p><strong>DOM事件的级别</strong></p>
<ul>
<li>DOM0，element.onclick = function(){}</li>
<li>DOM2，element.addEventListener(‘click’, function(){}, false);</li>
</ul>
<p><strong>DOM事件模型是什么：</strong>指的是冒泡和捕获<br><strong>DOM事件流是什么：</strong>捕获阶段 -&gt; 目标阶段 -&gt; 冒泡阶段<br><strong>描述DOM事件捕获的具体流程</strong><br>window –&gt; document –&gt; documentElement(html标签) –&gt; body –&gt; …. –&gt; 目标对象<br><strong>Event对象常见应用</strong></p>
<ul>
<li>event.preventDefault()，阻止默认行为</li>
<li>event.stopPropagation()，阻止事件冒泡</li>
<li>event.stopImmediatePropagation()，阻止剩余的事件处理函数执行并且防止事件冒泡到DOM树上，这个方法不接受任何参数。</li>
<li>event.currentTarget，返回绑定事件的元素</li>
<li>event.target，返回触发事件的元素</li>
</ul>
<p><strong>如何自定义事件</strong><br>Event，不能传递参数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> eve = <span class="keyword">new</span> Event(<span class="string">'自定义事件名'</span>);</div><div class="line">ev.addEventListener(<span class="string">'自定义事件名'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'自定义事件'</span>)</div><div class="line">&#125;);</div><div class="line">ev.dispatchEvent(eve);</div></pre></td></tr></table></figure></p>
<p>CustomEvent，还可以指定参数</p>
<h2 id="19-本地起了一个http-server，为什么只能在同一个WIFI-局域网-上访问？"><a href="#19-本地起了一个http-server，为什么只能在同一个WIFI-局域网-上访问？" class="headerlink" title="19.本地起了一个http server，为什么只能在同一个WIFI(局域网)上访问？"></a>19.本地起了一个http server，为什么只能在同一个WIFI(局域网)上访问？</h2><p>你没有公网IP当然就不能被外网访问了。常见的WIFI情况下，一般的ip会是~192.168.0.x·这样的，只是对局域网(同WIFI下)可见，但是外网是访问不了的。（<a href="https://segmentfault.com/q/1010000010863426" target="_blank" rel="external">segmentfault上的答案</a>）</p>
<h2 id="20-回流和重绘"><a href="#20-回流和重绘" class="headerlink" title="20.回流和重绘"></a>20.回流和重绘</h2><p>参考<a href="http://34585f3f.wiz03.com/share/s/0Qm5Y_0RRQtc2F-3Zy2piy1K0E4QKp0IAQvZ2PEFvB08u3fM" target="_blank" rel="external">《如何写出高性能DOM？》</a></p>
<h2 id="21-数组去重的方法"><a href="#21-数组去重的方法" class="headerlink" title="21.数组去重的方法"></a>21.数组去重的方法</h2><p>参考：<a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651550928&amp;idx=1&amp;sn=0912e56c7ccbb68cf36562e723e29da0&amp;scene=1&amp;srcid=0612ekFt6xkwpwwFhCDSPKnM#rd" target="_blank" rel="external">《JavaScript数组去重》</a></p>
<h2 id="22-深拷贝与浅拷贝"><a href="#22-深拷贝与浅拷贝" class="headerlink" title="22.深拷贝与浅拷贝"></a>22.深拷贝与浅拷贝</h2><p><strong>是什么</strong><br>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。<br><strong>实现浅拷贝</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span> &#125;;</div><div class="line"><span class="keyword">var</span> obj2 = obj1;</div><div class="line">obj2.b = <span class="number">100</span>;</div><div class="line"><span class="built_in">console</span>.log(obj1);</div><div class="line"><span class="comment">// &#123; a: 10, b: 100, c: 30 &#125; &lt;-- b 被改到了</span></div><div class="line"><span class="built_in">console</span>.log(obj2);</div><div class="line"><span class="comment">// &#123; a: 10, b: 100, c: 30 &#125;</span></div></pre></td></tr></table></figure></p>
<p><strong>实现深拷贝</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span> &#125;;</div><div class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">a</span>: obj1.a, <span class="attr">b</span>: obj1.b, <span class="attr">c</span>: obj1.c &#125;;</div><div class="line">obj2.b = <span class="number">100</span>;</div><div class="line"><span class="built_in">console</span>.log(obj1);</div><div class="line"><span class="comment">// &#123; a: 10, b: 20, c: 30 &#125; &lt;-- b 沒被改到</span></div><div class="line"><span class="built_in">console</span>.log(obj2);</div><div class="line"><span class="comment">// &#123; a: 10, b: 100, c: 30 &#125;</span></div></pre></td></tr></table></figure></p>
<p><strong>深拷贝实现方式</strong></p>
<ul>
<li>手动复制方式，如上面的代码，缺点就是</li>
<li><p>Object.assign，ES6 的新函数，可以帮助我们达成跟上面一样的功能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">20</span>, <span class="attr">c</span>: <span class="number">30</span> &#125;;</div><div class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</div><div class="line">obj2.b = <span class="number">100</span>;</div><div class="line"><span class="built_in">console</span>.log(obj1);</div><div class="line"><span class="comment">// &#123; a: 10, b: 20, c: 30 &#125; &lt;-- 沒被改到</span></div><div class="line"><span class="built_in">console</span>.log(obj2);</div><div class="line"><span class="comment">// &#123; a: 10, b: 100, c: 30 &#125;</span></div></pre></td></tr></table></figure>
</li>
<li><p>转成 JSON 再转回来<br>用JSON.stringify把对象转成字符串，再用JSON.parse把字符串转成新的对象。<br>缺点：只有可以转成JSON格式的对象才可以这样用，像function没办法转成JSON。</p>
</li>
<li>jquery，有提供一个$.extend可以用来做 Deep Copy。</li>
</ul>
<ol>
<li>lodash，也有提供_.cloneDeep用来做 Deep Copy。</li>
<li>递归实现深拷贝<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params"> o </span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> temp = &#123;&#125;;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> k <span class="keyword">in</span> o ) &#123;</div><div class="line">        <span class="keyword">if</span>( <span class="keyword">typeof</span> o[ k ] == <span class="string">'object'</span> )&#123;</div><div class="line">             temp[ k ] = clone( o[ k ] );</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">             temp[ k ] = o[ k ];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>参考文章：<a href="https://mp.weixin.qq.com/s/FFp56h9MnMKK4OM0BjDd1Q" target="_blank" rel="external">关于 JS 中的浅拷贝和深拷贝</a>,<a href="https://segmentfault.com/a/1190000006811354" target="_blank" rel="external">进击JavaScript之（四）玩转递归与数列</a></p>
<h2 id="23-如何快速合并雪碧图"><a href="#23-如何快速合并雪碧图" class="headerlink" title="23.如何快速合并雪碧图"></a>23.如何快速合并雪碧图</h2><p>Gulp：gulp-css-spriter<br>webpack：optimize-css-assets-webpack-plugin<br>Go！Png<br>在线工具</p>
<h2 id="24-代码优化基本方法"><a href="#24-代码优化基本方法" class="headerlink" title="24.代码优化基本方法"></a>24.代码优化基本方法</h2><p><strong>减少HTTP请求</strong><br>HTML优化：</p>
<ul>
<li>使用语义化标签</li>
<li>减少iframe：iframe是SEO的大忌，iframe有好处也有弊端</li>
<li>避免重定向</li>
</ul>
<p>CSS优化：</p>
<ul>
<li>布局代码写前面</li>
<li>删除空样式</li>
<li>不滥用浮动，字体，需要加载的网络字体根据网站需求再添加</li>
<li>选择器性能优化</li>
<li>避免使用表达式，避免用id写样式</li>
</ul>
<p>js优化：</p>
<ul>
<li>压缩</li>
<li>减少重复代码</li>
</ul>
<p>图片优化：</p>
<ul>
<li>使用WebP</li>
<li>图片合并，CSS sprite技术</li>
</ul>
<p><strong>减少DOM操作</strong></p>
<ul>
<li>缓存已经访问过的元素 </li>
<li>“离线”更新节点, 再将它们添加到树中</li>
<li>避免使用 JavaScript 输出页面布局–应该是 CSS 的事儿 </li>
</ul>
<p><strong>使用JSON格式来进行数据交换</strong><br><strong>使用CDN加速</strong><br><strong>使用HTTP缓存：</strong>添加 <code>Expires</code> 或 <code>Cache-Control</code> 信息头<br><strong>使用DNS预解析</strong><br>Chrome内置了DNS Prefetching技术, Firefox 3.5 也引入了这一特性，由于Chrome和Firefox 3.5本身对DNS预解析做了相应优化设置，所以设置DNS预解析的不良影响之一就是可能会降低Google Chrome浏览器及火狐Firefox 3.5浏览器的用户体验。<br>预解析的实现：</p>
<ol>
<li>用meta信息来告知浏览器, 当前页面要做DNS预解析:<code>&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt;</code></li>
<li>在页面header中使用link标签来强制对DNS预解析: <code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://bdimg.share.baidu.com&quot; /&gt;</code></li>
</ol>
<h2 id="25-HTTPS的握手过程"><a href="#25-HTTPS的握手过程" class="headerlink" title="25.HTTPS的握手过程"></a>25.HTTPS的握手过程</h2><ol>
<li>浏览器将自己支持的一套加密规则发送给服务器。</li>
<li>服务器从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。</li>
<li>浏览器获得网站证书之后浏览器要做以下工作：<ul>
<li>验证证书的合法</li>
<li>如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。</li>
<li>使用约定好的HASH算法计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给服务器</li>
</ul>
</li>
<li>网站接收浏览器发来的数据之后要做以下的操作：<ul>
<li>使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。</li>
<li>使用密码加密一段握手消息，发送给浏览器。</li>
</ul>
</li>
<li>浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。</li>
</ol>
<p>参考文章：<a href="http://blog.jobbole.com/105633/" target="_blank" rel="external">《HTTPS 工作原理和 TCP 握手机制》</a></p>
<h2 id="26-BFC相关问题"><a href="#26-BFC相关问题" class="headerlink" title="26.BFC相关问题"></a>26.BFC相关问题</h2><p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有 Block-level box 参 与， 它规定了内部的 Block-level Box 如何布局，并且与这个区域外部毫不相干。</p>
<p><strong>BFC的渲染规则</strong></p>
<ul>
<li>BFC这个元素的垂直方向的边距会发生重叠</li>
<li>BFC的区域不会与浮动元素的box重叠（清除浮动原理）</li>
<li>BFC在页面上是一个独立的容器，外面的元素不会影响它里面的元素，反过来它里面的元素也不会影响外面的元素</li>
<li>计算BFC的高度的时候，浮动元素也会参与计算</li>
</ul>
<p><strong>如何创建BFC？</strong></p>
<ul>
<li>overflow属性不为visible</li>
<li>float属性不为none</li>
<li>position属性为absolute或fixed</li>
<li>display属性为inline-block、table-cell、table-caption、flex、inline-flex</li>
</ul>
<p><strong>BFC的使用场景</strong><br>他的很常用的一个应用场景就是解决边距重叠的问题.</p>
<h2 id="27-响应式图片"><a href="#27-响应式图片" class="headerlink" title="27.响应式图片"></a>27.响应式图片</h2><p>1.JS或者服务端硬编码，resize事件，判断屏幕大小加载不同的图片<br>2.img srcset 方法<br>3.picture标签 -&gt; source<br>4.svg<br>5.第三方库polyfill</p>
<h2 id="28-判断一个变量是否是数组"><a href="#28-判断一个变量是否是数组" class="headerlink" title="28.判断一个变量是否是数组"></a>28.判断一个变量是否是数组</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = []; </div><div class="line"><span class="comment">// 1.基于instanceof </span></div><div class="line">a <span class="keyword">instanceof</span> <span class="built_in">Array</span>; </div><div class="line"><span class="comment">// 2.基于constructor </span></div><div class="line">a.constructor === <span class="built_in">Array</span>; </div><div class="line"><span class="comment">// 3.基于Object.prototype.isPrototypeOf </span></div><div class="line"><span class="built_in">Array</span>.prototype.isPrototypeOf(a); </div><div class="line"><span class="comment">// 4.基于getPrototypeOf </span></div><div class="line"><span class="built_in">Object</span>.getPrototypeOf(a) === <span class="built_in">Array</span>.prototype; </div><div class="line"><span class="comment">// 5.基于Object.prototype.toString </span></div><div class="line"><span class="built_in">Object</span>.prototype.toString.apply(a) === <span class="string">'[object Array]'</span>;</div><div class="line"><span class="comment">// 6.Array.isArray</span></div><div class="line"><span class="built_in">Array</span>.isArray([]); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>以上，除了<code>Object.prototype.toString</code>外，其它方法都不能正确判断变量的类型。</p>
<h2 id="29-UTF-8和Unicode的区别"><a href="#29-UTF-8和Unicode的区别" class="headerlink" title="29.UTF-8和Unicode的区别"></a>29.UTF-8和Unicode的区别</h2><p>UTF-8就是在互联网上使用最广的一种unicode的实现方式。<br>Unicode的出现是为了统一地区性文字编码方案，为解决unicode如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。<br>ASCII –&gt; 地区性编码（GBK） –&gt; Unicode –&gt; UTF-8<br><a href="https://www.zhihu.com/question/23374078" target="_blank" rel="external">知乎回答</a></p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的TO-DO应用实践]]></title>
      <url>/2017/09/02/My-TO-DO-application-practice/</url>
      <content type="html"><![CDATA[<p><img src="http://dunizb.b0.upaiyun.com/article/201709/mytodo/todo-1.png" alt=""><br>闲的时候不知道干嘛？生活没有具体目标？感觉很多事又不知道从哪里开始？老忘记一些事？</p>
<p>如果你有上面几个问题，那么该好好实施TODO来管理自己生活了。</p>
<p>TODO的意思是“去做”，一般也看以看成是待办事项、清单，有一本书叫《清单革命》，讲述了各行各业列清单的重要性，但是本书通篇都只是在说清单的重要性，缺少对个人应用清单到底该怎么做，因此，本书的作用也就仅限于让你知道清单的重要性，应该马上应用起来。还有一本书《为什么精英都是清单控》，这本书就是具体告诉该怎么做，声情并茂，至于内容，没什么新意，就是重复了其它一些时间管理书籍给出的常用技巧。列清单，排优先级，学任务外包。等等。</p>
<div align="center"><br><img src="https://img1.doubanio.com/lpic/s10324198.jpg" title="清单革命" alt="清单革命"><img src="https://img3.doubanio.com/lpic/s28758773.jpg" title="为什么精英都是清单控" alt="为什么精英都是清单控"><br></div>

<p>近两年突然兴起了各种时间管理方法论，其中的代表便是番茄管理法，大概也是新时代下信息爆炸导致我们的时间几乎都被手机、网络上的娱乐信息占据了，我们的大把时间被浪费掉了。</p>
<p>用过不少todo-list应用，比如以前用的奇妙清单、滴答清单，还用过各种各样的清单APP。奇妙清单是老外的作品，国内国外拥有很多铁粉，但是国内访问同步速度有点慢，不过现在被微软收购了，应用也被整合到新的APP中，变成了Microsoft To-Do，新的to-do在国内体验很好，同步速度也挺快，是我现在正使用的APP，没有什么需要付费的高级功能，更像是为个人量身打造的。不像其他TODO应用通常是为各种场景设计的，都提供团队使用功能等付费高级功能。<br><img src="http://dunizb.b0.upaiyun.com/article/201709/mytodo/todo-1.png" alt=""><br>Microsoft To-Do应用继承了奇妙清单的简单简洁风格，没有什么花俏功能，比较适合个人使用，界面也是小清新，最大的两点应该是“我的一天”了吧，可以规划今天该做些什么，这个功能虽然不算什么牛逼设计，但是深的我心，其他TODO应用貌似都没有这样的设计。虽然其他APP也可以这样做，但是感觉稍麻烦。<br><img src="http://dunizb.b0.upaiyun.com/article/201709/mytodo/todo-2.png" alt=""><br>上图是我的Microsoft To-Do网页版界面，我会把平时所想、灵感、待办事项等都随时记录下来，比如“要写的博客”清单，会把把平时遇到的问题或值得记录下来知识点记录下来，这样就不愁不知道写什么了，几天下来能积累下来不少的题目，在空余时间就可以找个题目构思博客了，做完一个任务就勾选掉，打钩的那一瞬间是最愉快的。<br><img src="http://dunizb.b0.upaiyun.com/article/201709/mytodo/todo-3.png" alt=""><br>“要读的书”清单，把这个月，这一年等需要读的书列出来；“要写的代码”清单，平时看到的有趣的效果，遇到的有趣的编程题目，或者自己突发奇想要写的东西都会被记录在这里。<br><img src="http://dunizb.b0.upaiyun.com/article/201709/mytodo/todo-4.png" alt=""><br><img src="http://dunizb.b0.upaiyun.com/article/201709/mytodo/todo-5.png" alt=""><br>默认清单是To-Do，不可删除编辑，如果不设置自定义清单，或创建任务不选择清单，或这个任务不好归类到某个清单，将默认添加在这里，可以把这里看成收集箱。<br><img src="http://dunizb.b0.upaiyun.com/article/201709/mytodo/todo-6.png" alt=""><br>关于清单的使用还有一些理论，例如四象限法则，提倡把任务分为重要又紧急、重要不紧急、不重要但紧急、不重要不紧急四个类别。在Microsoft To-Do中，可以新建这样四个清单来使用，不过感觉这个比较适合在工作中使用，个人的话，任务不是特别多，一般不用也没什么问题。</p>
<p>Microsoft To-Do当然也提供手机版，是我经常使用的方式<br><img src="http://dunizb.b0.upaiyun.com/article/201709/mytodo/todo-7.png" alt=""><img src="http://dunizb.b0.upaiyun.com/article/201709/mytodo/todo-8.png" alt=""><br>Microsoft To-Do使用了有大半年了，一切都感觉很好，微软良心出品，没有任何广告，没有你用不到又经常提示你的高级版升级提示，五星好评。</p>
<blockquote>
<p>PS：今天看到一篇文章，<a href="https://zhuanlan.zhihu.com/p/28987530?group_id=887069148176334848" target="_blank" rel="external">一些Markdown奇技淫巧</a>,原来Markdown是可以写部分HTML标签的，本文前面两张图书封面使用的就是里面的技巧</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 随笔扯谈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[成都·俗人言]]></title>
      <url>/2017/09/02/%E6%88%90%E9%83%BD-%E4%BF%97%E4%BA%BA%E8%A8%80/</url>
      <content type="html"><![CDATA[<p><a href="https://y.qq.com/n/yqq/playlist/2679635336.html" target="_blank" rel="external"><img src="http://dunizb.b0.upaiyun.com/article/201709/qqmusic.png" alt="进入歌单"></a></p>
<p><a href="https://y.qq.com/n/yqq/playlist/2679635336.html" target="_blank" rel="external">&gt;&gt;&gt; 进入歌单 &lt;&lt;&lt;</a></p>
<p>最近一个人安静的时候喜欢听谢春花、赵雷的歌，反复听。我觉得他们的歌风格类似，同种风格的男声版和女声版。</p>
<p>我最常用的听音乐软件是QQ音乐，网易云音乐偶尔听听，习惯了QQ音乐的简洁简单，我很少去探索未知的新歌，一般收藏了就会反复听。这么多年下来，我的QQ音乐上也创建了不少的歌单。</p>
<p>今天创建了《成都·俗人言》歌单，谢春花和赵雷的优秀作品集，还有其他歌单，欢迎来听听，交个歌友互通歌品吧。如你们也有不错的歌单，欢迎推荐互相点赞吧</p>
]]></content>
      
        <categories>
            
            <category> 随笔扯谈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何做程序的需求分析和设计？]]></title>
      <url>/2017/08/11/How-to-do-the-program-needs-analysis-and-design/</url>
      <content type="html"><![CDATA[<p>这篇文章以一个成员列表功能作为例子，很有启发意义，作者的思维过程和方法值得学习</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>分析的时候，我们要分析需求和难点。</p>
<p>分析需求的方法是做需求的陈述处理。要区分“做什么”和“怎么做”，把这两部分独立出来，“做什么是固定不变的”，而“怎么做”可能经常会变。举个例子，我们准备做一个成员列表（下图），产品经理告诉我们姓名拼音排序。<br><img src="http://img.mukewang.com/598d399300012f3921362752.jpg" alt="图片描述"><br>我们有时候不能完全听产品经理的，如果真按姓名拼音排序编码就没有可扩展性了。如果某一天产品经理说需要把VIP会员提前，那么你只能再去修改排序的程序。这个需求中始终不变的是排序，按姓名拼音只是排序的一种方法。我们在设计数据库的时候应该把排序字段设置为数字而不是拼音，再写一个拼音转换为数字的算法即可，这样来应对后面排序规则的变化。比如，VIP会员要提前，只要修改对应用户数据库的排序字段数值即可，不用大改程序。</p>
<p>我们可以用XMind作需求分析，先把看见和听见的需求一条一条地列出来。然后对每条需求进行分析，看看能否区分“做什么”和“怎么做”。如果能区分，在这条需求后面建两个分支，并把分析结果写上去，如下图：<br><img src="http://img.mukewang.com/598d39b60001edd932321200.jpg" alt="图片描述"><br>需求过了一遍后，我们需要思考程序哪儿可能有难点，再把难点列到Xmind中。比如，成员列表这个功能，难点可能有：<br>1.如何把中文姓名转换为拼音<br>2.如何把拼音转换为数字</p>
<p>然后，我们再想想这两个难点的解决方案。我们在网上搜索，发现有中文转拼音的开源库，直接用这个库就行，把解决方案写在对应难点的后面。另外，我们还应该做一个简单的Dome，测试一下次此方案是否真的能解决难点。</p>
<p>程序员习惯用二元思维，往往认为不是“是”就是“非”，一个难点不能完美的解决，感觉就是不能解决，相反，我们要有优雅降级的思维。假设我们要做一个特殊的缓存功能，缓存到服务端是最完美的，但有难度，不好实现。这时候想想能不能优雅降级，不能缓存到服务端能否缓存到客户端；缓存到客户端的方案并不完美，比如用户可能会手动清空缓存，但是有缓存总比没有好，那么我们能不能做呢？</p>
<p>我们再分析刚才的第二个难点，拼音转换为数字的算法，我们可能定义a转换为1，b转换为2，c转换为3.但有一个问题，我们对人名的第一个字排序了，要不要对第二个字排序？比如“张三”和“张飞”两个人名，第一个字“张”的拼音首字母都是Z，我们还需要对“三”和“飞”转换为拼音排序吗？要做完美的解决方案的话，是要对第二个字排序的，那么怎么排序？假设我们在这里卡住了，暂时想不到好的解决方案，很多人会觉得这个功能做不了、不能做饿了，我们能不能优雅降级一下，先对第一个字排序，以后想到其他解决方案再完善呢？</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>设计这一步，要体现程序怎么写，我们要设计出数据库的表结构、API接口以及前端页面等。设计也可以在Xmind中完成：<br><img src="http://img.mukewang.com/598d39e00001785426081744.jpg" alt="图片描述"><br>设计这部分一定要体现程序如何开发，不能还是列举需求，要说明建立什么程序文件、建立什么类，以及类有哪些方法，方法的具体处理过程。在XMind中我们经常会用这些断句：“当XXX条件成立时做XXX”“调用XXX方法”。</p>
<p>XMind在列出这些“处理过程”时就能发现很多重复的逻辑，我们应该把这些重复的逻辑独立成模块（封装为类或含函数）。对于这些要封装的模块，我们在列XMind的时候就要想好，而不是编写代码边想，这样会不断推翻以前的代码重写，浪费时间。</p>
<p>在设计类的时候注意“正交设计、类要有专职、委托优于继承”。类方法的处理过程要详细，在实际写代码的时候照着XMind实现代码即可，那个时候就不用想程序的逻辑了。</p>
<p>对于新手来说，写代码之前把所有细节都想到是有难度的，他们要边写边想，写到具体的地方才知道有什么细节。但这样的习惯很不好，写着写着代码逻辑就会变乱。程序员一定要养成写之前先想清楚的习惯。从现在开始我们慢慢养成写代码之前列XMind做分析和设计的习惯，写完代码后再对比之前列的XMind看看哪些是之前没有想到的，慢慢积累经验，时间长了分析和设计会做的越来越好。</p>
<p>我们在XMind中设计好有哪些接口和模块还有利于团队的沟通和工作的分工，评估每个模块的开发时间。因为XMind列的比较细，每个模块的时间往往能以分钟或小时来估计，如果有些模块还必须以天为单位估算时间的话，那证明这个模块还能再细化。</p>
<hr>
<p>《内外兼修——程序员的成长之路》读书笔记</p>
<p><strong>++++++++++<a href="http://dunizb.com/obook/">20元出售此书</a>++++++++++</strong><br><a href="http://dunizb.com/obook/"><img src="http://img.mukewang.com/598d3a7e0001c19005860710.png" alt="图片描述"></a></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS中的typeof和类型判断]]></title>
      <url>/2017/07/08/JS-in-the-typeof-and-type-judgment/</url>
      <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>这篇文章讲述typeof运算符判断基本类型和引用类型的区别，以及怎么判断数组类型和空对象</p>
<h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p>ECMAScript 有 5 种原始类型（primitive type），即 Undefined、Null、Boolean、Number 和 String。我们都知道可以使用typeof运算符求得一个变量的类型，但是对引用类型变量却只会返回<code>object</code>，也就是说typeof只能正确识别基本类型值变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="string">"abc"</span>;</div><div class="line"><span class="keyword">typeof</span> a;<span class="comment">// "string"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="number">123</span>;</div><div class="line"><span class="keyword">typeof</span> b;<span class="comment">// "number"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> c = <span class="literal">true</span>;</div><div class="line"><span class="keyword">typeof</span> c;<span class="comment">// "boolean"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> d = <span class="literal">null</span>;</div><div class="line"><span class="keyword">typeof</span> d;<span class="comment">// "object"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> f = <span class="literal">undefined</span>;</div><div class="line"><span class="keyword">typeof</span> f;<span class="comment">// "undefined"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> g;</div><div class="line"><span class="keyword">typeof</span> g;<span class="comment">// "undefined"</span></div><div class="line"><span class="keyword">typeof</span> x;<span class="comment">// "object"</span></div></pre></td></tr></table></figure></p>
<p>您也许会问，为什么 typeof 运算符对于 null 值会返回 “object”。这实际上是 JavaScript 最初实现中的一个错误，然后被 ECMAScript 沿用了。现在，null 被认为是对象的占位符，从而解释了这一矛盾，但从技术上来说，它仍然是原始值。</p>
<p>最后一个比较奇怪，typeof一个不存在的变量<code>x</code>居然返回了”object”而不是”undefined”。</p>
<p>我们在来如下代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"><span class="keyword">typeof</span> a; <span class="comment">// "function"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">typeof</span> b; <span class="comment">// "object"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> c = &#123;&#125;;</div><div class="line"><span class="keyword">typeof</span> c; <span class="comment">// "object"</span></div></pre></td></tr></table></figure></p>
<p>对于数组和对象都返回”object”，因此我们日常开发中一个常见需求就是如何判断变量是数组还是对象。</p>
<h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><p>类型判断，一般就是判断是否是数组，是否是空对象。这是针对这个需求，我日常用过或见过的判断方法</p>
<p><strong>判断是否是数组</strong><br>有数组：<code>var a = [1,2,3,4,5];</code><br>方法一：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">toString.call(a); <span class="comment">// "[object Array]"</span></div></pre></td></tr></table></figure></p>
<p>方法二：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>方法三：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.constructor == <span class="built_in">Array</span>; <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>第一种方法比较通用，也就是<code>Object.prototype.toString.call(a)</code>的简写。</p>
<p><code>instanceof</code>和<code>constructor</code>判断的变量，必须在当前页面声明的，比如，一个页面（父页面）有一个框架，框架中引用了一个页面（子页面），在子页面中声明了一个a，并将其赋值给父页面的一个变量，这时判断该变量，<code>Array == object.constructor</code>会返回<code>false</code>；</p>
<p><strong>判断是否是空对象</strong><br>有变量：<code>var obj = {};</code><br>方法一：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">JSON</span>.stringify(obj); <span class="comment">// "&#123;&#125;"</span></div></pre></td></tr></table></figure></p>
<p>通过转换成JSON对象来判断是否是空大括号</p>
<p>方法二：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(obj.id)&#123;</div><div class="line">   <span class="comment">//如果属性id存在....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法比较土，大多数人都能想到，前提是得知道对象中有某个属性。</p>
<p>方法三：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmptyObject</span>(<span class="params">e</span>) </span>&#123;  </div><div class="line">    <span class="keyword">var</span> t;  </div><div class="line">    <span class="keyword">for</span> (t <span class="keyword">in</span> e)  </div><div class="line">        <span class="keyword">return</span> !<span class="number">1</span>;  </div><div class="line">    <span class="keyword">return</span> !<span class="number">0</span>  </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="comment">//true</span></div><div class="line">isEmptyObject(obj); </div><div class="line"><span class="comment">//false</span></div><div class="line">isEmptyObject(&#123;</div><div class="line">    <span class="string">"a"</span>:<span class="number">1</span>,</div><div class="line">    <span class="string">"b"</span>:<span class="number">2</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这个方法是jQuery的isEmptyObject()方法的实现方式。</p>
<hr>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-44511e8f33ac2b9b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文章首发于我的微信公众号，关注可获得每次最新推送"></p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS的String()、toString()、valueOf()的一些隐秘特性]]></title>
      <url>/2017/07/06/js-String-toString-valueOf/</url>
      <content type="html"><![CDATA[<h2 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h2><p>要把一个值转换为一个字符串，最常用的就是，使用几乎每个值都有的toString()方法，这个方法唯一要做的就是返回相应值的字符串表现。</p>
<p>数值、布尔值、对象和字符串值（没错，每个字符串也都有一个toString()方法，该方法返回字符串的一个副本）都有<code>toString()</code>方法。但<code>null</code>和<code>undefined</code>值没有这个方法。因此在对一个变量进行了<code>toString()</code>后，如果变量为<code>null</code>或者<code>undefined</code>的时候就会报错。</p>
<p>多数情况下，调用<code>toString()</code>方法不必传递参数。但是，在调用数值的<code>toString()</code>方法时，可以传递一个参数：输出数值的基数。默认情况下，<code>toString()</code>方法以十进制格式返回数值的字符串表示。而通过传递基数，<code>toString()</code>可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格式表示的字符串值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">10</span>; </div><div class="line"><span class="comment">// "10" </span></div><div class="line">alert(num.toString()); </div><div class="line"><span class="comment">// "1010" </span></div><div class="line">alert(num.toString(<span class="number">2</span>)); </div><div class="line"><span class="comment">// "12" </span></div><div class="line">alert(num.toString(<span class="number">8</span>)); </div><div class="line"><span class="comment">// "10" </span></div><div class="line">alert(num.toString(<span class="number">10</span>)); </div><div class="line"><span class="comment">// "a" </span></div><div class="line">alert(num.toString(<span class="number">16</span>));</div></pre></td></tr></table></figure></p>
<p>通过这个例子可以看出，通过指定基数，toString()方法会改变输出的值。而数值10根据基数的不同，可以在输出时被转换为不同的数值格式。注意，默认的（没有参数的）输出值与指定基数10时的输出值相同。</p>
<h2 id="valueOf-方法"><a href="#valueOf-方法" class="headerlink" title="valueOf()方法"></a>valueOf()方法</h2><p>说实话这个方法存在感很低，在JS中对数据进行字符串转型，通常都用<code>toString()</code>方法，或者直接在变量后面加上空字符串。<code>valueOf()</code>方法的返回值通常与<code>toString()</code>都是一样的。但是，在Object上，他们两个表现出了截然不同的形式，在对一个对象类型（Object、Array）进行valueOf()时，valueOf()直接返回原对象，而toString()则返回<code>[object Object]</code>。<strong>在《JavaScript高级程序设计（第三版）》中，作者说valueOf()返回与toString()相同的值，即对Array调用valueOf()返回字符串表现形式，我在多个现代浏览器中（Chrome、Egde）和IE8文档模式下测试均返回原数组对象。所以看到这里的读者要注意了，书中部分内容到现在可能并不准确了。</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123; <span class="string">"a"</span>:<span class="string">"123"</span>, <span class="string">"b"</span>: <span class="string">"456"</span> &#125;;</div><div class="line"><span class="comment">// Object &#123;a: "123", b: "456"&#125;</span></div><div class="line">a.valueOf()</div><div class="line"><span class="comment">// [object object]</span></div><div class="line">a.toString()</div></pre></td></tr></table></figure></p>
<p>对于数组也一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var b = [1,2,3,45,6];</div><div class="line">// (5) [1, 2, 3, 45, 6]</div><div class="line">b.valueOf()</div><div class="line">// 1,2,3,45,6</div><div class="line">b.toString()</div></pre></td></tr></table></figure></p>
<h2 id="String-方法"><a href="#String-方法" class="headerlink" title="String()方法"></a>String()方法</h2><p>在不知道要转换的值是不是<code>null</code>或<code>undefined</code>的情况下，还可以使用转型函数<code>String()</code>，这个函数能够将任何类型的值转换为字符串。String()函数遵循下列转换规则：</p>
<ul>
<li>如果值有toString()方法，则调用该方法（没有参数）并返回相应的结果；</li>
<li>如果值是null，则返回”null”；</li>
<li>如果值是undefined，则返回”undefined”。</li>
</ul>
<p>toString()与String()的区别就在于String()还能转换<code>null</code>和<code>undefined</code>值，可以说是toString()的增强版。在开发中直接使用String()似乎更好，这样能避免潜在的转换风险。</p>
<hr>
<p>《JavaScript高级程序设计》笔记之一</p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用户体验设计及评判]]></title>
      <url>/2017/06/27/user-experience-design-and-evaluation/</url>
      <content type="html"><![CDATA[<h2 id="用户体验的设计步骤和目标"><a href="#用户体验的设计步骤和目标" class="headerlink" title="用户体验的设计步骤和目标"></a>用户体验的设计步骤和目标</h2><p>用户体验和用户界面设计的目的是什么？有哪些步骤呢？一些没有经验的工程师觉得，“我先把代码写好，然后有一些会画图的人来把界面改一改就好了……”，这种想法是非常幼稚和有害的。另一方面，如果认为工程师只能等着设计师的线框图才能开始工作，这也是同样幼稚的。</p>
<p>用户体验设计的一个重要目的就是要降低用户的认知阻力（Cognitive Friction），即用户对于软件界面的认知（想象某事应该怎么做，想象某操作应该产生什么结果）和实际结果的差异。我们来看一个具体的例子，如果用户（一个生活在中国二线城市，有高中文化水平，有基本计算机基础的成年人）要在一个文稿中写居中的一句话，在下表所列的各种工具中，用户是怎么才能做到的。</p>
<p>倘若认知阻力大，学习曲线就会比较陡；但是经过学习和练习，如果用户适应了新的认知模式，工作效率便会有较大的提高。</p>
<p>作为练习，同学们可以讨论一下，如果用户用的是VI（或者Vim等变种），如何完成这一任务，这个编辑器的认知阻力有多大。一般用户对于VI这种强大编辑器的抱怨是，它有好几种模式（Mode），同样地敲键盘，有时候是输入文字，有时候是控制，我们常见的“纸和笔”没有这些不明显的“模式”。</p>
<p>需要指出的是，软件工程师往往以熟练掌握认知阻力大的工具而自豪（例如命令行操作、VI、Emacs等编辑器），这对于工程师的工作是有帮助的；但是大多数用户的心理是要躲避认知阻力。</p>
<p>用户体验设计有哪些步骤呢？一个成熟和常用的方法是分阶段进行设计和探讨（下表由左至右不断迭代细化）。<br><img src="http://upload-images.jianshu.io/upload_images/68937-96d4fc4ee3e6e889.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20170627-231009@2x.png"></p>
<h2 id="评价标准"><a href="#评价标准" class="headerlink" title="评价标准"></a>评价标准</h2><p>那么对于一个软件的用户界面，我们有没有什么评价标准呢？可以参考费茨法则（Fitts law）注释12、Nielsen启发式评估十条原则以及其他经验。</p>
<p>下面是作者在自身实践的基础上总结的一些原则：</p>
<p><strong>1.尽快提供可感触的反馈</strong><br>系统状态要有反馈，等待时间要合适。现在程序发生了什么，应该在某一个统一的地方清晰地标示出来。一个目标用户能够只靠软件的主要反馈来完成基本的操作，而不用事先学习使用手册。系统的反馈可以是视觉的、听觉的、触觉的（例如手机振动）。但是要避免简单重复的提示。</p>
<p><strong>2.系统界面符合用户的现实惯例</strong><br>与用户沟通，软件系统要使用用户语言而不是开发者语言，所用的概念要贴近生活实际，而不是用学术概念或开发者的概念。我们说的生活实际，最好是目标用户的实际生活体验。例如，在用户没有期待对话框的时候，软件从奇怪的角度弹出对话框，或者给用户提示“找不到对象”。<br><img src="http://upload-images.jianshu.io/upload_images/68937-99c1ca10f8175a14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20170625-142045@2x.png"></p>
<p><strong>3. 用户有控制权</strong><br>操作失误可回退，要让用户可以退出软件（很多软件都没有退出菜单，这是导致用户反感的一大原因）。用户可以定制显示信息的多少，还可以定制常用的设置。</p>
<p><strong>4. 一致性和标准化</strong><br>在软件中，对同一事物和同类操作的表示用语，各处要保持一致。例如，某词典软件有“帮助用户收集生词并且背诵生词”的功能。这个功能要有明确一致的称呼，不能混杂着叫“单词本”、“生词本”、“Word List”、“Word Book”、“单词文件”……等等。</p>
<p><strong>5. 适合各种类型的用户</strong><br>我们的软件要为新手和专家提供可定制化的设计。一些操作方式，如快捷操作，用户可以自行调整。我们还应该为存在某些障碍的用户（色弱、色盲、盲人、听力有缺陷的用户、操作键盘鼠标不方便的用户等）提供一定程度的便利。对于长期使用某个软件的用户，软件应该能适应用户的使用习惯，让用户越用越顺手，最后产生感情上的好感和忠诚度。</p>
<p>交互设计的一个原则是：如果某个看似不明显的交互操作解释过一次之后，就很容易理解，那么这就是一个好设计。</p>
<p><strong>6. 帮助用户识别、诊断并修复错误</strong><br>软件的关键操作要有确认提示，以便帮助用户及早消除误操作。要注意使用朴素的语言来表述错误信息。错误信息需要给出下一步操作提示（我现在出错了，那下一步怎么办）。必要时提供详细的帮助信息，并协助用户方便地从错误中恢复工作。</p>
<p>让所有的用户都可以通过电子邮件或者表单来提交反馈意见。有些程序用一对简单的笑脸/哭脸符号来鼓励用户提交反馈，这也是很好的办法。</p>
<p><strong>7. 有必要的提示和帮助文档</strong><br>不需要文档，用户就能使用自如，当然更好，必要时还可以提供在线帮助。有些软件在首次启动时会通过图示或动画展现某些新功能的用法，或引导用户进行一些基本的设置（例如第一次使用输入法时，让用户选择候选词的个数、字体大小，等等）。这些都是不错的方法。</p>
<hr>
<p>《构建之法》读书笔记之三</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件工程 </tag>
            
            <tag> 用户体验 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[程序员，软件测试知多少？]]></title>
      <url>/2017/06/24/softeware-test-know-how-much/</url>
      <content type="html"><![CDATA[<blockquote>
<p>送给初级程序员的测试认知文</p>
</blockquote>
<p>作为开发同学，一些基本的测试岗位相关知识还是很有必要了解一下，免的某些同学在工作中和测试同学斗嘴、打架、群殴等以及被测试鄙视….。</p>
<p>我们常常听说的一些测试专业术语，比如白盒、黑盒、单元测试，相信搞作为程序员的你脱口而出的就是这三个词汇吧，笔者在前几年对测试也仅仅停留在这个两个词汇上，更多的就不得而知了。后来在一家做跨境电商的公司学到了一些新术语，也见到了测试岗位的一些日常，比如冒烟测试、测试用例(TC)、回归测试、接口测试以及偶尔和我吵架等等。</p>
<p>白盒黑盒测试是按测试设计方法分类的，是指软件测试设计的方法，而不是软件测试的方法，注意这个区别。</p>
<p>黑盒测试是行为测试，即从软件的行为而不是内部结构触发来设计测试，也就是在软件上到处点点等。白盒指的是在设计测试的过程中，设计者可以“看到”软件系统的内部结构，并使用软件的内部结构和知识来选择测试数据及具体的测试方法。</p>
<h2 id="功能测试和非功能测试"><a href="#功能测试和非功能测试" class="headerlink" title="功能测试和非功能测试"></a>功能测试和非功能测试</h2><p>按测试的目，分为功能测试和非功能测试，单元测试是功能测试里的一种，每种测试的名称和内容如下：<br><img src="http://img.mukewang.com/594bf0a30001b04f13260506.png" alt="图片描述"></p>
<p>一个软件除了基本功能之外，还有很多功能之外的特性，这些叫非功能需求，或者服务质量需求。然而，若没有软件的基本功能，这些特性都将无从表现出来，因此，我们要在软件开发的适当阶段——基本功能完成后再来做这些非功能测试，非功能测试有如下这些<br><img src="http://img.mukewang.com/594bf1a00001bbc613620632.png" alt="图片描述"></p>
<h2 id="其他分类下的测试"><a href="#其他分类下的测试" class="headerlink" title="其他分类下的测试"></a>其他分类下的测试</h2><p>在开发软件的过程中，不少测试起着“烽火台”的作用，它们告诉我们软件开发的流程是否顺畅，比如冒烟测试是指测试不通过不能进行下一步工作，是一种基本验证测试，据说是从硬件设计行业流传过来的说法。当年设计电路板的时候，很多情况下，新的电路板一插上电源就冒起白烟，烧坏了。如果插上电源后没有冒烟，那就是通过了“冒烟测试”，可以进一步测试电路板的功能了。还有验证构建是否通过基本测试以及全面考核某方面的功能的验收测试。</p>
<p>另一些测试名称则是说明不同的测试方法<br><img src="http://img.mukewang.com/594bf0ca00010b0514120408.png" alt="图片描述"></p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>对于开发来讲，最最常用和熟悉的还是单元测试，怎样才算一个好的单元测试？单元测试应该准确、快速地保证程序基本模块的正确性。下面是验证单元测试好坏的一系列标准：</p>
<ul>
<li>单元测试应该在最基本的功能/参数上验证程序的正确性。</li>
<li>单元测试必须由最熟悉代码的人（程序的作者）来写。</li>
<li>单元测试过后，机器状态保持不变。如果单元测试创建了临时的文件或目录，应该在Teardown(拆卸)阶段删掉。如果单元测试在数据库中创建或修改了记录，那么也许要删除或恢复这些记录，或者每一个单元测试使用一个新的数据库，这样可以保证单元测试不受以前单元测试实例的干扰。</li>
<li>单元测试要快（一个测试的运行时间是几秒钟，而不是几分钟）。</li>
<li>单元测试应该产生可重复、一致的结果。</li>
<li>独立性—单元测试的运行/通过/失败不依赖于别的测试，可以人为构造数据，以保持单元测试的独立性。</li>
<li>单元测试应该覆盖所有代码路径。</li>
<li>单元测试应该集成到自动化测试的框架中。</li>
<li>单元测试必须和产品代码一起保存和维护。</li>
</ul>
<p>然并卵！都说国内很多程序员是不写单元测试的，甚至从来都不写，笔者当年做Java的时候也没写过几次（捂脸）。</p>
<h2 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h2><p>在单元测试的基础上，我们就能够建立关于这一模块的回归测试（Regression Test）。Regress：return to a worse or less developed state，是倒退、退化、退步的意思。在软件项目中，如果一个模块或功能以前是正常工作的，但是在一个新的构建中出了问题，那么这个模块就出现了一个“退步”（Regression），从正常工作的状态退化到不正常工作的状态。在一个模块的功能逐步完成的同时，与此功能有关的测试用例也同样在完善中。一旦有关的测试用例通过，我们就得到了此模块的功能基准线（Baseline），一个模块的所有单元测试就是这个模块最初的Baseline。</p>
<p>针对一个Bug Fix，我们也要做Regression(海退) Test。目的是：</p>
<ol>
<li>验证新的代码的却改正了缺陷。</li>
<li>同时要验证新的代码有没有破坏模块的现有功能，有没有Regression</li>
</ol>
<p>对于“回归测试”中的“回归”，我们可以将其理解为“回归到以前不正常的状态”。回归测试最好要自动化，因为这样就可以对于每一个构建快速运行所有回归测试，以保证尽早发现问题。单元测试是回归测试的基础。在专注于模块基本功能的单元测试之外，还有功能测试——从用户的角度检查功能完成得怎么样。</p>
<h2 id="探索性测试"><a href="#探索性测试" class="headerlink" title="探索性测试"></a>探索性测试</h2><p>探索性测试是为了某一个特定目的而进行的测试，且就这一次，以后一般也不会重复测试。在软件工程的实践中，“Ad hoc”大多是指随机进行的、探索性的测试。</p>
<p>探索式测试的测试流程是不可重复的，因为它的测试都是“特定”测试，没法重复。这一原因，使得探索式测试不能自动化，就这一点而言，还达不到CMMI二级——可重复级。</p>
<p>作为管理人员来说，如果太多的小强是在探索式测试中找出来的，那我们就要看看测试计划是否基于实际的场景，开发人员的代码逻辑是否完善，等等。</p>
<h2 id="场景-集成-系统测试"><a href="#场景-集成-系统测试" class="headerlink" title="场景/集成/系统测试"></a>场景/集成/系统测试</h2><p>在软件开发的一定阶段，我们要对一个软件进行全面和系统的测试，以保证软件的各个模块都能共同工作，各方面均能满足用户的要求。这类测试叫系统/集成测试。这一方法的核心思想是：当用户使用一个软件时，他/她并不会独立使用各个模块，而是把软件作为一个整体来使用。我们在做场景测试的时候，就需要考虑在现实环境中用户使用软件的流程是怎样的，然后模拟这个流程，看看软件能不能满足用户的需求。这样，才能使软件符合用户的实际需求。</p>
<p>应该什么时候做集成测试呢？是不是越早越好？原则上是当一个模块稳定的时候，就可以把它集成到系统中，和整个系统一起进行测试。在模块本身稳定之前就提早做集成测试，可能会报告出很多Bug，但是这些由于提早测试而发现的Bug，有点像汽车司机在等待绿灯时不耐烦而拼命地按喇叭——也就是说，有点像噪音。我们还是要等到适当的时机再开始进行集成测试。</p>
<p>了解完这些概念后，我们来看看究竟一个测试工程师的职责是怎么样的呢，下面列举一些：</p>
<ul>
<li>制定测试计划</li>
<li>设计与编写测试用例</li>
<li>实施测试</li>
<li>BUG跟踪</li>
<li>测试报告与总结</li>
<li>其他测试工程活动</li>
</ul>
<p>很多测试工作并不是说，有了测试工程师，把测试相关的全部事情扔给他们就完事了，需要开发和测试配合，共同完成某些测试任务，软件测试也不仅仅是为了发现bug然后提给开发，测试=质量保障，提升质量相关的都是测试工程师需要关注和负责的，软件测试的目标是帮助项目打造用户喜欢的产品。</p>
<hr>
<p>《构建之法》读书笔记之二</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[你会靠谱的进行(Bug)错误报告吗？]]></title>
      <url>/2017/06/21/bug-report/</url>
      <content type="html"><![CDATA[<p>我们知道，在软件项目中经常会有各种或大或小的Bug，更甚一点出现Error。那么如何清晰无异议的提出Bug呢？是不是经常遇到别人给你说某某地方有个Bug，然后就没有然后了…你是什么反应？或者一个功能表面上看起来都是正常的，但他说结果错了，然后呢，然后也没然后了，你去看了一下，好像都正常，没有报错什么的，这时候你是什么反应？</p>
<p>常见的两种提Bug的情况：</p>
<ul>
<li>第一种，只说错误现象。在没有明显的错误情况下，报告错误而不说正确的结果应该是什么，没有应该正确的结果（预期结果）对比，光说错误相当于污蔑。</li>
<li>第二种，描述笼统。</li>
<li>第三种，Bug point缺乏上下文。比如说，某个页面里的一个功能按钮有bug，如果直接报告这个功能按钮，你是一下子反应不过来的，你的系统分为很多大模块，然后下面有小模块，然后下面有很多页面，这个页面里有很多功能按钮，甚至很多页面都有相同的按钮，那么到底是说哪个页面的功能按钮有Bug呢？</li>
</ul>
<p>下图是我司禅道项目管理系统中今天分配给我的一个真实任务：<br><img src="http://img.mukewang.com/594b71bd00014df105450593.png" alt="图片描述"></p>
<p>部分具体是指哪些？位置从哪调整到哪？新增的薪资模块又是什么，放哪？有没有想骂人的冲动？？ 如果不想详细表达好歹可以来一张示意图吧….</p>
<p>比如，张三创建了一个Bug给李四</p>
<blockquote>
<p>标题：挂了<br>  内容：我今天在玩XXXX网的时候，发现XXXX网站挂了。</p>
</blockquote>
<p>这个Bug对问题的描述太过笼统，开发人员根本无从下手。李四拿到这个Bug，也是哭笑不得，试了试网站的各个页面，好像也都正常。他于是把这个Bug又推给张三，“哪里挂了？”</p>
<p>过了一会儿，张三回复“在我的机器上挂了”。</p>
<p>李四跑到张三的座位上，想看看“犯罪现场”。</p>
<p>张三：我刚重启了机器……</p>
<p>两人等到启动完毕，打开网页，发现一切正常。</p>
<p>张三：（纳闷了）昨天晚上的确是挂了。网页上还有一些错误信息。我当时正在干什么来着，好像是在留言或在论坛上发帖子，我现在也记不清了。让我再玩玩，等碰到了再叫你。</p>
<p>李四：这样九条浪费了两个人各一个小时的时间，最后什么进展也没有。一个好的Bug报告应该是这样的：</p>
<blockquote>
<p>标题：购物网站的某个具体页面（URL），在回复中提交大于100KB的文字时会出错内容有以下几点：<br>  环境：<br>  在Windows XP下，使用IE7。允许Cookie。购物网的版本是1.2.40。<br>  重现步骤：<br>  1）用[用户名，密码]登录。这一用户在系统中是一般用户。<br>  2）到某一产品页面（链接为：……）。<br>  3）选中一个帖子，例如：帖子号为579。<br>  4）回复帖子，在内容中粘贴100KB的文字内容（文本内容见附件）。<br>  结果：网站出错，错误信息为：[略]<br>  预期结果：网站能完成操作，或者提示用户文本内容过大。[在附件中加入100KB的文本文件]。</p>
</blockquote>
<p>测试人员还可以附上其他分析，团队应该鼓励测试人员追根溯源。如果看到测试人员发来这样的Bug报告，那么开发人员就能够很快地重现这一问题，从而有效地分析和解决问题。</p>
<p>那么，靠谱受欢迎的Bug报告要怎么提？</p>
<p>软件项目管理工具通常支持多种类型的记录，“任务(Task)”和“缺陷(Bug)”是最基本的两种记录，任务=要做的事情，缺陷=意外发生的故障。当软件工程师完成了预定的任务，达到“代码完成”之后，团队的成员主要用Bug这种类型的记录来交流。在一定规模的软件项目中，一份好的错误报告，至少要满足以下几点。</p>
<ol>
<li>Bug的标题，要能简要说明问题。</li>
<li>Bug的内容要写在描述中，包括：<br>a. 测试的环境和准备工作。<br>b. 测试的步骤，清楚地列出每一步做了什么。<br>c. 实际发生的结果。<br>d. （根据软件功能说明书和用户的期望）应该发生的结果。</li>
<li>如有其他补充材料，例如相关联的Bug、输出文件、日志文件、调用堆栈的列表、截屏等，应保存在Bug对应的附件或链接中。</li>
<li>还可以设置Bug的严重程度（Severity）、功能区域等，这些都可以记录在不同的字段中。</li>
</ol>
<p>在实际生活中，在没有规范的前提下，请尽量做的规范一点，心中有佛，随处修行</p>
<hr>
<p>《构建之法》读书笔记之一</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue.js项目API、Router配置拆分实践]]></title>
      <url>/2017/06/20/Vue-js-api-router-split/</url>
      <content type="html"><![CDATA[<h2 id="前后端分离开发方式前端拥有更高的控制权"><a href="#前后端分离开发方式前端拥有更高的控制权" class="headerlink" title="前后端分离开发方式前端拥有更高的控制权"></a>前后端分离开发方式前端拥有更高的控制权</h2><p>随着前端框架技术的飞速发展，Router这个概念也被迅速普及到前端项目中，在早期前后的没有分离的时期下，并没有明确的路由概念，前端页面跳转大多是通过后端进行请求转发的，比如在Spring MVC项目中，进行一个页面跳转如下（画红线部分）：<br><img src="http://upload-images.jianshu.io/upload_images/68937-f03ed7ab6e640bbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="code-0620-1.png"></p>
<p>前端需要一个超链接，链接的href=/manager，这样这个超链接被转发到scs/waitFollowed路径指定的页面。</p>
<p>前后的分离后，前端页面跳转的方式发生了变化，不再需要后端处理了，数据交换方式也改变了，由此前端需要定义Router配置文件，需要定义API配置文件。在项目的权限配置管理中，完全不需要后端什么事了，可以说，权限配置表可以单独拿出来由前端维护了。<br><img src="http://upload-images.jianshu.io/upload_images/68937-b498a4b16768dc4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TIM截图20170620113459.png"></p>
<p>比如这个url字段，在前后端不分离的情况下，严重依赖于后端，url就是后端接口地址，如果需要更改就需要后端修改代码修改接口地址，而现在，前端可以自由控制url的值是什么了。</p>
<p>在接口层面，前端也会有自己的配置文件，可以对后端提供的接口进行重命名，组合等。比如<br><img src="http://upload-images.jianshu.io/upload_images/68937-4b28c44760b767bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="code-0620-2.png"></p>
<p>前端都统一使用<code>模块名+接口名</code>的方式管理，管后端提供的接口叫啥已经不重要，在视觉上和维护上都比较方便。在页面上使用，查询起来也很直观：<br><img src="http://upload-images.jianshu.io/upload_images/68937-2c37fb6e4f8d75fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="code-0620-3.png"></p>
<p>看到<code>DISTRBUTE().Leads.dataGrid</code>这个接口，就知道这是<code>DISTRBUTE</code>模块下<code>Leasd</code>功能下的列表查询接口</p>
<h2 id="Vue-js中的API、Router配置"><a href="#Vue-js中的API、Router配置" class="headerlink" title="Vue.js中的API、Router配置"></a>Vue.js中的API、Router配置</h2><p>在Vue.js项目下，一开始我们只使用一个<code>api.config.js</code>配置文件，所有的接口都定义在这里面，router也一样，都配置在一个<code>router.config.js</code>中，下面是我们项目中API配置文件<br><img src="http://upload-images.jianshu.io/upload_images/68937-8b2545e71f3ef362.gif?imageMogr2/auto-orient/strip" alt="GIF.gif"></p>
<p>可以看到，很多的业务模块，很多的接口，已经达到了570多行，随着业务进一步推进，接口快速膨胀，文件越来越大。</p>
<p>这时候迫切需要拆分，把不同的业务模块单独拆分为一个个API配置文件。同样，我们来看看拆分前的Router配置文件：<br><img src="http://upload-images.jianshu.io/upload_images/68937-fd575cd42a645538.gif?imageMogr2/auto-orient/strip" alt="GIF2.gif"></p>
<p>这样router一多最大的缺点就是会导致router命名冲突。</p>
<h2 id="拆分！拆分！拆分！"><a href="#拆分！拆分！拆分！" class="headerlink" title="拆分！拆分！拆分！"></a>拆分！拆分！拆分！</h2><p>首先考虑API配置文件怎么拆分，对于接口，我们肯定有多套环境，多套环境那么API的URL也不一样，拆分成多个文件后多个文件需要共用同一个获取<code>apiBase</code>的方法，所以这个<code>apiBase</code>就要写在公共的地方，在这里原来的<code>api.config.js</code>就变成了公共配置，<code>apiBase</code>就放在此文件内。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">apiBase</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> hostname = <span class="built_in">window</span>.location.hostname,</div><div class="line">    API_BASE_URL = <span class="string">'http://test2api.dunizb.com'</span>;<span class="comment">//默认环境</span></div><div class="line">  <span class="keyword">if</span>(hostname === <span class="string">'crm.dunizb.cn'</span>) &#123;  <span class="comment">//正式环境</span></div><div class="line">    API_BASE_URL = <span class="string">'http://api.dunizb.cn'</span>;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(hostname === <span class="string">'admin.dunizb.com'</span>) &#123;<span class="comment">//公网测试环境</span></div><div class="line">    API_BASE_URL = <span class="string">'http://testapi.dunizb.com'</span>;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(hostname === <span class="string">'manager.dunizb.com'</span>) &#123;<span class="comment">//内网测试环境</span></div><div class="line">    API_BASE_URL = <span class="string">'http://test2api.dunizb.com'</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> API_BASE_URL;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在每个子API配置文件中引入即可：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;apiBase&#125; <span class="keyword">from</span> <span class="string">'../api.config'</span>;</div></pre></td></tr></table></figure></p>
<p>具体功能API不需要更改，直接拷贝相应模块API到子模块API配置文件即可。<br><img src="http://upload-images.jianshu.io/upload_images/68937-8be4224d09ef444d.gif?imageMogr2/auto-orient/strip" alt="GIF3.gif"></p>
<p>Router的拆分稍微复杂一点，拆分后的文件目录与API的目录相同：<br><img src="http://upload-images.jianshu.io/upload_images/68937-ad998c0c3b66f044.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="code-0620-4.png"></p>
<p>拆分思路也完全一样，但要保证只有一个<code>router.start</code>即：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> router.start(App, <span class="string">'#app'</span>);</div></pre></td></tr></table></figure></p>
<p>虽然你在子router配置文件中也写上页面是能正常工作的，但是Vue.js会在控制台报一个错误：<br><img src="http://upload-images.jianshu.io/upload_images/68937-4a2541ad4fb7ce30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="code-0620-5.png"></p>
<p>这个错误的意思就是router已经启动，无需启动多次。所以，子router文件中不能存在 <code>return router.start(App, &#39;#app&#39;);</code> 这样的代码。</p>
<p>拆分后<code>router.config.js</code>内容如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 路由总文件</div><div class="line"> * Created by Bing on 2017/6/19 0019.</div><div class="line"> */</div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</div><div class="line"><span class="keyword">import</span> authority <span class="keyword">from</span> <span class="string">'./routers/authority'</span>;</div><div class="line"><span class="keyword">import</span> publics <span class="keyword">from</span> <span class="string">'./routers/public'</span>;</div><div class="line"><span class="keyword">import</span> study <span class="keyword">from</span> <span class="string">'./routers/study'</span>;</div><div class="line">... ...</div><div class="line">export <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">router</span>)</span>&#123;</div><div class="line">  authority(router);<span class="comment">//基础与权限模块</span></div><div class="line">  publics(router);<span class="comment">//公共模块</span></div><div class="line">  study(router);<span class="comment">//教学相关</span></div><div class="line">  ... ...</div><div class="line">  return router.start(App, <span class="string">'#app'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而子router配置文件的写法就是这样（以study模块为例）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 教学排课</div><div class="line"> * 教研</div><div class="line"> * Created by Bing on 2017/6/19 0019.</div><div class="line"> */</div><div class="line"><span class="keyword">import</span> courseIndex <span class="keyword">from</span> <span class="string">'components/studyCourse/index/index'</span>;</div><div class="line"><span class="keyword">import</span> waitCourse <span class="keyword">from</span> <span class="string">'components/studyCourse/waitCourse/waitCourse'</span>;</div><div class="line"><span class="keyword">import</span> alreadyCourse <span class="keyword">from</span> <span class="string">'components/studyCourse/alreadyCourse/alreadyCourse'</span>;</div><div class="line"><span class="keyword">import</span> gearCourse <span class="keyword">from</span> <span class="string">'components/studyCourse/waitCourse/gearCourse'</span>;</div><div class="line"><span class="keyword">import</span> courseWare <span class="keyword">from</span> <span class="string">'components/teachingResearch/courseware/courseware.vue'</span>;</div><div class="line"><span class="keyword">import</span> courseWareLibrary <span class="keyword">from</span> <span class="string">'components/teachingResearch/courseware/library.vue'</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">router</span>) </span>&#123;</div><div class="line">  router.map(&#123;</div><div class="line">    <span class="string">'/study/index'</span>: &#123;<span class="attr">component</span>: courseIndex&#125;,</div><div class="line">    <span class="string">'/study/waitCourse'</span>: &#123;<span class="attr">component</span>: waitCourse&#125;,<span class="comment">//待排课程</span></div><div class="line">    <span class="string">'/study/waitCourse/gearCourse'</span>: &#123;<span class="attr">component</span>: gearCourse&#125;,<span class="comment">//待排</span></div><div class="line">    <span class="string">'/study/course'</span>: &#123;<span class="attr">component</span>: alreadyCourse&#125;,<span class="comment">//已排课程</span></div><div class="line">    <span class="string">'/tr/courseware'</span>: &#123;<span class="attr">component</span>: courseWare&#125;,<span class="comment">//课件管理</span></div><div class="line">    <span class="string">'/tr/courseWare/library'</span>: &#123;<span class="attr">component</span>: courseWareLibrary&#125;,<span class="comment">//自主上传课件库</span></div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>拆分后，每个模块管理它自己领域的router、api，router.config.js和api.config.js就大大瘦身了，也降低了命名冲突的问题和将来混乱的问题。</p>
<hr>
<p>此前的Vue.js系列文章：</p>
<ul>
<li><a href="http://dunizb.com/2016/12/18/Vue.js常用开发知识简要入门（一）">Vue.js常用开发知识简要入门（一）</a></li>
<li><a href="http://www.jianshu.com/p/ce9fc4c8a7ce" target="_blank" rel="external">Vue.js常用开发知识简要入门（二）</a></li>
<li><a href="http://dunizb.com/2017/02/13/Vue.js常用开发知识简要入门（三）">Vue.js常用开发知识简要入门（三）</a></li>
<li><a href="http://dunizb.com/2017/06/19/Vue.js开发常见问题解析/">Vue.js开发常见问题解析</a></li>
<li><a href="http://dunizb.com/2017/06/19/Vue.js动态组件解析/">Vue.js动态组件解析</a></li>
</ul>
<hr>
<p> 本人出售《Vue.js权威指南》，二手价20元！点击下图购买</p>
<p> <strong>++++++++++<a href="http://dunizb.com/obook/">20元出售此书</a>++++++++++</strong><br><a href="http://dunizb.com/obook/"><img src="http://upload-images.jianshu.io/upload_images/68937-4b8b1cbd73a8fd1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Vue.js权威指南"></a></p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Vue.js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue.js动态组件解析]]></title>
      <url>/2017/06/19/Vue.js%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/68937-9dc1cd5e606ff6fd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Vue.js"><br>此前的Vue.js系列文章：</p>
<ul>
<li><a href="http://dunizb.com/2016/12/18/Vue.js常用开发知识简要入门（一）">Vue.js常用开发知识简要入门（一）</a></li>
<li><a href="http://www.jianshu.com/p/ce9fc4c8a7ce" target="_blank" rel="external">Vue.js常用开发知识简要入门（二）</a></li>
<li><a href="http://dunizb.com/2017/02/13/Vue.js常用开发知识简要入门（三）">Vue.js常用开发知识简要入门（三）</a></li>
<li><a href="http://dunizb.com/2017/06/19/Vue.js开发常见问题解析/">Vue.js开发常见问题解析</a></li>
</ul>
<p>什么是动态组件绑定？简单的说，就是几个组件放在一个挂载点下，然后根据父组件的某个变量来决定显示哪个，或者都不显示。</p>
<h2 id="is属性"><a href="#is属性" class="headerlink" title="is属性"></a>is属性</h2><p>在挂载点使用component标签，然后使用<code>v-bind:is=&quot;组件名&quot;</code>，会自动去找匹配的组件名，如果没有，则不显示；改变挂载的组件，只需要修改<code>is</code>指令的值即可。<br>HTML：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"one"</span> <span class="attr">value</span>=<span class="string">"fast"</span> <span class="attr">v-model</span>=<span class="string">"currentView"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"one"</span>&gt;</span>fast<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">br</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"two"</span> <span class="attr">value</span>=<span class="string">"bus"</span> <span class="attr">v-model</span>=<span class="string">"currentView"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"two"</span>&gt;</span>bus<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">br</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"three"</span> <span class="attr">value</span>=<span class="string">"business"</span> <span class="attr">v-model</span>=<span class="string">"currentView"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"three"</span>&gt;</span>business<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"currentView"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 组件在 vm.currentView 变化时改变 --&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">component</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>JS：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建根实例</span></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">el</span>: <span class="string">"#example"</span>,</div><div class="line">  <span class="attr">data</span>: &#123;</div><div class="line">    <span class="attr">currentView</span>: <span class="string">'bus'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">components</span>: &#123;</div><div class="line">    <span class="attr">fast</span>: &#123;<span class="attr">template</span>: <span class="string">'&lt;div&gt;滴滴快车&lt;/div&gt;'</span>&#125;,</div><div class="line">    <span class="attr">bus</span>: &#123;<span class="attr">template</span>: <span class="string">'&lt;div&gt;滴滴巴士&lt;/div&gt;'</span>&#125;,</div><div class="line">    <span class="attr">business</span>: &#123;<span class="attr">template</span>: <span class="string">'&lt;div&gt;滴滴专车&lt;/div&gt;'</span>&#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>通过<code>is</code>属性绑定的<code>vm.currentView</code>变量值，控制展示的组件，<a href="http://jsrun.net/aVYKp" target="_blank" rel="external">在线查看效果</a></p>
<h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><p>简单来说，被切换掉（非当前显示）的组件，是直接被移除了。如果把切换出去的组件保留在内存中，则可以保留它的状态或避免重新渲染。为此，可以添加一个keep-alive指令参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;keep-alive&gt;</div><div class="line">   <span class="xml"><span class="comment">&lt;!-- 非活动组件将被缓存 --&gt;</span></span></div><div class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"currentView"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>Vue.js为其组件设计了一个<code>keep-alive</code>特性，如果这个特性存在，那么在组件被重复创建时，会通过缓存机制快速创建组件，以提升视图更新性能。</p>
<h2 id="activate钩子"><a href="#activate钩子" class="headerlink" title="activate钩子"></a>activate钩子</h2><p>简单来说，他是延迟加载。 例如，在发起ajax请求时，会需要等待一些时间，假如我们需要在ajax请求完成后，再进行加载，那么就需要用到<code>activate</code>钩子了。</p>
<p>具体用法来说，activate是和template、data等属性平级的一个属性，形式是一个函数，函数里默认有一个参数，而这个参数是一个函数，执行这个函数时，才会切换组件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'activate-example'</span>, &#123;</div><div class="line">    activate(done) &#123;</div><div class="line">        <span class="keyword">let</span> _this = <span class="keyword">this</span>;</div><div class="line">        loadDataAsync(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">            _this.someData = data;</div><div class="line">            done();</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><code>activate</code>钩子只作用于动态组件切换或静态组件初始化渲染的过程中，不作用于使用实例方法手工插入的过程中。</p>
<hr>
<p><strong>++++++++++<a href="http://dunizb.com/obook/">本人出售《Vue.js权威指南》，二手价20元！</a>++++++++++</strong><br><a href="http://dunizb.com/obook/"><img src="http://upload-images.jianshu.io/upload_images/68937-4b8b1cbd73a8fd1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Vue.js权威指南"></a></p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Vue.js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue.js开发常见问题解析]]></title>
      <url>/2017/06/19/Vue.js%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/68937-9dc1cd5e606ff6fd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Vue.js"><br>此前的Vue.js系列文章：</p>
<ul>
<li><a href="http://dunizb.com/2016/12/18/Vue.js常用开发知识简要入门（一）">Vue.js常用开发知识简要入门（一）</a></li>
<li><a href="http://www.jianshu.com/p/ce9fc4c8a7ce" target="_blank" rel="external">Vue.js常用开发知识简要入门（二）</a></li>
<li><a href="http://dunizb.com/2017/02/13/Vue.js常用开发知识简要入门（三）">Vue.js常用开发知识简要入门（三）</a></li>
</ul>
<h2 id="camelClass-amp-kebab-case"><a href="#camelClass-amp-kebab-case" class="headerlink" title="camelClass &amp; kebab-case"></a>camelClass &amp; kebab-case</h2><p>HTML标签中的属性名不区分大小写。设置prop名字为camelClass形式的时候，需要转换为kebab-case形式（短横线）在HTML中使用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'child'</span>, &#123;</div><div class="line">    <span class="comment">//这里可以是camelClass形式</span></div><div class="line">    props: [<span class="string">'myMessage'</span>],</div><div class="line">    <span class="attr">template</span>: <span class="string">'&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;'</span></div><div class="line">&#125;);</div><div class="line"><span class="xml"><span class="comment">&lt;!-- 对应在HTML中必须是短横线分隔 --&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">my-message</span>=<span class="string">"hello"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="字面量语法-amp-动态语法"><a href="#字面量语法-amp-动态语法" class="headerlink" title="字面量语法 &amp; 动态语法"></a>字面量语法 &amp; 动态语法</h2><p>这个问题比较绕，也算是一个笔记常犯的一个错误吧，使用字面量语法传递数值：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 传递了一个字符串“1” --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">some-prop</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>因为他是一个字面prop，它的值是字符串“1”，而不是以实际的数字传递下去。如果想传递一个真实的JavaScript类型的数字，则需要使用动态语法，从而让它的值被当做JavaScript表达式计算。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 传递实际的数字 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">:some-prop</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="模板解析"><a href="#模板解析" class="headerlink" title="模板解析"></a>模板解析</h2><p>Vue的模板是DOM模板，使用浏览器原生的解析器而不是自己实现一个。相比字符串模板，DOM模板有一些好处，但是也有问题，它必须是有效的HTML片段。一些HTML元素对什么元素可以放在它里面有限制。常见的限制有：</p>
<ul>
<li>a不能包行其他的交互元素（如按钮、链接）</li>
<li>ul和ol只能直接包含li。</li>
<li>select只能包含option和optgroup。</li>
<li>table只能直接包含thead、tbody、ftoot、tr、caption、col、colgroup。</li>
<li>tr只能直接包含th和td。</li>
</ul>
<p>在实际应用中，这些限制会导致意外的结果。尽管再简单的情况下它可能可以工作，但是我们不能依赖自定义组件在浏览器验证之前展开结果。例如<code>&lt;my-select&gt;&lt;option&gt;....&lt;/option&gt;&lt;/my-select&gt;</code>不是有效的模板，即使<code>my-select</code>组件最终展开为<code>&lt;select&gt;...&lt;/select&gt;</code>。</p>
<p>另一个结果是，自定义标签（包括自定义元素和特殊标签，如<code>&lt;component&gt;</code>、<code>&lt;template&gt;</code>、<code>&lt;partial&gt;</code>）不能用在ul、select、table等对内部元素有限制的标签内。放在这些元素内的自定义标签将被提到元素的外面，因而渲染不正确。</p>
<p>自定义元素应当使用<code>is</code>特性，如<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">"my-component"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><code>&lt;template&gt;</code>不能用在<code>&lt;table&gt;</code>内，这时应该使用<code>&lt;tbody&gt;</code>，<code>&lt;table&gt;</code>可以有多个<code>&lt;tbody&gt;</code>。如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">tbody</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span>Even row<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span>Odd row<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="如何解决数据层级结构太深的问题"><a href="#如何解决数据层级结构太深的问题" class="headerlink" title="如何解决数据层级结构太深的问题"></a>如何解决数据层级结构太深的问题</h2><p>在开发业务的时候，经常会出现异步获取数据的情况，有时候数据层次比较深。如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"airport"</span> <span class="attr">v-text</span>=<span class="string">"ticketInfo.flight.fromSegments[ticketInfo.flight.fromSegment - 1].depAirportZh"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>我们可以使用<code>vm.$set</code>手动定义一层数据。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vm.$set(<span class="string">"depAirportZh"</span> ,ticketInfo.flight.fromSegments[ticketInfo.flight.fromSegments - <span class="number">1</span>] .depAirportZh)</div></pre></td></tr></table></figure></p>
<h2 id="data中没有定义计算属性，它是如何被使用的"><a href="#data中没有定义计算属性，它是如何被使用的" class="headerlink" title="data中没有定义计算属性，它是如何被使用的"></a>data中没有定义计算属性，它是如何被使用的</h2><p>如下代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;div id="example"&gt;</div><div class="line">    a = &#123;&#123; a &#125;&#125;, b = &#123;&#123; b &#125;&#125;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">var vm = new Vue(&#123;</div><div class="line">    el: '#example',</div><div class="line">    data: &#123;</div><div class="line">        a: 1</div><div class="line">    &#125;,</div><div class="line">    computed: &#123;</div><div class="line">        b: function() &#123;</div><div class="line">            return this.a + 1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>对于上面计算属性b是怎么被使用的？实际上它并没有把计算数据放到<code>$data</code>里，而是通过<code>Object.definePropert(tihs, key, def)</code>直接定义到了实例上。</p>
<hr>
<p>《Vue.js权威指南》读书笔记</p>
<p><strong>++++++++++<a href="http://dunizb.com/obook/">本人出售《Vue.js权威指南》，二手价20元！</a>++++++++++</strong><br><a href="http://dunizb.com/obook/"><img src="http://upload-images.jianshu.io/upload_images/68937-4b8b1cbd73a8fd1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Vue.js权威指南"></a></p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Vue.js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[锤子坚果Pro细红线版开箱及使用体验]]></title>
      <url>/2017/05/14/%E9%94%A4%E5%AD%90%E5%9D%9A%E6%9E%9CPro%E7%BB%86%E7%BA%A2%E7%BA%BF%E7%89%88%E5%BC%80%E7%AE%B1%E5%8F%8A%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/</url>
      <content type="html"><![CDATA[<p>一直打算该换一个手机了，目前使用的是魅蓝Note，现在魅蓝都出到第五代了。一直在观望各大手机厂商新品，重点考虑了小米、魅族，锤子之前发布的几款手机我并没有非常动心，小米手机说实话我最喜欢的还是小米4，魅族的手机外观却实越来越好看了，是我喜欢的审美风格，我喜欢的是四四方方硬朗的造型，刚好现在锤子坚果Pro正好是这样，没有随大流做成圆圆润润的。看完老罗的发布会立刻就下单了，买的是细红线128G版本。</p>
<p>这些照片是晚上室内用魅蓝Note拍的，凑合看吧。</p>
<h2 id="一、开箱晒图"><a href="#一、开箱晒图" class="headerlink" title="一、开箱晒图"></a>一、开箱晒图</h2><p>外包装盒<br><img src="http://upload-images.jianshu.io/upload_images/68937-cc2657227229e9f1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P70512-211705.jpg"><br>现在的手机厂商对外包装盒都越来越重视了，都做成硬纸盒形式，我记得最先是小米这样做的，黄黄的牛皮纸包装盒，说是跟砖头一样硬朗靠谱抗压。<br><img src="http://upload-images.jianshu.io/upload_images/68937-3c097e42ced22368.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P70512-211746.jpg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-0544a0c8924364f0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P70512-211853.jpg"><br>打开盖子，锤子风格的标语映入眼帘，手机看起来比较长、、、、</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-2f2e12b2fdebe6b8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P70512-212002.jpg"><br>撕掉保护膜后的背面</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-9a3bc5b55492dcb9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P70512-212129.jpg"><br>继续开箱</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-e08efbfaef335716.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P70512-212705.jpg"><br>拿掉手机，说明书、卡针静静的躺在下面，我另外买里99元的碎屏险服务，可以免费更换一次原装屏幕组件。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-46787de939a8552d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P70512-212739.jpg"><br>长长的说明书</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-cb6f9a58fe3d8c19.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P70512-212914.jpg"><br>说明书下面就是电源、电源线等配件了，这个插头有点大啊，支持快充的</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-b8ff9b469da0bb45.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P70512-212940.jpg"><br>锤子坚果Pro跟苹果一样去掉了3.5mm耳机插孔，改成USB-TYPEC接口，所以原装配了一个音频转接线</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-2fce11b7e8f45f59.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P70512-213023.jpg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-ae2045afe77f85dc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P70512-213057.jpg"></p>
<p>好了，开箱完毕！</p>
<h2 id="二、三围"><a href="#二、三围" class="headerlink" title="二、三围"></a>二、三围</h2><p><img src="http://upload-images.jianshu.io/upload_images/68937-7acc2d9099179f97.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P70512-212325.jpg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-3d02ca186d730a51.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P70512-212357.jpg"><br>手机背面，玻璃，我感觉我又多了块便携的镜子。。。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-d76afebd6a228ec5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P70513-151317.jpg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-885d6df5da5c2d4a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P70513-151437.jpg"><br>双面玻璃还是很美的</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-2f0a36df3ebb1699.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P70512-215948.jpg"><br>熟悉的锤子风格桌面和系统</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-03772afd15ef07ff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P70513-151522.jpg"><br>侧面，所谓的细红线其实就是带颜色的斜切面，说成是细红线有点牵强其实、、、、</p>
<h2 id="三、使用体验"><a href="#三、使用体验" class="headerlink" title="三、使用体验"></a>三、使用体验</h2><p>用了两天，感觉手机很细长、、、额头和下巴比较大，这在其他手机上已经很少见了，现在都流行大屏占比了。比较轻薄，至于手感，我觉得没有什么好坏，圆润手感就好？至于割手问题其实也没什么，拿习惯了这点小毛病无伤大雅忽律不计。</p>
<p>开机后第一时间更新系统到3.6版本，相比以前看到的锤子系统，现在的锤子系统感觉已经变化了好多，桌面可以选择非9宫格桌面了，One Step操作起来也很方便，左上角或者右上角画一下就能启用，内置APP也多了几个，比如锤子论坛、M1系列发布会时新增的远程协助、屏幕录像，现在还增加了手机管理、HandShaker，这两个之前貌似是没有的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-d299862507516094.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screenshot_2017-05-14-13-13-51-294.png"><br>手机管理APP，暂时没有流量管理功能，不能输入月总流量、已用流量查看还剩多少流量的功能，这个功能缺失我比较意外，这应该是手机管理类APP的标配功能了。手机管理title下的黄色小字“S.H.I.E.L.D.”不知道啥意思、、、</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-357a0095ce607068.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screenshot_2017-05-14-13-07-39-431.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-68d8e8f32f2e5887.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screenshot_2017-05-14-13-09-50-044.png"><br>不得不说，SmartisanOS在设计、交互上还是很特别的，第一次用需要一点点学习时间掌握一些特别的操作。至于系统流畅性我觉得没什么好说的，新手机嘛，那肯定流畅啊，本来想跑分看看，但是锤子手机对跑分做了劣化，所以就没什么意义了，由于我不玩游戏，所以也没测试过游戏表现。有经验的你，看看配置就知道了。</p>
<p>续航还真给力，老罗没吹牛。</p>
<h2 id="四、糟点"><a href="#四、糟点" class="headerlink" title="四、糟点"></a>四、糟点</h2><p>锤子也是不完美的。坚果Pro，这个价位，非常值得买，唯一我个人觉得是糟点的地方一是正面屏幕，二是没了3.5mm耳机孔。坚果Pro的正面玻璃和边框结合的不是太好，有明细的缝隙</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-ee8c14a73dfe0150.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P70514-132257.jpg"><br>而背面处理的稍微好一些</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-ba5abfd4d3914628.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="P70514-132321.jpg"></p>
<p>没了3.5mm耳机插孔，要么配合使用音频转接头，要么买个type-c接口的耳机。虽然我不喜欢这样，但貌似这又是手机界的设计趋势。</p>
<p>坚果Pro毕竟是一款中低端的手机，价格摆在哪里了，就不要想那些有点没得了，支持锤科，支持老罗！</p>
]]></content>
      
        <categories>
            
            <category> 随笔扯谈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《她理财·蜜财周刊》怎样开源怎样花钱]]></title>
      <url>/2017/04/22/%E3%80%8A%E5%A5%B9%E7%90%86%E8%B4%A2%C2%B7%E8%9C%9C%E8%B4%A2%E5%91%A8%E5%88%8A%E3%80%8B%E6%80%8E%E6%A0%B7%E5%BC%80%E6%BA%90%E6%80%8E%E6%A0%B7%E8%8A%B1%E9%92%B1/</url>
      <content type="html"><![CDATA[<blockquote>
<p>她理财网出品的理财周刊部分期刊内容笔记，我觉得非常好，和大家分享一下，赚钱难，花钱易，那我么该怎么办？</p>
</blockquote>
<h2 id="别把开源玩坏了，开源要什么？"><a href="#别把开源玩坏了，开源要什么？" class="headerlink" title="别把开源玩坏了，开源要什么？"></a>别把开源玩坏了，开源要什么？</h2><p>通过上面的实践，我觉得开源不应该盲目，不要觉得挣点儿钱就挺好的，其实人的时间精力有限还是要和长远目标相结合。每个人的开源方法不同，需求也不一样，但是评价一个开源项目优劣的标准应该是类似的。下面就说一下我的总结：<br><strong>1.开源考虑的是时间和收益的性价比</strong></p>
<p>如果一个开源项目耗费时间但是收益不高，比不上本职工作的时薪水平，我觉得可以慎重考虑，把精力省下来用在工作上提高绩效、多出成绩，往往比向外开源效果好。如果因此升职加薪了，职业生涯就上了一个新台阶，获益可不是小小开源能匹配的。</p>
<p><strong>2.开源是长期目标和短期目标的结合</strong></p>
<p>开源往往牺牲的是我们的休闲时间，不要觉得整天玩儿也没什么用，开阔眼界丰富生活都是个人成长的养分，开源项目如果和你的未来发展规划相一致，能够增加资历、积累经验那是再好不过的，这时就不要斤斤计较收入的多少了，合适的开源可能带来发展机会，就像我的前同事妹子，通过一个做旅游书的项目成功跳槽到外版旅行杂志工作，现在全世界品美酒、住酒店，实现了职业转变。</p>
<p><strong>3.开源是否能带来钱以外的收获</strong></p>
<p>有时候开源机会真不是有意赚钱，比如说兴趣爱好干得好了获得欣赏，有了赚钱机会。这样的开源是工作的美好平衡，干得美滋滋的事情还能赚钱当然就不要放弃啦。</p>
<p><strong>4.开源还要看你处于什么人生阶段我想对一个开源项目的选择还跟处于什么人生阶段相关。</strong></p>
<p>如果是刚如社会的年轻妹子，甚至还是学生党，无论开源做什么都是人生经历的一部分，摆个摊啊，做个家教啦，这些事情未必很能赚钱，也未必能获得了不得的工作经验，但做总比不做强，任何经验对未来都是很宝贵的；而如果年过三十，正处于事业上升的关键期，我觉得开源要慎重，最好把精力放在专注发展的事业上，不要轻易分心，开源必须服务于整体人生规划。</p>
<h2 id="我的开源经验"><a href="#我的开源经验" class="headerlink" title="我的开源经验"></a>我的开源经验</h2><p>总结下我这一年奋斗的小经验、小感触，希望对大家有用。</p>
<p><strong>1.攒钱固然重要，但是千万不能降低自己的生活水准</strong></p>
<p>此处说的生活水准指的是基本的消费和娱乐，而不是过度奢靡的消费。就我个人而言，虽然做了兼职空余时间少了，但是该休闲玩乐的时候也不马虎。比如我开源同时还跟老公去欧洲玩了一圈，千万不要为了攒钱让自己变得不快乐，这样你会失去持续下去的动力。</p>
<p><strong>2.选择合适的兼职很重要，千万不要盲从</strong></p>
<p>自从发了帖子至少有30%的小伙伴来问我考口译证书的事情，表怪我实话实说，如果英语底子特别不好或者对英语特别没兴趣，还是不要把宝贵的时间花在这个上面。就我周围的朋友看来很多行业只要努力都有很大的产出，关键要分析好自身优势，不盲从。</p>
<p><strong>3.要对自己狠一点，你会发现很有效果很多小伙伴留言说自己没时间或者老是半途而废，导致现在只能拿死工资</strong></p>
<p>其实，就我一年的坚持发现，给自己设置个“绝境”很重要。虽然我当时的情况也不是一定要凑足这28万才行，但想想父母为自己的付出，作为女儿就想一定要给他们把房子首付准备好。中途也有过放弃，特别是刚开始找不到该做什么的时候，很迷茫，觉得达不成这个目标。幸好我性格比较固执一根经，坚持下来就神清气爽了。</p>
<p><strong>4.不要再给自己找借口，时间确实挤挤就会有的</strong></p>
<p>这一年我在忙装修、忙结婚、忙考在职研究生、忙工作的状态下还能做兼职，自己也觉得难以置信，但回头看看时间管理给了我很大的裨益。我的本职工作类似机关领导秘书，典型的5+2、白+黑模式，开源一定是要忙里偷闲。我学会了错峰吃饭，不把时间浪费在闲聊、逛网站之类没有实际意义的事情上，在跟领导外出的时候也要见缝插针，比如把要记的单词写在随身带的本子上进行复习加深印象之类。5. 要做个生活的有心人，因为机会就在身边。</p>
<p>很多小伙伴会问我“你是哪里找到兼职工作”的问题，其实这关键是要做个生活的有心人，平时多关注相关网络论坛，我的兼职工作就是先从网上找到的。不要两眼只盯着前方，很多事情考虑更多一步、更细一点，你会发现有很多机会就在那里。</p>
<h2 id="怎么花钱才能实现金钱最大的价值？"><a href="#怎么花钱才能实现金钱最大的价值？" class="headerlink" title="怎么花钱才能实现金钱最大的价值？"></a>怎么花钱才能实现金钱最大的价值？</h2><ol>
<li>用于提升自我的钱不能省。</li>
<li>花在投资的钱，不能省</li>
<li>能让自己快乐的钱，不能省。<br>有些人，明明很想去旅行，却为了省钱舍不得去，有些人明明想买漂亮的裙子，却为了省钱，舍不得买……虽然说省钱是一件好事，但是太过节省，压抑自己的本性不是一件明智的事情。如果一个人太过压抑自己，就会影响情绪，影响自己做事的动力。所以，不花钱的时候，要让自己开心，花钱的时候，更要快乐。</li>
</ol>
<p>分散购物欲是获得更好体验的生活方</p>
<ol>
<li>专注于工作，提高工作收入</li>
<li>培养一项爱好</li>
<li>陪伴家人</li>
<li>为自己充电</li>
<li>维系友谊</li>
<li>让自己休息</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[《Web全栈工程师的自我修养》浓缩笔记（下）]]></title>
      <url>/2017/03/31/%E3%80%8AWeb%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E6%B5%93%E7%BC%A9%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="http://dunizb.com/2017/03/16/%E3%80%8AWeb%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E6%B5%93%E7%BC%A9%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89/">《Web全栈工程师的自我修养》浓缩笔记（上）</a></p>
</blockquote>
<h2 id="六、大前端"><a href="#六、大前端" class="headerlink" title="六、大前端"></a>六、大前端</h2><h3 id="1-易于上手、难于精通"><a href="#1-易于上手、难于精通" class="headerlink" title="1. 易于上手、难于精通"></a>1. 易于上手、难于精通</h3><p>不同于某些“难于上手、难于精通”的职业，前端这一岗位就像暴雪公司的游戏设计一样：“易于上手、难于精通 ”。</p>
<p>前端技术的“易于上手”导致它在某些技术人员那里不受待见。他们认为HTML与CSS根本都不是程序语言，甚至认为JavaScript是一种功能不全的玩具型语言。所以直到我几年前毕业的时候，大学都没有前端相关的课程和专业。而市场对前端工程师的需求又很大，学校的输出跟市场的要求没有对接上，所以往往出现学生找不到工作，公司又招不到人的现状。</p>
<h3 id="2-框架-VS-库"><a href="#2-框架-VS-库" class="headerlink" title="2. 框架 VS 库"></a>2. 框架 VS 库</h3><p>一个库是一系列对象、方法等代码，您的应用程序可以把这个库 “链接 ”进来。这个库起到了重用代码的作用，为您省下了重写这部分代码的工作量。</p>
<p>而一个框架是一个软件系统中可重用的一部分。它可能包含子程序、库、胶水语言、图片等一些“资源”，这些资源一起组成了软件项目。框架不像库，可能包含多种语言，某些功能可能通过API的方式让主程序调用。所以框架是一个更加灵活和宽松的名词，在具体的情景中，它可能指一个库、多个库、脚本代码，或者多个可单独运行的子程序的集合。</p>
<p>在出现一些热门框架时，建议开发者先去了解框架的创建初衷，合理使用，而不是盲目收集。</p>
<h2 id="七、向移动端转型"><a href="#七、向移动端转型" class="headerlink" title="七、向移动端转型"></a>七、向移动端转型</h2><h3 id="1-为什么向移动端转型"><a href="#1-为什么向移动端转型" class="headerlink" title="1. 为什么向移动端转型"></a>1. 为什么向移动端转型</h3><p>技术是服务于市场的，在市场发生变化的时候，如果开发者不能顺应变化，就有被淘汰的风险，毕竟很多开发者所服务的这个岗位诞生都不到十年，消亡可能也会在十年之内发生。对于目标是全栈工程师的人来说，技术能力更是多多益善。</p>
<h3 id="2-一定要是自己的产品的用户"><a href="#2-一定要是自己的产品的用户" class="headerlink" title="2. 一定要是自己的产品的用户"></a>2. 一定要是自己的产品的用户</h3><p>风投在评估一个创业项目是否会成功的时候，有一个指标就是创始人是否是自己产品的目标用户。如果不是，那产品很有可能会失败。</p>
<p>在大公司，一些工程师士气低迷往往就是这个原因，成功来得很慢，失败也是。因为大家害怕失败，所以想把产品调整得完美无缺才发布。但是世界上成功的软件都不是完美的软件，而是在合适的时间发布的、刚刚够用的产品。如果它能活下来，在后面的版本中，它才有机会越来越好。</p>
<p>《精益创业 》中有一句话：“客户需求只有在实际使用中才能辨明，再多的前期调研也只能发现客户认为他们想要什么，而不是客户实际上想要什么。因此在不了解客户真实需求的情况下，只会多做多错。”</p>
<h3 id="3-有哪些方向"><a href="#3-有哪些方向" class="headerlink" title="3. 有哪些方向"></a>3. 有哪些方向</h3><p><strong>iOS原生App</strong><br>iOS原生App开发的技能树相对比较新，需要学习Objective C这门语言，以及Xcode的一些操作方法——主要是sto ryboard，以及各种官方类库的使用方法。它带来的收益也很高，对于独立开发。AppStore仍然是地球上最好的软件市场，对于团队，在未来5年都不会缺少对iOS开发者的需求。</p>
<p><strong>Android原生App</strong><br>使用Java编程，如果有Java编程经验，Android原生App是最好的选择，因为用户量和用户比例都在稳定增长。</p>
<p><strong>WindowPhone原生App</strong><br>现在用户量还很少，除此之外也不知道如何评论… … </p>
<p><strong>WebApp</strong><br>技术是最简单的，传统前端开发的技能树可以无缝移植，包括 HTML5/CSS3/JavaScript等。应用场景包括浏览器中打开的WebApp、微信中的页面，或者混合模式App。WebApp的好处是天然无缝移植到所有支持Web标准的平台——甚至Kindle。</p>
<p>此外，对于中国开发者来说，微信公众号也是一个巨大的平台。之所以提到微信，是因为微信这个平台在中国的覆盖率几乎跟Android和iOS加在一起一样多，而且微信也有比较成熟的支付方式。</p>
<h3 id="4-混合模式App"><a href="#4-混合模式App" class="headerlink" title="4. 混合模式App"></a>4. 混合模式App</h3><p>混合模式App（Hybrid App）同时使用Web技术与原生程序语言开发，通过应用商店区分移动操作系统分发，需要用户安装使用。就像混合动力汽车使用汽油和电力两种动力一样，混合模式App使用两种技术制造。</p>
<p>混合模式App对于用户来说跟其他App一样，需要去苹果AppStore或者Android应用商店下载。所以App需要对应的操作系统平台的技术，比如Objective C或者Java制作整体框架。App启动后，它的全部界面或者部分界面中，使用网络视图（WebView）技术来实现。WebView能加载显示网页，可以将其视为一个浏览器，它一般使用WebKit渲染引擎加载显示网页。</p>
<p>混合模式App一些常用的优化方法如下：</p>
<ul>
<li>把WebView的部分或者所有资源打包在App中<br>缺点：发布包体积会变大</li>
<li>把需要加载的资源设置好预先加载<br>缺点：第一次访问的时候可能因为没有预加载资源而导致等待的时间比较长</li>
<li>使用HTML5 Manifest技术实现资源缓存</li>
<li>不要把整个App的主要逻辑都是用WebView开实现<br>要结合原生技术和WebView各自的优缺点，根据不同的场景选择合适的技术。原生技术的优点在于能很好地操作 App存储数据；实现页面间切换、高性能动画、大量数据的界面（比如可以无限滚动的图片流）。WebView的优点在于开发快、技术简单；前端开发者能够利用已有的CSS3和JavaScript知识；页面能够从服务器端更新；能够分享到社交平台；在多个平台上共用等。</li>
<li>设计的更像一个App，而不是一个网页</li>
</ul>
<h3 id="5-混合模式App开发框架"><a href="#5-混合模式App开发框架" class="headerlink" title="5. 混合模式App开发框架"></a>5. 混合模式App开发框架</h3><p>PhoneGap通过对各个平台底层功能进行封装和抽象，然后通过JavaScript暴露出一致的API，让开发者可以通过JavaScript编写跨平台的原生APP。</p>
<p>虽然看上去“一次编写、到处运行”的愿景很美，但是PhoneGap有这样几个缺点。</p>
<ul>
<li>PhoneGap的编程语言其实是JavaScript，这对于非前端工作者来说，学习起来和学习原生的Objective C或Java编程语言难度差不多，想精通JavaScript，相当不易。</li>
<li>PhoneGap编译的App包大小比一般的会大很多。</li>
<li>PhoneGap的目标是方便地创建跨平台应用，但是苹果和Google都发布了自己的人机交互指南。有些情况下，iOS程序和Android程序有着不同的交互原则。使用PhoneGap就意味着您的程序在UI和交互上，既不像原生iOS程序，又不像原生Android程序。</li>
<li>动画性能不佳。JavaScript终究无法和原生程序比运行效率，当制作一些动画效果，或者有大量数据的长页面的时候，就表现得很明显。</li>
</ul>
<p>当然，PhoneGap的优势也很明显 。</p>
<h2 id="八、持续集成"><a href="#八、持续集成" class="headerlink" title="八、持续集成"></a>八、持续集成</h2><h3 id="1-版本控制"><a href="#1-版本控制" class="headerlink" title="1.版本控制"></a>1.版本控制</h3><p><strong>SVN</strong><br>集中式代码管理的核心是服务器，所有开发者在开始新一天的工作之前必须从服务器获取代码，然后开发，最后解决冲突，提交。所有的版本信息都放在服务器上。如果脱离了服务器，开发者基本上可以说是无法工作的。</p>
<p>在企业内部，使用SVN没有什么问题，服务器压力和内部带宽都能够承受所有员工一起操作SVN。但是在开源世界，这种架构方法就不行了，著名的开源软件的开发人数太多了，因此诞生了Git。</p>
<p><strong>Git</strong><br>Git是一个分布式版本控制软件，是天才工程师、Linux内核开发者Linus开发，目的是更好地管理Linux内核源码。其第一版于2005年发布，它与SVN最大的不同之处就是基于分布式的理念。</p>
<h3 id="2-版本控制最佳实践"><a href="#2-版本控制最佳实践" class="headerlink" title="2. 版本控制最佳实践"></a>2. 版本控制最佳实践</h3><p><strong>鼓励频繁的提交</strong><br>SVN践是频繁地提交，而不要等到代码没问题了再一次性提交。对于可能损坏主干原则的代码，不要直接提交到主干，而是创建一个分支，在分支中频繁提交。</p>
<p><strong>确定分支流程</strong><br>基本上所有的特性和较大的bug修复都应该使用分支来修改。</p>
<p><strong>定义主干原则，并且坚守它</strong><br>我们团队的主干原则是“主干对应的代码必须是可以发布并且不会产生bug的”，如果不能保证新增的或者修改的代码符合这一原则，就在分支提交代码。任何人破坏这一原则引起bug，就请大家吃饭。</p>
<p><strong>不要把逻辑的修改和代码格式化操作混在一起</strong><br>如果您做了一些代码格式化的操作，就单独提交这次修改。比如您去掉了代码中所有的空行，那就单独提交一个 commit，然后再做一些逻辑的修改，再提交。这样可以避免“天哪，所有的东西都不一样了”，出现问题之后更容易追溯。</p>
<p><strong>不相干的代码分开提交</strong><br>也就是说不要在一次提交里修复两个bug。</p>
<p><strong>保持工作代码库的“干净”</strong><br>如果您有文件不想也不需要提交，就加入到忽略列表（ignorelist） 。不需要提交的文件包括编译后文件、配置文件和第三方依赖等。这样的好处是，您每次打开SVN提交界面，如果没有修改过任何代码，就会看见一个空的列表 ，如果修改过代码，就显示修改过的代码。这能提醒您不要漏掉任何需要提交的文件。</p>
<h3 id="3-包管理"><a href="#3-包管理" class="headerlink" title="3. 包管理"></a>3. 包管理</h3><p>为什么需要包管理？</p>
<p>在我们日常工作编写的软件中，可能有绝大部分代码都不是我们自己输入的。我们“依赖”一些第三方的框架或者库。在Web前端开发中，我们依赖各种框架、库、静态资源等；在PHP开发中，我们依赖各种框架、库；在iOS App开发中，我们依赖各种库、模块、资源等。在复杂一点的依赖环境中，您所引入的第三方库也依赖其他的“第四方库” “第五方库”… …如何保证互相之间都不会出现冲突很重要。</p>
<p>如何让我们依赖的资源有条不紊地在一个地方进行管理和更新，而不用重复“搜索、下载、移动”这一系列繁琐的手工操作？这就要引入“包管理”。</p>
<p><strong>Node.js</strong><br>Node.js的包管理器npm应该是世界上最有名的包管理器。如果没有npm，Node不会有今天的普及度。npm收集了大量优秀的Node.js代码包，然后这些库吸引更多开发者进入Node.js开发的行列，反过来又促成了npm的繁荣，就像鸡生蛋，蛋生鸡一样。</p>
<p>npm如何引入依赖组件？</p>
<p>第一种是在自己项目的根目录里写一个<code>package.json</code>。这是一个json对象，在其中的<code>dependencies</code>或者<code>devDependencies</code>值列出所需要的模块和版本，然后用命令行切换到项目根目录，运行<code>npminstall</code>。通过这种方法，其他人在得到您的代码之后，仅需要一个<code>package.json</code>文件，就可以简单地使用<code>npminstall</code>命令来安装所需要的所有依赖。模块会全部下载到<code>node_modules</code>文件夹。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">"dependencies"</span>: &#123;</div><div class="line">    <span class="string">"gulp-util"</span>: <span class="string">"2.2.14"</span>,</div><div class="line">    <span class="string">"through2"</span>: <span class="string">"~0.4.1"</span></div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>因为<code>node_modules</code>文件夹里全都是第三方代码，实际上是脱离于自己项目的代码库的。所以应该在<code>.gitignore</code>或者 SVN的忽略文件列表里忽略掉<code>node_modules</code>整个文件夹，而且所有项目成员也不应该修改<code>node_modules</code>里的任何东西，否则在将来<code>npm</code>安装的时候可能会丢失您的修改。如果发现某个模块有修改的必要，要向原作者提出<code>issue</code>。或者推送请求。</p>
<h3 id="4-构建工具"><a href="#4-构建工具" class="headerlink" title="4. 构建工具"></a>4. 构建工具</h3><p><strong>首先需要良好的架构</strong></p>
<ul>
<li>有合适的分离粒度</li>
<li>最小知识原则<br>一个组件或者对象不应该知道其他组件或者对象的内部实现细节。在QQ空间中，我们的配色组件跟其他组件是完全分开的，二者没有依赖关系。一个组件或者对象不应该知道其他组件或者对象的内部实现细节。在QQ空间中，我们的配色组件跟其他组件是完全分开的，二者没有依赖关系。</li>
<li>DRY（不要重复您自己）<br> 特殊的功能只能在一个组件中实现，在其他的组件中不应该有副本。这是我们的一个严格要求。</li>
<li>最小化预先设计，只设计必须的内容</li>
<li>通过良好的层级，让文件易于找到</li>
<li>在代码层面，有一致且可执行的命名规则<br>从路径名到文件名都有一致的前缀、后缀、版本规则。整个团队有一致的命名风格和注释风格。</li>
</ul>
<p><strong>Make和依赖关系</strong><br>Make是一个经典的构建工具，现代很多构建工具（比如Grunt、Gulp等）都参考了它的一些基本原则来设计。 Make的基本模型是：定义一个任务时首先声明依赖关系，然后说明根据这些依赖调用哪些应用程序来生成目标文件。因为每一步都需要使用不同的应用程序调用不同的数据，所以这里面需要设置依赖关系。</p>
<p>另一方面，使用包管理工具可以把项目需要用的第三方包，以及每一个包的特定版本，都集中在一个配置文件中。此后，我们通过一句命令，就可以下载这些包到本地的开发环境。每个软件包都会涉及其他的软件包，软件包里程序的运行需要有一个可执行的环境（要求有其他的程序、库等），软件包依赖关系正是用来描述这种关系的。</p>
<p>所以， “依赖关系”既属于“包管理”，同时又属于“构建工具”。</p>
<p><strong>Grunt和Gulp</strong><br>Make很强大，而且在全世界范围内几乎所有的计算机领域用了几十年，它的稳定可靠经过了广泛验证。不过从学习成本角度来说，它需要学习者具备一些Linux编程的基础，难度较高。所以，Grunt和 Gulp诞生了，它们都是用 JavaScript来实现的构建工具。</p>
<p>Grunt引爆了前端架构工具的概念，得到了广泛的应用。现在，Grunt的生态环境已经非常庞大，越来越多的开发者着手Grunt开发，为它添砖加瓦。但是Grunt有几个问题 。</p>
<ul>
<li>配置项过多。每一个插件的使用都需要配置输入项和输出项，使用比较繁琐。</li>
<li>子任务间的协作基于文件。基于文件的坏处是，后一个子任务必须等前一个子任务的过程完全结束，才能开始它的流程，这样比较慢。而且磁盘读写速度远远慢于内存读写。</li>
</ul>
<p>所以虽然Grunt有先发优势，但是由于它有几个痛点没有很好地解决，所以又诞生了Gulp。</p>
<p>Gulp的意思是 “大口吸” ，它最初的logo是一杯饮料，上面有一根吸管，很形象地跟它的宣传语相呼应：“基于流的构建工具” 。<strong>与Grunt最大的不同就在于，Gulp基于 “流 ”的理念。</strong> </p>
<p>Gulp基于Node.js的流的概念，所以前一个任务的输出就是后一个任务的输入。</p>
<p>从语法风格上来讲，编写任务的过程更像是 “编程 ”，而不是 “编写配置” 。Gulp通过对接前一个任务的输入和后一个任务，就像一个管道，二者可以同时进行，不输出在磁盘中，没有多余的中间产物，性能更加高效。</p>
<p>当前，Gulp的社区还远不如Grunt成熟，有些功能的插件，Gulp可能就没有。不过从个人偏好来看，我更倾向于Gulp，它的技术理念更好。</p>
<h2 id="九、理解编程语言"><a href="#九、理解编程语言" class="headerlink" title="九、理解编程语言"></a>九、理解编程语言</h2><h3 id="1-全栈工程师最佳实践"><a href="#1-全栈工程师最佳实践" class="headerlink" title="1. 全栈工程师最佳实践"></a>1. 全栈工程师最佳实践</h3><p><strong>通用用途语言 VS 特定领域语言</strong><br>很多编程语言倾向于通用解决方案，而不是只解决具体问题。这些语言都被设计为可以在任何领域使用，比如C、Java、Python和XML，它们被称为 “通用语言 ”（General Purpose Language， GPL）。我们可以看到用 C编写的所有类型的软件，从游戏到客户端软件，从服务器端软件到手机端软件。</p>
<p>与之相对应的，有些编程语言被设计为特定领域专用，叫做 “特定领域语言 ” （DSL）。DSL的目的是解决特定领域的问题，而不是像GPL一样可以解决任意的软件问题。DSL在计算机软件开发中十分常见，比如前端开发中常见的HTML和CSS就是一种DSL，专用于Web开发。MySQL是一种DSL，专用于操作数据库。Make是一种DSL，专门用来处理Shell脚本操作系统文件输入和输出。</p>
<p>如果您是一个以解决问题为目标的全栈工程师 ，我建议您在考虑发明一个DSL之前先考虑以下方案 。</p>
<ul>
<li>尽量用您熟悉的通用语言来解决问题 ，比如Python、Java或C++。</li>
<li>优化您的解决方案，提炼出一种真正精简、优雅的扩展库。</li>
<li>开源您的扩展库，根据其他人的贡献来继续优化解决方案。</li>
<li>如果想简化配置文件的语法，可以创建一个脚本包装器来专门为库工作，这就是您自己的DSL。</li>
<li>如果最后您还是想进一步优化下去，那就发明您的DSL吧。</li>
</ul>
<p><strong>框架和库拓展了语言</strong><br>在快速开发中，真正重要的是库，全栈工程师的目标往往是快速解决商业问题，不一定需要长期完美的方案。使用方便好用的框架能大大节省学习成本和开发时间，所以有些时候我们的技术选型步骤是：先选择框架，然后选择语言。</p>
<h3 id="2-脚本语言的优势"><a href="#2-脚本语言的优势" class="headerlink" title="2. 脚本语言的优势"></a>2. 脚本语言的优势</h3><p>一个误解，Swift是一种语法很像脚本语言的编译语言。脚本语言跟编译语言的差异不在于语法，而在于编译机制。</p>
<p>脚本语言，是指支持用脚本的方式编写程序的语言，它无需编译即可直接在运行时环境中解析。在操作上，它缩短了传统的 “编写编译链接运行 ”过程。脚本语言通常具有简单、易用的特性，而且常常很短小。</p>
<p>相比编译语言脚本语言有更高的开发效率，但是在执行效率上会有所牺牲。由于现在的趋势是硬件成本越来越低，而工程师的人工成本越来越高，所以脚本语言的使用空间越来越大，有一些脚本语言（ Python、Ruby ）已经在成熟的商业网站中使用。</p>
<p>不同的脚本语言有不同的设计原则，但是它们往往有一个共同的目标，就是以简单的方式，快速完成某些复杂的任务。</p>
<p><strong>脚本语言不需要编译</strong><br>脚本语言的特点是无需编译即可运行，它在对应的运行环境中直接运行，运行时通过解释器来逐句解析。</p>
<p>因为语言跟对应的解释器（或者编译语言跟对应的编译器）是分开的两个概念，所以从科学上讲，只要给定合适的运行时环境和库支持，任何语言都可以作为脚本语言来使用（也就是编写脚本） 。也就是说， “编写脚本”是对语言的一种使用方法 ，而称某种语言为脚本语言是一种工程上的约定俗成的用法，而不是科学上的定义。</p>
<p>而且另一个问题是，无论是脚本语言还是编译语言，最终都需要编译成机器码让机器来执行。比如JS语言 ，在v8引擎中被编译为机器码然后执行，如果是使用Node.js。那么这个机器码可能会被缓存起来，这样的话，跟编译语言就没什么区别了。</p>
<p><strong>脚本语言常常不需要关心清理内存</strong><br>因为脚本语言的设计目标是快速写出能运行的程序，它更倾向于取悦工程师，而不是优化性能。所以在语法上就忽视内存管理，而该语言的解释器则各显神通，把清理内存垃圾的重担揽在自己的黑盒里面，无需工程师关注。</p>
<p><strong>脚本语言常常会对特定领域优化</strong></p>
<p><strong>脚本语言常常是动态类型语言</strong></p>
<p><strong>脚本语言的抽象层常常更高</strong></p>
<p><strong>脚本语言常常有包管理器</strong></p>
<h2 id="十、全栈游乐场"><a href="#十、全栈游乐场" class="headerlink" title="十、全栈游乐场"></a>十、全栈游乐场</h2><h3 id="1-VPS"><a href="#1-VPS" class="headerlink" title="1. VPS"></a>1. VPS</h3><p>虚拟专用服务器（VPS）是把一台服务器分割成多个虚拟专享服务器的优质服务。每个VPS都可分配独立公网IP地址、独立操作系统、磁盘空间、内存、 CPU资源、进程和系统配置，模拟出 “独占 ”使用计算资源的体验。</p>
<p>比较廉价的选择是虚拟主机（Virtual Host），又称虚拟服务器或虚拟空间。虚拟主机将一台服务器的某项或者全部服务内容逻辑划分为多个服务单位，对外表现为多个服务器，从而充分利用服务器硬件资源。</p>
<p>如果使用虚拟主机，跟其他人共享CPU和内存等资源，这就像是合租。如果其他人在使用卫生间，您就没法用了。虚拟主机的好处是很便宜，国内一些服务提供商提供年费仅几十元的虚拟主机。虚拟并非指不存在，而是指空间是由实体的服务器延伸而来，其硬件系统可以是基于服务器群，或者是单个服务器.</p>
<p>为什么推荐一个全栈工程师买一台VPS自己玩玩？<br><strong>对网站全貌有所了解</strong><br>如果采用第三方的托管服务来搭建博客系系统，新建一个账号就可以开始写了，好处是很方便，缺点是在自定义功能上比如绑定独立域名，安装插件和修改路径格式代没那么灵活。</p>
<p>如果有瘾vps搭建一个博客网站就麻烦一些。</p>
<ul>
<li>初始化。linode提供一键安装操作系统，等待几分钟操作系统就安装完成了。</li>
<li>安装最新版的Apache。启用Apache的rewrite等模块，WordPress的URL重写会用到。</li>
<li>安装MySQL数据库，配置WordPress的数据链接。</li>
<li>配置域名和路由。包括访问路由配置，日志配置，网站域名和别名等，启动服务器，查看资源利用等等。</li>
<li>当然也不要忘了安全防护和设置自动备份。</li>
</ul>
<p>看上去很折腾，不过这种折腾是有意义的，因为他那里在操作的过程中理解了web工作原理。</p>
<p><strong>时间就是金钱</strong><br>推荐使用vps的第二个原因就是稳定。如果您想把精力集中在有用的技术上，而不是服务器无响应或者IP北墙等一些无聊的琐事，那么vps是最有性价比的选择。</p>
<p><strong>部署自己的环境</strong></p>
<p><strong>学习Linux</strong></p>
<p><strong>理解HTTP</strong><br>通过自己去配置和操作服务器，会让前端工程师也得http有更好的理解。</p>
<h3 id="2-如何选择vps？"><a href="#2-如何选择vps？" class="headerlink" title="2. 如何选择vps？"></a>2. 如何选择vps？</h3><p>每个人都有不同的需求，不过选择vps的原则都差不多，首先需要考虑的当然是性价比，主要参数是内存、CPU、硬盘和流量。</p>
<ul>
<li>内存一般是vps的瓶颈</li>
<li>CPU是相对没那么重要的性能指标</li>
<li>硬盘的大小和读写速度是关键。</li>
<li>还有一个重要的考虑就是客户服务。</li>
</ul>
<p><strong>关注服务及安全</strong><br>能力越大责任越大，当你有了安装vps操作系统的能力，您就一定要学会保护自己的服务器。</p>
<p><strong>操作系统的选择</strong></p>
<p><strong>域名解析</strong><br>一般来说，域名购买商和服务器提供商都提供DNS解析的能力，不过域名在哪里注册和域名在哪里解析是两回事。</p>
<p>因为国内网络环境比较复杂，用户可能来自电信、联通、移动、教育网等网络，所以建议把域名的域名服务器设置为国内的智能DNS提供商，比如DNSPod。DNSPod除了可以根据用户IP来给出最佳的IP以外，还提供额外的功能，比如网站监控等增值服务。</p>
<p><strong>云服务器</strong></p>
<h2 id="十一、高效工程师"><a href="#十一、高效工程师" class="headerlink" title="十一、高效工程师"></a>十一、高效工程师</h2><h3 id="1-提速100倍"><a href="#1-提速100倍" class="headerlink" title="1. 提速100倍"></a>1. 提速100倍</h3><p><strong>阅读英文资料</strong></p>
<ul>
<li>英文的技术资料更多。</li>
<li>stackoverflow有完善的鼓励机制。</li>
<li>谷歌的搜索能力非常强。</li>
<li>英语世界的语言风格比较严谨。</li>
</ul>
<p><strong>时间管理四象限</strong></p>
<p><strong>消除重复工作</strong></p>
<p><strong>给自己留出不被打扰的时间</strong></p>
<p><strong>番茄工作法</strong></p>
<h3 id="2-跨界思考"><a href="#2-跨界思考" class="headerlink" title="2. 跨界思考"></a>2. 跨界思考</h3><p>过去跨界学习的成本很高，大部分人都不敢轻易尝试，但如今互联网时代给我们带来了机遇，每天上网都可以看到其他领域名人写的文章和微博，通过查看这些内容，我们就能对于原本完全陌生的领域有一个感性的认识，时间一久我们就能够在潜移默化中理解另一个领域的从业者的思维方式，当您开始跨界学习之后，就会增加更多的机会。</p>
<p>或许每个工程师会在不同的环境中，跨不同的界，但是在未来，我认为跨界出来的那部分能力才真正定义了“您”。</p>
<h3 id="3-纸上头脑风暴"><a href="#3-纸上头脑风暴" class="headerlink" title="3. 纸上头脑风暴"></a>3. 纸上头脑风暴</h3><h3 id="4-使用版本控制和构建系统"><a href="#4-使用版本控制和构建系统" class="headerlink" title="4. 使用版本控制和构建系统"></a>4. 使用版本控制和构建系统</h3><h2 id="十二、学习设计"><a href="#十二、学习设计" class="headerlink" title="十二、学习设计"></a>十二、学习设计</h2><p>在前面的章节里“如何成为全栈工程师”里，我给有志成为全栈工程师的同学的的第一个建议是“关注商业目标”，第二个建议是“关注用户体验”。而好的设计师优秀用户体验的必要非充分条件。</p>
<h3 id="1-科学家和工程师"><a href="#1-科学家和工程师" class="headerlink" title="1. 科学家和工程师"></a>1. 科学家和工程师</h3><p>首先，一个事实是：<strong>过去的工程师普片不在意设计。有意无意，他们忽视设计的重要性。</strong></p>
<p>知乎网站上有一个帖子，问题是“为什么部分开发工程师不喜欢调节界面UI细节？”。我比较赞同下面这个回答：</p>
<blockquote>
<p>我发现程序员大致可以分为科学家和工程师两类，科学家关注技术是否优越，而工程师关注产品是否完美。和科学家类型的程序员合作项目往往是件痛苦的事情，他们太过关注自己手中的的锤子是否先进，却不在意自己敲进去的钉子是否平整光滑不扎屁股，更不要说这可钉子是不是跟其他钉子对齐里。那些“资深”程序员更是如此，那个年代很多用户体验技术不成熟，能做出一个能用的东西已经不易，更不要说做出一个性能还算不错的产品。抱着这个想法走到今天，大多数应该被淘汰的程序员反而做到更高的位置，开始拿这种过时的想法熏陶小弟。（来自陈鑫的回答）</p>
</blockquote>
<h3 id="2-细分不是最佳的解决方案"><a href="#2-细分不是最佳的解决方案" class="headerlink" title="2. 细分不是最佳的解决方案"></a>2. 细分不是最佳的解决方案</h3><p>在传统Web设计流程中，我们也参考里工业化的流水线：按交互设计、视觉设计、前端开发、后台开发的流程来生产一个产品。按照这种细致的分工，设计师就要输出3个以上的页面：手机、平板、超大屏幕的电脑等。设计师在交付设计稿的时候如果有需要调整的地方，3个页面就要重新调整，只要设计发生里调整，就要更改每个对应的样式，大量的人力和时间就浪费在不必要的“流程”中。</p>
<p>我们的解决方案：视觉设计师关注设计模块和整体氛围，只需要给出一份为PC设计的视觉设计稿。让有一定合计理论基础的前端工程师根据拿到的PC设计稿直接创建可以适配多个平台的页面，也就是一个“响应式”的页面。</p>
<p>另一个例子，我们想在页面或者App中创建一些动画效果。在老式Web设计中不会有很多动画，但是现在，页面和App更强调每一个操作都给用户动画反馈，有些是为了更炫，有些是为了给用户操作反馈。但是浙西动画很那在设计稿中体现，这会给设计师和工程师带来很大的沟通成本。</p>
<p>我们的解决方案：让有一定设计功底的前端工程师主动提出自己对动画而见解，做出效果之后再反馈给设计师去确认，优化后的流程十分高效。</p>
<h3 id="3-设计基础"><a href="#3-设计基础" class="headerlink" title="3. 设计基础"></a>3. 设计基础</h3><p>推荐一本书，Robin Wiliams的《写给大家看的设计书》，本书调理清晰简单易读，一个周末的下午或者每天半小时，持续一周就可以读完。但它的理论会如此深刻地停留在您的脑海里，每次看到不符合这些理论的设计，对应的理论就会迸发出老。</p>
<p><strong>设计的四大基本理论是：亲密性、对齐、重复、对比。</strong></p>
<ul>
<li>亲密：关系亲密的元素要放在一起，关系疏远的元素则要分开。位置的亲密性直接表现出意义的相关性。</li>
<li>对齐：左对齐、右对齐、上对齐、下对齐。斜线对齐比较简单，居中对齐很难处理，新手不要尝试。</li>
<li>重复：视觉上使用重复的图形和元素、线条和颜色等。比如QQ空间重复使用的换色跟黑色<br>、微信的绿色、京东的红色等。</li>
<li>对比：如果两个元素（的大小或者颜色）不一样，就让它完全不一样，产生视觉冲击力。</li>
</ul>
<p>所以“设计感”其实是“科学”而不是“艺术”。这些只是理论或者“规则”，规则总是可以被打破的，但是前提是要熟练掌握这些规则。在没有掌握这些规则之前，请遵循规则。</p>
<h2 id="十三、全栈思维"><a href="#十三、全栈思维" class="headerlink" title="十三、全栈思维"></a>十三、全栈思维</h2><h3 id="1-有兴趣就够了吗"><a href="#1-有兴趣就够了吗" class="headerlink" title="1. 有兴趣就够了吗"></a>1. 有兴趣就够了吗</h3><p>作者讲了一个把一本英文书籍交给两个很有兴趣做翻译的年轻人的故事，结果由于各种各样的理由延期交稿，延期里也不主动告知，而他们完成的部分也只能算勉强及格，错译、漏译的情况常常出现，可能存在一些能力问题，但他们给我们的感觉却是根本就不上心。</p>
<p>如果想拖延一件事，或者不想做一件事，总是能找到理由。懒惰的终极原因就是您想逃避这件事。对于所有刚开始工作的年轻人，我告诉你们：<strong>老板给您的任务，根本不关心您有sm理由，只关心您完成没有</strong>。</p>
<p>有人认为兴趣是成功的老师，无法完成某些事情是因为没有兴趣。其实我认为耐心是一种能力，有些人天生缺乏这种能力。在能力不足、困难重重的时候，唯有投入大量的时间才能保住着珍贵的信任。</p>
<p>新人没有经验、知识不丰富，这都可以理解，但是以此为理由输出不合格的产品，那就是自己的问题。</p>
<h3 id="2-学一点管理"><a href="#2-学一点管理" class="headerlink" title="2. 学一点管理"></a>2. 学一点管理</h3><p>不是每个人都有足够的自律和积极性。虽然作为全栈工程师，我们的学习目标一直是提升个人的技术能力。但是在组织中工作，并不需要特别强的个人能力或者天赋、更需要的是稳扎稳打、虚心学习，不要害怕批评，而应该真诚沟通、珍惜每一次机会，完成每一个承诺。</p>
<p><strong>好的管理者能让平凡的员工做不平凡的事</strong><br><strong>高效能的管理者并不奢求完美的人才，他能让平凡的人成就不平凡的事业</strong></p>
<p>《卓有成效的管理者》中的核心是5个思维习惯，这5个思维习惯环环相扣，非常经典。</p>
<ul>
<li>有效的管理者知道她们的时间用在什么地方</li>
<li>有效的管理者重视对外界的贡献</li>
<li>有效的管理者善于利用长处，包括自己的长处、上司的长处、同事的长处和下属的长处。</li>
<li>有效的管理者集中精力于少数重要的领域，在这个少数重要的领域中，如果能有优秀的绩效就可以产生卓越的成果。</li>
<li>最后，有效的管理者必须善于做有效的决策</li>
</ul>
<p>每一条都会花一章的篇幅来展开说明，每一章都有些让我醍醐灌顶的部分。比如“有效的管理者重视对外界的贡献”。</p>
<p>重视贡献，才能使管理者的注意力不为本身的专长所限，不为其本身的技术所限，不为其本身所属的部门所限，才能看到整体的绩效，同事也才能使他更重视外部世界。</p>
<h3 id="3-沟通：被忽视的竞争力"><a href="#3-沟通：被忽视的竞争力" class="headerlink" title="3. 沟通：被忽视的竞争力"></a>3. 沟通：被忽视的竞争力</h3><p>一个事实是，程序员的沟通能力所带来的价值被大大低估来。在我们的招聘流程中，技术能力过关，但是因为沟通能力这一项不过关，而直接被拒绝的面试者比例还是很高的。但是为了避免不必要的争议，大企业的HR往往不会把拒绝的原因传达给应聘者，所以对方也不知道自己为什么会被拒绝。</p>
<p>沟通能力的评判往往是非常微妙和主观的，并没有一份考题能证明您的沟通能力好或者差，只是面试官能根据自己的判断来决定。为了避免无休止的争论，所以刚脆不告诉拒绝原因是最好的。</p>
<p><strong>沟通是软技能</strong><br><strong>针对目标听众</strong><br>佛家有一个词叫“度己度人”，就是在帮助别人的过程中，其实也在帮助自己。所以反过来想，作为需求的请求方，最开始就得找到那个很关键的人，对于他来说，帮助您对他是很有好处的。也就是说他能把这件事当作i自己的冠军任务。如果您的要求对于他人纯属累赘，那么他人自然不愿意帮助您了，任您多么会沟通，最终都不管用。</p>
<p>所以，授权给平级的同事的时候，<strong>最好的方法就是诉诸对方的利益</strong>。如果一件事情可以对双方的KPI都有好处，那么对方也愿意帮助您一起分担这个任务。如果您把不擅长的事情授权给对方，而作为交换，能给对方一些资源，那也是诉诸利益的一个好方法。</p>
<p>其次的方法就是把问题上升到上级领导，让上级领导安排资源，但是这种方法不能经常用，否则上司会认为您不会主动解决问题，只会提出问题。被授权的那一方也觉得您在拿领导压制他，可能会存在负面的情绪。</p>
<p><strong>有方法</strong><br>麦肯锡的金字塔原理就是，任何事情都可以归纳出一个中心论点，而此中心论点可由3至7个论据支持，这些一级论据本身也可以是论点，被二级的3至7个论据支持，如此延伸，状如金字塔。使用金字塔方法的前提是，您的有一个中心目标。不能是两个，更多更不行，只能是一个。</p>
<p><strong>表达自己的想法</strong></p>
<p>看到这里，这本书就读完了！</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[《Web全栈工程师的自我修养》浓缩笔记（上）]]></title>
      <url>/2017/03/16/%E3%80%8AWeb%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E6%B5%93%E7%BC%A9%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>本书的作者余果，腾讯社交用户体验设计部高级UI工程师，前端开发组负责人，熟悉前端开发、iOS开发、PHP开发和Ruby开发等。这本书所讲的内容适合所程序员，不限于前端后端客户端，很多内容其实都是常识。第二遍阅读，特此整理此书精华内容笔记。<br><a id="more"></a><br><img src="http://upload-images.jianshu.io/upload_images/68937-48d9e2503e18d59f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="timg (1).jpg"></p>
<h2 id="一、什么是全栈工程师？"><a href="#一、什么是全栈工程师？" class="headerlink" title="一、什么是全栈工程师？"></a>一、什么是全栈工程师？</h2><p>对于全栈工程师 ，业界并没有严格的定义 ，并不是说一定要一种都不能少地具备哪几项知识才能叫做全栈工程师 。我倾向于认为 ，<strong>应该从能力和思维方式两方面 ，来判定一个人是否是一个合格的全栈工程师 。</strong></p>
<p>国外是怎么样定义的呢？在著名的问答网站Quora上有一个高票的回答：</p>
<blockquote>
<p>全栈工程师是指 ，一个能处理数据库 、服务器 、系统工程和客户端的所有工作的工程师 。根据项目的不同 ，客户需要的可能是移动栈 、 Web栈 ，或者原生应用程序栈 。</p>
</blockquote>
<p>简单来说 ，全栈工程师就是可以独立完成一个产品的人 。当客户让他去做一些舒适区之外的工作时 ，他敢于迎难而上 ，并成功完成任务 。</p>
<h2 id="“各司其职”的弊端"><a href="#“各司其职”的弊端" class="headerlink" title="“各司其职”的弊端"></a>“各司其职”的弊端</h2><p>虽然流水线式的职业划分和工程管理有很多优点，但是它就像一把双刃剑，在带来高可控性、可用性和可管理性的同时，也给工程师带来了一些困境。</p>
<p><strong>1. 工程师职责不清导致效率低下</strong></p>
<p><strong>2. 工程师缺乏主人感导致产品质量差</strong></p>
<p><strong>3. 工程师缺乏全局的视野影响个人成长</strong><br>当工程师希望晋升到更高级的职位 ，如高级工程师或者管理岗位时 ，公司对他的大局观会有更高的要求 ，这就不仅仅是做好 “分内 ”的工作就行的 。高级工程师需要有对设计的理解 、对后台知识的了解 ，以及有跨团队推动项目的能力 。长期研究专精的专业知识会让一个人视野变窄 ，变成 “学术派 ” ，而不是 “实践派 ” 。</p>
<p><strong>4. 更多角色导致项目效率低下</strong></p>
<h3 id="全栈工程师登上舞台"><a href="#全栈工程师登上舞台" class="headerlink" title="全栈工程师登上舞台"></a>全栈工程师登上舞台</h3><p>因为各司其职的工作流程有效率低下 、成本高的缺点 ，所以很多创业公司都不会配备齐全的流水线 ，而是希望采用更灵活的方式来组建团队 ，全栈工程师也因此成为了理想的选择 。<strong>但是全栈工程师的兴起还离不开这两个重要因素 ：技术的发展 ，以及提供 PaaS服务的平台越来越多 。</strong></p>
<h3 id="全栈工程师基本要有的觉悟"><a href="#全栈工程师基本要有的觉悟" class="headerlink" title="全栈工程师基本要有的觉悟"></a>全栈工程师基本要有的觉悟</h3><p>而我推崇的全栈工程师则是与专精工程师不同的另一条道路 。全栈工程师除了在一个专精知识领域有深入研究之外 ，还以知识广博和解决问题能力强著称 。所以我认为有志成为全栈工程师的学习者 ，要有这样几个觉悟 。</p>
<p><strong>1. 一专多长</strong><br>一专多长的意思是 ，工程师首先有一个专精的方向 ，在这个方向上足够精通之后 （高级工程师级别 ） ，以此为突破点去学习更多的知识 ，增加自己的长处 。如果还没有获得某个方向上足够深入的理解 ，就不要囫囵吞枣地去学习其他领域的知识 。</p>
<p><strong>2.  解决问题，而不是醉心技术</strong></p>
<h2 id="二、如何成为全栈工程师"><a href="#二、如何成为全栈工程师" class="headerlink" title="二、如何成为全栈工程师"></a>二、如何成为全栈工程师</h2><h3 id="先精后广，一专多长"><a href="#先精后广，一专多长" class="headerlink" title="先精后广，一专多长"></a>先精后广，一专多长</h3><p>“先精后广 ，一专多长 ”是指 ，建议初学者学习全栈技能的时候 ，先在一个特定的方向上有比较深入的钻研 ，然后再将学习目标渐渐推广开来 。比如先从前端方向入手 ，掌握了基本的 <code>HTML</code>、<code>CSS</code> 、<code>JavaScript</code>之后 ，不要转头向服务器端语言或者 App 方向发展 ，而是深入到性能优化 、 SEO 、多种框架 、响应式页面等前端细节中去 。经过一到两年的深入研究之后 ，再去学习其他方向 。</p>
<p>如果是毕业生或者初学者 ，我不建议在刚开始的一到两年接触太多技术 ，杂而不精 ，结果可能会对后面的职业道路产生副作用 。</p>
<p>为什么要强调在开始的时候要专精方向的重要性呢？因为这样您才能在求职的时候有一个“亮点”。</p>
<p>无论是毕业生还是社会招聘 ，仅仅满足招聘要求是不够的 。您需要在招聘要求的方向上以 200%的能力来得到这个职位 。一个求职者在整个流程中会受到多方考核 ： HR考核您的成本和价值 ，专业面试官 （不是全栈工程师 ）考核您的专业能力 ，经理考核您的沟通能力 。在所有这些考核中 ，其实每一环都是漏斗型筛选 ，会过滤掉一些人 。</p>
<p>让我再次重复这一点 ，作为求职者 ，一定要在某个特定方向上有非常深入的理解 。仅仅会做还不够 ，还要理解背后的原因 ，还有背后的背后的原因 。</p>
<h3 id="围绕商业目标"><a href="#围绕商业目标" class="headerlink" title="围绕商业目标"></a>围绕商业目标</h3><p>我的第一条建议是 ，在考虑做什么项目的时候 ，围绕商业利益作为目标 。归根结底 ，技术是服务于商业目标的 。</p>
<p>老板雇用一个员工 ，不是因为他能写程序 ，而是因为他能帮助自己赚钱 。赚钱有两种方法 ：减少成本 ，或者增加收入 。程序员如果能加快内部系统的运行效率 ，让产品制作流程更加顺畅 ，就是减少成本 。如果能让用户更容易地购买产品 ，或者提高服务质量吸引更多用户 ，就能增加收入 。在老板看来 ，程序员只是一个昂贵的劳动力 ，他会不会写程序都没那么重要 ，重要的是能赚钱 。</p>
<p>所以如果您想成为一个高级开发者 （或者高级设计师 ） ，就一定要学会这种思维方式 。</p>
<p>所谓 “商业目标 ”要广义地去解读 。对于直接制作产品 ，给用户使用的团队 ，就需要对外关注如何提高产品质量 、降低产品成本 ；对内应该关注如何优化流程 、减少错误率 。如果团队输出的成果是公司内其他部门需要的原材料 ，就要关注下游的需求 ，研究如何更好地输出成果 ，如何在流程上使得输出产品的过程更顺畅 。</p>
<p>关注商业目标需要持久的练习 。等到自己成为全栈工程师 ，或者成为团队管理者 ，更加需要在多个目标任务之中做出选择 。全栈工程师需要做和能够做的事情是很多的 ，他会很多技能 ，也负责处理很多工作 ，所以他更需要能力从诸多事情中找到最有商业价值的一个 ：可能是制作一款工具提升团队效率 ，也可能是成本上的优化 。</p>
<p>全栈工程师可以做得事情越多 ，就越需要具备判断做什么的能力 。如果增加一个用户需要的功能是加分项的话 ，拒绝一个用户不需要的需求更加值得推崇 。</p>
<p><strong>一切都要围绕商业目标来进行 ，包括您做的项目 、您的汇报方式 ，以及您在学习新技能时进行的取舍 。永远从商业目标的角度来决定学习哪些东西 ，而不是纯粹为了锻炼技术能力而去学习 。</strong></p>
<h3 id="关注用户体验"><a href="#关注用户体验" class="headerlink" title="关注用户体验"></a>关注用户体验</h3><ul>
<li>每一个糟糕的体验背后都蕴藏着商机（腾讯HR的故事）</li>
<li>用户是谁</li>
<li>大巧若拙<br>意思是指，真正聪明的人，不会显露自己，反而从表面上看好像还很笨拙</li>
<li>做自己会用的产品</li>
</ul>
<p>我如果开创一个公司需要招聘 “全栈工程师 ” ，我要求的三个能力就是<strong>一专多长 、关注商业目标 、关注用户体验 。</strong></p>
<h2 id="三、工程师事业指南"><a href="#三、工程师事业指南" class="headerlink" title="三、工程师事业指南"></a>三、工程师事业指南</h2><h3 id="技术、成长和声望"><a href="#技术、成长和声望" class="headerlink" title="技术、成长和声望"></a>技术、成长和声望</h3><p>软件工程师事业指南告诉您 ，最核心的 3个词就是<strong>技术 、成长和声望 </strong>。技术是您的武器 ，成长就是好好打磨武器 ，而声望是您一生的积累 。怎样获得良好的声望 ？很简单 ——答应做的事 ，全部都要完成 。</p>
<p>那如果上司真的给出一个非常棘手的问题 ，您该如何回答 ？没错 ，您不能直接拒绝 。拒绝上司是很困难的 。但您也不能什么都答应下来 ，随后又无法完成任务 。那时候您会丢掉更多的得分 。正确的方法是 ，讲出事实 。</p>
<h3 id="积累作品集"><a href="#积累作品集" class="headerlink" title="积累作品集"></a>积累作品集</h3><h2 id="四、全栈工程师眼中的HTTP"><a href="#四、全栈工程师眼中的HTTP" class="headerlink" title="四、全栈工程师眼中的HTTP"></a>四、全栈工程师眼中的HTTP</h2><h3 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h3><p><strong>1. OSI七层模型</strong><br>OSI模型义了整个世界计算机相互连接的标准，总共分为 7层 ，其中最上层 （也就是第 7层 ）就是应用层 ， HTTP 、HT TPS、FTP、TELNET、SSH、SMTP和POP3都属于应用层 。这是软件工程师最关心的一层 。 SI模型越靠近底层 ，就越接近硬件 。在 HTTP协议中 ，并没有规定必须使用它或它支持的层 。事实上 ， HTTP可以在任何互联网协议或其他网络上实现 。 HTTP假定其下层协议提供可靠的传输 ，因此 ，任何能够提供这种保证的协议都可以被其使用 ，也就是其在 T CP / IP协议族使用 TCP作为其传输层 。</p>
<p><img src="[https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1490023285&amp;di=7e5c19431bb3a3f7f8a4613d8aad0267&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Ffarm6.staticflickr.com%2F5491%2F10973734404_1c7b19e69e_o.jpg" alt="">](<a href="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1490023285&amp;di=7e5c19431bb3a3f7f8a4613d8aad0267&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Ffarm6.staticflickr.com%2F5491%2F10973734404_1c7b19e69e_o.jpg" target="_blank" rel="external">https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1490023285&amp;di=7e5c19431bb3a3f7f8a4613d8aad0267&amp;imgtype=jpg&amp;er=1&amp;src=http%3A%2F%2Ffarm6.staticflickr.com%2F5491%2F10973734404_1c7b19e69e_o.jpg</a>))</p>
<p><strong>2. 关于HTTP版本</strong><br>1999年发布HTTP1.1，比1.0它增加了缓存处理和持续连接，以及其他一些性能优化。</p>
<p>2015年2月，HTTP/2正式发布 。新的 HTTP版本有一些重大更新 ，除了一如既往地向下兼容 HTTP/1以外 ，还有一些优化 ，比如减小网络传输延迟 ，并简化服务器向浏览器传输内容的过程 。主流的服务器 （Apache 、Nginx等 ）和浏览器 （Firefox、Chrome、Safari以及 iOS和Android的浏览器等 ）的最新版都已经支持 HTTP/2 ，剩下的就需要网站管理员把服务器升级到最新版了 。</p>
<h3 id="前端视角"><a href="#前端视角" class="headerlink" title="前端视角"></a>前端视角</h3><p>每一个前端工程师都知道的基本优化方法是：尽量减少统一域下的HTTP请求数，以及尽量减少每个资源的体积。</p>
<p><strong>尽量减少统一域下的HTTP请求数</strong><br>浏览器常常限定了对同一域名发起的并发连接数的上限 。 各种浏览器普遍把这一上限设定为 4至 8个 。如果浏览器需要对某个域进行更多的连接 ，则需要在用完了当前连接之后 ，重复使用或者重新建立 T C P连接 。</p>
<p>由于浏览器针对资源的域名限制并发连接数 ，而不是针对浏览器地址栏中的页面域名 ，所以很多静态资源可以放在其他域名下 （不同的子域名也被认为是不同的域名 ） 。如果您只有一台服务器 ，可以把这些不同的域名同时指向一个 I P ，也就提高了对这台服务器的并发连接数限制 （不过要小心服务器压力过大 ） 。</p>
<p>把静态资源放在非主域名下 ，这种做法除了可以增加浏览器并发 ，还有一个好处是 ，减少HTTP请求中携带的不必要的cookie数据 ，因为这对带宽和链接熟读都造成了影响，所以我们一般把静态资源放在单独的域名下。</p>
<p><strong>尽量减少每一个资源的体积</strong><br>我们不光要限制请求数 ，还要尽量减少每一个资源的体积。因为资源的体积越大 ，在传输中消耗的流量就越多 ，等待时间也越久 。</p>
<p>在面试应聘者的时候，我会问的一个基础题目是 “常用的图片格式有哪些 ，它们的使用场景是什么 ” 。如果能选择合适的图片格式 ，就能够用更小的体积 ，达到更好的显示效果 。对图片格式的敏感 ，能反映出工程师对带宽和速度的不懈追求 。此外 ，对于比较大的文本资源 ，必须开启 gzip压缩 。因为 gzip 对于含有重复 “单词 ”的文本文件 ，压缩率非常高 ，能有效提高传输过程 。</p>
<h3 id="后台视角"><a href="#后台视角" class="headerlink" title="后台视角"></a>后台视角</h3><p>前端工程师对HTTP的关注点在于尽量减少同一域下的HTTP请求数 ，以及尽量减少每一个资源的体积 。与之不同 ，后台工程师对于HTTP的关注在于让服务器尽快响应请求 ，以及减少请求对服务器的开销 。</p>
<p><strong>提高服务器的请求处理能力</strong><br>Apache是市场份额最大的服务器 ，超过 50%的网站运行在Apache上 。Apache通过模块化的设计来适应各种环境 ，其中一个模块叫做多处理模块（MPM）专门用来处理多请求的情况 。Apache安装在不同系统上的时候会调用不同的默认MPM ，我们不用关心具体的细节，只需要了解Unix上默认的MPM是<code>prefork</code>。为了优化，我们可以改成<code>worker</code>模式 。</p>
<p><code>prefork</code>和<code>worker</code>模式的最大区别就是 ，prefork的一个进程维持一个连接 ，而worker的一个线程维持一个连接 。所以prefork更稳定但内存消耗也更大 ，worker没有那么稳定 ，因为很多连接的线程共享一个进程 ，当一个线程崩溃的时候 ，整个进程和所有线程一起死掉 。但是worker的内存使用要比prefork低得多 ，所以很适合用在高HTTP请求的服务器上 。</p>
<p>在高连接并发的情况下 ，Nginx是Apache服务器不错的替代品或者补充 ：一方面是Nginx更加轻量级 ，占用更少的资源和内存；另一方面是Nginx处理请求是异步非阻塞的 ，而Apache则是阻塞型的 ，在高并发下Nginx能保持低资源 、低消耗和高性能 。由于Apache和Nginx各有所长 ，所以经常的搭配是Nginx处理前端并发 ，Apache处理后台请求 。值得一提的是 ，新秀Node.js也是采用基于事件的异步非阻塞方式处理请求 ，所以在处理高并发请求上有天然的优势 。</p>
<p><strong>DDos攻击</strong><br>DDos是Distributed Denialof Service的缩写，DDos攻击翻译成中文就是 “分布式拒绝服务 ”攻击 。</p>
<p>攻击者通过海量的请求 ，让目标服务器瘫痪 ，无法响应正常的用户请求 ，以此达到攻击的效果 。对于这样的攻击 ，几乎没有什么特别好的防护方法 。除了增加带宽和提高服务器能同时接纳的客户数 ，另一种方法就是让首页静态化 。</p>
<p>DDos攻击者喜欢攻击的页面一般是会对数据库进行写操作的页面，这样的页面无法静态化，服务器更容易宕机 。DDos攻击者一般不会攻击静态化的页面或者图片，因为静态资源对服务器压力小，而且能够部署在CDN上 。</p>
<p><strong>BigPipe</strong><br>通俗来解释，BigPipe首先把HTML页面分为很多部分 ，然后在服务器和浏览器之间建立一条管道 （BigPipe就是 “大管道 ”的意思 ） ，HTML的不同部分可以源源不断地从服务器传输到浏览器 。BigPipe首先输送的内容是框架性HTML结构 ，这个框架结构可能会定义每个Pagelet模块的位置和宽高 ，但是这些Pagelet都是空的，就像只有钢筋混泥土骨架的毛坯房 。</p>
<p>接下来管道里源源不断地传输过来很多模块 ，这时候最开始加载在服务器中的JS代码开始工作 ，它会负责把每一个模块依次渲染到页面上，在用户的感知上，页面非常快地出现在眼前 ，但是所有的模块都显示正在加载中 ，然后主要的区域 （比如重要的用户动态 ）优先出现，接下来是logo、边栏和各种挂件等 。</p>
<p>为什么BigPipe能够让服务器对浏览器说“我这个请求还没结束，我们保持这个链接不要断开”呢？答案是HTTP1.1的分块传输编码。</p>
<p>HTTP1.1引入分块传输编码 ，允许服务器为动态生成的内容维持HTTP持久链接。如果一个HTTP消息（请求消息或应答消息）的Transfer Encoding消息头的值为chunked，那么消息体由数量不确定的块组成 ——也就是说想发送多少块就发送多少块 ——并以最后一个大小为0的块为结束 。</p>
<h2 id="五、高性能网站的关键——缓存"><a href="#五、高性能网站的关键——缓存" class="headerlink" title="五、高性能网站的关键——缓存"></a>五、高性能网站的关键——缓存</h2><h3 id="1-服务器缓存"><a href="#1-服务器缓存" class="headerlink" title="1. 服务器缓存"></a>1. 服务器缓存</h3><p><strong>基本的数据库查询缓存</strong><br>MySQL默认不开启查询缓存 ，但我们可以通过修改MySQL安装目录中的 <code>my.ini</code> 来设置查询缓存 。设置的时候可以根据实际情况配置缓冲区大小 、单个查询的缓冲区大小等 。</p>
<p>可以在MySQL配置中增加这两项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">query_cache_size = SIZE</div></pre></td></tr></table></figure></p>
<p>SIZE是指为查询缓存开辟多大的空间 。默认是 0 ，也就是禁用查询缓存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">query_cache_type = OPTION</div></pre></td></tr></table></figure>
<p>设置查询缓存的类型 ，可选的值有以下这三种 。 </p>
<ul>
<li>0：设置查询缓存的类型 ，可选的值</li>
<li>1：所有的缓存结果都缓存起来 ，除非查询命令以 <code>SELECTS_NO_CACHE</code> 开始 。 </li>
<li>2：只缓存查询命令以 <code>SELECT SQL_CACHE</code>开始的查询结果 。</li>
</ul>
<p>所以 ，对于查询操作远远多于修改操作的数据库 ，开启数据库查询缓存是很有益的 ；但是对于修改操作很多的数据库 ，由于缓存经常会失效 ，就起不到加速的效果 。不仅如此 ，由于数据库要花费时间写缓存 ，所以实际上速度更慢了 。</p>
<p>这里需要注意的是 ，两次 SQL 文本必须完全相同 。如果前后两次查询使用了不同的查询条件 ，就会重新查询 。</p>
<p><strong>扩展数据库缓存：memcached</strong><br>memcached的缓存失效采用的是按时间来过期的设计 。memcached相当于应用程序和数据库之间的中间层 ，通过网络 API设置和调用 。memcached储存的是名值对 ，而且设置了一个过期时间 ，只要过期时间没有到 ，应用程序就会从memcached中获取数据 。这时候即使发生了数据库更新操作 ，缓存的查询结果也仍然是之前保存的旧数据 ，直到设置的时间过期 。这样提高了缓存的性能 ，带来的影响就是 ，数据可能是 “不新鲜 ”的 。</p>
<p>但是 memcached 也不是总是那么有效，因为如果只有一台服务器，就用不到它的服务器集群的优势，反而让系统更慢 。</p>
<p><strong>再加一层文件缓存</strong><br>除了可以将数据库查询结果缓存在内存中还可以将被频繁造访的数据缓存在文件中。文件 I/O 比起内存有以下几个好处。硬盘容量比内存大，所以可以缓存更多数据。数据更安全，断电之后数据还在。易于扩展，硬盘不够用的时候还可以添加硬盘。但是文件缓存没有内存缓存快，只能作为内存缓存的补充，在获取数据时，先从最快的地方读取，如果没有就继续往后找。查找优先级为：内存缓存 →文件缓存 →数据库 。</p>
<p>缓存文件不会过期，除非您删掉它，否则任何被缓存了的查询会一直存在。缓存系统允许您按页面清除，或把所有缓存都清除掉 。一般来说，您可以在某些事件（比如向数据库添加了数据 ）发生时用特定的函数来清除缓存 。</p>
<p><strong>静态化</strong><br>有两种静态化的方法，其中一种是类似 WordPress 的静态化插件，安装很简单，每次有新文章就自动生成静态页面。这种方法还是将数据保存在数据库中，只是会读取数据库之后生成一些静态页。这一种方法的原理跟文件缓存很相似 。</p>
<p>另一种方法就是直接抛弃数据库 。比如有一些博客作者会用 Jekyll 系统来写博客，将整个博客站点静态化。完全抛弃数据库的好处是，可以将生成的静态网页直接托管在静态资源站点，比如 GitHub Pages 或者 Amazon S3，而不用操心数据库服务器的问题，不光整个系统稳定很多，费用上也更加低廉 （GitHub更是完全免费的，而且提交 Markdown 源代码后可以让它在服务器端生成站点） 。</p>
<h3 id="2-浏览器缓存"><a href="#2-浏览器缓存" class="headerlink" title="2. 浏览器缓存"></a>2. 浏览器缓存</h3><p>当浏览器访问一个站点的时候，网络连接是主要瓶颈，我们可以通过设置浏览器缓存来跳过 HTTP请求。如果在浏览器设置缓存，通常有两个主要作用。</p>
<ul>
<li>用户来说，减少请求可以更快地加载页面，节省流量。如果用户是在手机上用3G或4G访问页面，这一点就很关键。</li>
<li>对网站来说，减少带宽压力和费用。假设有1亿的访问量，如果能把大小为 10KB的 CSS缓存起来，可以节省不小的开支。</li>
</ul>
<p>主要的两种缓存指令<br><strong>第一种：Expires</strong><br>这种缓存是最快的，因为没有任何 HTTP请求发生。当用户需要这个资源，浏览器就直接从缓存中读取，不再需要询问服务器端的意见（服务器端甚至不知道您在浏览 image.png） 。所以 HttpWatch是推荐对所有的静态资源都设置Expires 。</p>
<p><strong>第二种：Last-Modified</strong><br>通过这种缓存方式 ，无论资源是否发生了更新 ，仍然至少会发生一来一去 HTTPS 头的传输和接收 ，所以速度比不上Expires 。</p>
<p>从服务器端的角度来看 ，有时候我们并不希望对静态资源的请求中大部分都返回304。因为这可能说明我们的很多用户都在频繁访问站点 ，而且我们的资源很少更新 ，就好像它们一直问 “资源修改了吗？ ” ，我们一直回答 “没有修改 ” 。这里可以使用Expires来设置过期时间 ，这样它们就不会 “烦我们 ”了 。对于服务器管理员来说，保持304为一个合理的比例即可 。我们可以通过查看服务器的log ，查看304响应与200响应的比例，来做出一个合理的缓存策略 。</p>
<p><strong>Restful Web API</strong><br>表征性状态传输（Representational State Transfer，REST）是一种软件架构风格。在 3种主流的Web服务实现方案中，因为REST模式最简洁，也能合理地利用HTTP操作的语义，所以越来越多的Web服务开始采用REST风格设计和实现 。</p>
<p>Restful的目的是定义如何正确地使用Web标准，优雅地使用HTTP本身的特性。原则上是对资源、集合、服务（URL）、get、post 、put、delete（操作）的合理使用。举例来说，如果请求一个资源，但是服务器上没有这个资源，这时候就应该对HTTPS头设置404，而不是设置200。</p>
<p><strong>HTTP1.1加入的Cache-Control</strong><br>它的功能跟Expires类似，不过有更多的选项。Expires的值是一个日期，表示某日期之前都不再询问。Cache-Control的值是 : maxage = 7776000， maxage的单位是秒，从浏览器接收到文件之后开始计时。</p>
<p>按照HTTP规范 ，如果修改了请求资源的QueryString，就应该被视为一个新的文件。</p>
<p>下面是推荐的浏览器缓存设置最佳实践。</p>
<ul>
<li>对于动态生成的HTML页面使用HTTPS头：<code>Cache-Control:nocache</code>。</li>
<li>对于静态HTML面使用HTTPS头：Last-Modified 。</li>
<li>其他所有的文件类型都设置Expires头，并且在文件内容有所修改的时候修改QueryString。</li>
</ul>
<p><strong>浏览器缓存的现实世界</strong><br>服务器端可以设置缓存规则，告诉浏览器应该如何遵循和实现，但在服务器不能掌控的地方也许会出现一些意外。缓存会被挤出。文件有可能在运营商服务器上被劫持。</p>
<p>第二个问题是 ，用户的宽带运营商为了提高速度 ，可能会在自己某节点服务器上缓存您的文件（比如style.css?v1），好处是当用户请求这个文件的时候，运营商无需来您的服务器上请求文件，而自己直接就给出了。</p>
<p>问题来了，如果您的QueryString更新了（style.css?v2），按照HTTP规范，这理应被视为一个新的文件，但是运营商仍然可能会拿自己节点的缓存，而不是遵循规范。有点可恶对不对？这就是我们在用户量极大的情况下侦测到的情况，虽不太常见，但是有可能发生。所以，为了保证更新的文件下发到所有的用户，我们会使用更加强硬的方法：修改文件名，而不是仅仅修改QueryString。</p>
<p>QQ空间静态资源在浏览器端使用的缓存策略。</p>
<ul>
<li>对于动态生成的HTML页面使用HTTPS头：<code>Cache-Control:nocache</code>。</li>
<li>对于静态HTML页面使用HTTPS头 ：Last-Modified 。</li>
<li>其他所有的文件类型都设置Cache-Control头，<strong>并且在文件内容有所修改的时候修改文件名</strong>。</li>
</ul>
<hr>
<p>猜你喜欢：<a href="http://www.jianshu.com/p/8423c354108c" target="_blank" rel="external">《Web全栈工程师的自我修养》浓缩笔记（下）</a></p>
<blockquote>
<p>文章出处：<a href="http://dunizb.com">http://dunizb.com</a><br>原文链接：<a href="http://dunizb.com/2017/03/16/%E3%80%8AWeb%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E6%B5%93%E7%BC%A9%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89/">http://dunizb.com/2017/03/16/%E3%80%8AWeb%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E6%B5%93%E7%BC%A9%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89/</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[响应式图片实战]]></title>
      <url>/2017/03/12/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9B%BE%E7%89%87%E5%AE%9E%E6%88%98/</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/68937-2d2de74c9c20fb5b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="响应式图片实战"></p>
<p>说到响应式网站，我们都知道弹性布局、弹性图片、媒体查询，更多指的是布局的方式，比如说使用<code>max-width: 100%</code>，这样让图片的宽度随着容器的大小而改变，响应式设计让网站能兼容各种屏幕设备，但是在我们流量这么昂贵的时代，让一个小屏幕的手机去加载一张为大屏幕PC设计的几百K的图片，虽然这张图片会看起来非常的清晰，但是疯涨的流量消耗肯定会让用户非常的苦恼，而且我们也需要加载更长的时间才能把页面加载出来。</p>
<p>我们开发的目的不是挑战用户的耐心和金钱，而是让用户在使用的过程中有更好的感受，在这种情况下加载与 用户设备相匹配的小图片，即快速，又不会影响用户的体验，帮用户节省了成本，同样的，你在PC端加载一张小图片也不会影响用户的体验，帮用户节省了成本，同样的你在PC端加载一张小图片，虽然速度很快但是放大后模糊的效果会让用户觉得网站很Low很不专业,而且PC大部分使用的wifi，我们不需要去接受太多的流量，那么如何解决刚才说的这些问题呢？响应式图片的概念也就随之产生了，响应式图片，不仅仅是指图片的排版和布局，更多的还指可以根据设备大小而加载不同的图片，虽然这个过程增加了一点点UI设计师的工作量，不过那会大大改善用户的体验，那么想要响应式图片如何来实现呢？</p>
<h2 id="第一种，JS或者服务端硬编码"><a href="#第一种，JS或者服务端硬编码" class="headerlink" title="第一种，JS或者服务端硬编码"></a>第一种，JS或者服务端硬编码</h2><p>这种方式的原理其实就是跟踪window的resize事件，然后修改一下图片的路径，我们准备三张图片，1-480.png、1-800.png、1-1600.png，分别对应三种大小设备屏幕，然后：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">makeImageResponsive</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> width = $(<span class="built_in">window</span>).width();</div><div class="line">        <span class="keyword">var</span> img = $(<span class="string">'.container img'</span>);</div><div class="line">        <span class="keyword">var</span> imgUrlPrefix = <span class="string">'http://sandbox.runjs.cn/uploads/rs/496/pkutja85/'</span>;</div><div class="line">        <span class="keyword">if</span> (width &lt;= <span class="number">480</span>) &#123;</div><div class="line">            img.attr(<span class="string">'src'</span>,imgUrlPrefix + <span class="string">'1-480.png'</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (width &lt;= <span class="number">800</span>) &#123;</div><div class="line">            img.attr(<span class="string">'src'</span>,imgUrlPrefix + <span class="string">'1-800.png'</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            img.attr(<span class="string">'src'</span>,imgUrlPrefix + <span class="string">'1-1600.png'</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    $(<span class="built_in">window</span>).on(<span class="string">'resize load'</span>, makeImageResponsive);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><a href="http://sandbox.runjs.cn/show/nzuscj9e" target="_blank" rel="external">在线查看</a>，<a href="http://runjs.cn/code/nzuscj9e" target="_blank" rel="external">源码</a></p>
<p>这种形式还有一种变种的方式， 就是把屏幕信息写入Cookie中，取图片的时候在服务器端决定返回哪一张图片，这样的话就不需要我们来写脚本了，我们通过Cookie和在服务器端进行控制就可以达到目的，兼容性也比较好。</p>
<h2 id="第二种，srcset-方法"><a href="#第二种，srcset-方法" class="headerlink" title="第二种，srcset 方法"></a>第二种，srcset 方法</h2><p>通过js或者服务器端返回确实可以达到响应式图片这样一个目的，兼容性也非常的好，但是需要我们编码实现响应式的逻辑，在修改的时候也不是很方便，这属于命令式的实现，那么有没有声明式的实现呢？也就是说我们把这几个图片地址声明在HTML中，由浏览器来决定如何加载，这样的话更加的灵活，把展示的逻辑从js脚本或者从服务器端硬编码分离出来，这样也降低的耦合，因为展现和我们的业务逻辑是分开的。</p>
<p>那么具体有没有呢？答案是有的。</p>
<p>经过了多年的努力和争辩，我们现在有了一些符合标准的标记，这些标记其实都经过了很多的修改、讨论，最后决定了这样几种，这些标记是来解决响应式图片的问题的。这些标记如下：</p>
<ul>
<li>srcset</li>
<li>srcset 配合 sizes</li>
<li>picture</li>
<li>svg</li>
</ul>
<p>这些新元素和新属性让我们可以编写多个可替换的图片，让每个客户端使用最适合的那一个，这些已经进入了官方的规范，下面我们分别来使用这些标记。</p>
<p>我们新建一个如下的页面：<br>HTML：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></div><div class="line"> ![这里是图片](http://upload-images.jianshu.io/upload_images/68937-84332faff9c92c52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>CSS：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">html</span>, * &#123;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.content</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">    <span class="attribute">marign</span>: <span class="number">0</span> auto;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.content</span> <span class="selector-tag">img</span> &#123;</div><div class="line">    <span class="attribute">display</span>: block;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">    <span class="attribute">max-width</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个页面很简单，就是载入了一副480x480的图像</p>
<p><code>srcset</code>是<code>img</code>标签中的一个属性，这个属性里面是可以以逗号隔开的一个或者多个字符串列表，这些字符串用来代表一系列可能使用的图片，每个字符串的格式如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"iamge"</span> <span class="attr">src</span>=<span class="string">"img/1-480.png"</span> </span></div><div class="line">      <span class="attr">srcset</span>=<span class="string">"img/1-480.png 480w, </span></div><div class="line">              img/1-800.png 800w, </div><div class="line">              img/1-1600.png 1600w" /&gt;</div></pre></td></tr></table></figure></p>
<p><code>480w</code>、<code>800w</code>、<code>1600w</code>就是尺寸描述符，一般是<code>w</code>结尾，也就是width的意思，以上声明了三张不同规格的图片，对于支持<code>srcset</code>的浏览器会怎么做呢？</p>
<p><a href="http://sandbox.runjs.cn/show/dhdzk8e5" target="_blank" rel="external">在线预览</a>，<a href="http://sandbox.runjs.cn/code/dhdzk8e5" target="_blank" rel="external">查看源码</a></p>
<p>从效果上看浏览器会自动感知，这个感知包含一系列因素如屏幕大小、网速、dpr等，然后去选中一张合适的图片进行加载。我们先把界面变小，如下面所示：<br><img src="http://upload-images.jianshu.io/upload_images/68937-0d2dadf996f4e769.gif?imageMogr2/auto-orient/strip" alt="responsive-1.gif"></p>
<p>我们可以看到，当我们加载到最大的图片后，然后再把屏幕缩小后，加载的图片却并没有改变，这是什么样的一个逻辑 呢？</p>
<p>这个逻辑就是：浏览器会根据屏幕的宽度和我们声明的图片的尺寸描述符去决定应该使用哪张图片，但是呢，因为我们浏览器已经在大的分辨率下加载了大的图片，那么浏览器会默认你的图片已经放在缓存中了，使用大的图片不会再有网络的消耗，那么当然是使用更大的图片更好的了，所以在我们再缩小屏幕的时候浏览器不会再去使用小图片了，这是浏览器的一个默认的行为。</p>
<h2 id="第三种，sizes-解决-srcset坑"><a href="#第三种，sizes-解决-srcset坑" class="headerlink" title="第三种，sizes 解决 srcset坑"></a>第三种，sizes 解决 srcset坑</h2><p>上面使用<code>srcset</code>让我们的开发变的非常的简单，只需要声明一下将几个图片和它的宽度，就可以让浏览器自动的去选择，那么如果我们只设置<code>srcset</code>的话，会有一个小小的坑，我们试的把这个content它的宽度设置成50%。看一下页面的效果，我还是把dpr设置为1，这样的话他会精确到像素，让我们看得更加的清晰。</p>
<p>设置成50%之后这个图片只是占了50%的宽度来显示，但是当我们去加宽这个宽度的时候，可以看到，当我们到480的时候，图片就会改变，但其实这个图片真实的宽度只有480/2，也就是只有240，只在240的时候这个宽度就改变了，这时候我们就会会发现这个图片，它的这个自动的加载变得不是那么智能了，那么我们图片的容器变小，但是图片还是按照百分之百的宽度逻辑进行缩放，这是什么样什么样一个原因呢？这是因为呢其实，srcset，这一个属性还需要配合一个属性来使用，就是刚才说到的<code>sizes</code>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"image"</span> <span class="attr">src</span>=<span class="string">"http://sandbox.runjs.cn/uploads/rs/496/pkutja85/1-480.png"</span> <span class="attr">alt</span>=<span class="string">"这里是图片"</span> </span></div><div class="line"> <span class="attr">srcset</span>=<span class="string">"http://sandbox.runjs.cn/uploads/rs/496/pkutja85/1-480.png 480w,</span></div><div class="line">                        http://sandbox.runjs.cn/uploads/rs/496/pkutja85/1-800.png 800w,</div><div class="line">                        http://sandbox.runjs.cn/uploads/rs/496/pkutja85/1-1600.png 1600w" </div><div class="line"> <span class="attr">sizes</span>=<span class="string">"100vw"</span>/&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>刚才我们没有设置设置这个<code>sizes</code>属性，其实，这个属性还是被设置了，它被设置成什么呢？它被设置成了一个默认的值，<code>sizes</code>属性，如果我们不去设置的话它的默认值是<code>100vw</code>，这里的<code>vw</code>代表视口的宽度，<code>v</code>就是<code>viewport</code>，<code>w</code>就是<code>width</code>，<code>vw</code>是一个代表视口宽度的单位。<code>vw</code>就是这样一个缩写，那么同样的还有一系列这样的宽度，比如说<code>vh</code>，代表视口高度，这是和视口相关的一个相对的单位，有点类似于我们的em之类的相对单位，只是这个单位它的相对值是视口，这里的100不是代表100个，而是代表百分比100%，这里设置成<code>100vw</code>就代表图片的尺寸就是百分之百的视口的宽度，<code>sizes</code>属性他是告诉浏览器以什么样的尺寸来显示图片，如果不写的话默认是<code>100vw</code>的视口宽度，那么就是告诉浏览器在这里不管图片外边是怎么样去包围它的，图片实际的宽度是多少，它的参考值就是百分之百的视口的宽度尺寸，所以说在这里边我们不管图片外面的容器的宽度是多少，图片本身它的宽度是多少这个百分之百是宽度来去选择我们这里面声明的三张图片，一般来说这个选择的逻辑不是我们需要的，因为在各个分辨率下图片的宽度其实都是有可能不同的，比如说在这里我们<code>content</code>的宽度设置成50%，那图片就变小了，图片宽度变小怎么办呢？我们就可以来设置这个<code>sizes</code>属性，怎么样来设置呢？</p>
<p><code>sizes</code>和这个<code>srcset</code>有点类似，他都是以逗号隔开的一个或者多个字符串，每个字符串里面的第一个值可以包含一个媒体条件，也就是媒体查询，第二个值代表图片他的一个预估的尺寸，也就是说，在这种媒体查询条件下，这个图片预估的尺寸是多少，注意这两个值是空格分开的，在这里我们先写一个五<code>50vw</code>看一下效果，<code>50vw</code>相当于图片的尺寸也就是我们预估的尺寸，因为第一个条件媒体查询是可以省略的，省略了媒体查询，只写一个<code>50vw</code>就是代表所有条件下这个图片的宽度预估都是<code>50vw</code>，也就是50%的视口宽度。</p>
<p>sizes属性里的单位还可以是px等其他任何的单位，在简单的情况下，比如说图片的宽度一直100%或者某个值，我们只需要给一个给定的数值就行了，比如50vw。但是在比较复杂的排版的情况下，这个sizes就可以起到比较大的作用，比如有一张图片，它的视口宽度超过800px的时候我们要求它的宽度最大是800px宽，如果视口的宽度小于800px的时候我们要求它的宽度是100%的视口宽度。那我们就可以这样写：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"image"</span> <span class="attr">src</span>=<span class="string">"http://sandbox.runjs.cn/uploads/rs/496/pkutja85/1-480.png"</span> <span class="attr">alt</span>=<span class="string">"这里是图片"</span> </span></div><div class="line"> <span class="attr">srcset</span>=<span class="string">"http://sandbox.runjs.cn/uploads/rs/496/pkutja85/1-480.png 480w,</span></div><div class="line">                        http://sandbox.runjs.cn/uploads/rs/496/pkutja85/1-800.png 800w,</div><div class="line">                        http://sandbox.runjs.cn/uploads/rs/496/pkutja85/1-1600.png 1600w" </div><div class="line"> <span class="attr">sizes</span>=<span class="string">"(min-width:800px) 800px, 100vw"</span>/&gt;</div></pre></td></tr></table></figure></p>
<h2 id="第四种，picture标签"><a href="#第四种，picture标签" class="headerlink" title="第四种，picture标签"></a>第四种，picture标签</h2><p>一般来说对于仅仅是需要缩放的图片，我们在<code>srcset</code>属性里面列出图片的地址啊，像素宽度啊，用<code>sizes</code>属性来告诉浏览器这个图片在什么样的情况下它的宽度显示成怎么样，写出这些就足够了，但是有的时候我们会希望除了缩放之外还通过其他的方式进行图片的自适应，这个时候我们就要夺回一些我们选择图片的一个控制权，所谓的夺回控制权就是说浏览器的选择逻辑我们要把它拿过来一些，我们自己来控制，那么<code>picture</code>属性就该出场了，比如我们有一个天安门的全景图，宽宽的一个图片：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-29a9b3a19ef73f6c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="天安门的全景图"><br>他在大屏幕下显示非常的效果非常的好，但是在小屏幕下这个全景图显示就显得太小了，如果我们可以在手机上能放大，能展现出来一个更突出的一个裁切后的全景图那样就更好了，那么如果我们在一个srcset中的引入一个裁切后的版本，那么我们就无法分辨他们何时应该去选用何时不应该去选用，而使用了picture我们就能明确的表达出我们的意图，比如说我们只在视口宽度超过800像素的时候加载宽的版本，比这个小的视口中我们总是加载裁切后的版本。代码如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">picture</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">"(max-width:36em)"</span></span></div><div class="line">                <span class="attr">srcset</span>=<span class="string">"http://www.fansimg.com/uploads2011/05/userid280713time20110508081514.jpg 768w"</span>/&gt;</div><div class="line"> <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">"http://www.fansimg.com/uploads2011/05/userid280713time20110508081514.jpg 1800w"</span>/&gt;</span></div><div class="line"> ![这里是图片](http://upload-images.jianshu.io/upload_images/68937-29a9b3a19ef73f6c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"> <span class="tag">&lt;/<span class="name">picture</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-198eb46728db123c.gif?imageMogr2/auto-orient/strip" alt="responsive-2.gif"><br><a href="http://sandbox.runjs.cn/show/w4ncyudb" target="_blank" rel="external">在线演示</a>，<a href="http://sandbox.runjs.cn/cod/w4ncyudb" target="_blank" rel="external">源码</a></p>
<p>source中除了可以有媒体查询之外，还可以正对媒体查询设置多组不同格式的文件，比如source中还有<code>type</code>属性，可以是“image/svg+xml”等格式文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;source type=&quot;image/svg+xml&quot; srcset=&quot;logo.svg 480w, logo.svg 800w, logo.svg 1600w &quot;/&gt;</div><div class="line">&lt;source type=&quot;image/webp&quot; srcset=&quot;logo.webp 480w, logo-m.webp 800w, logo-l.webp 1600w &quot;/&gt;</div></pre></td></tr></table></figure></p>
<h2 id="第五种，svg"><a href="#第五种，svg" class="headerlink" title="第五种，svg"></a>第五种，svg</h2><p>svg是可缩放的矢量图形，它是基于可扩展标记语言来生成的，svg图像可以用任何的文本编辑器来创建，但是一般人很少会去用文本编辑器来创建svg图片，因为这个非常的麻烦，除非你就只需要几条横线几个圆圈什么的。</p>
<p>什么是矢量图形？矢量图形就是这些图形，在说话的时候它都不会失真和变形，这些图形它不是基于像素的，而是基于一个绘制的规则，一旦我们确定了绘制的规则，比如说颜色、形状、轮廓、大小、屏幕位置等等，确定了这些规则，即使我们发生了缩放也不会影响这些图形的绘制，所以这些图像当然也不会发生失真，但是这些矢量图形的和位图比起来其实有缺点的，最大的缺点的就是它很难去表现色彩层次丰富和逼真的图像效果。比如让我们的一个照片变成一个矢量图形，那么这个这个矢量图形肯定要大了去了，要变的非常的非常的大，因为每个像素他可能就要有一个绘制的规则，所以根据我们的需要可以去选择你使用矢量图形还是要位图，一般来说针对一些logo，简单的图标，比如说回收站、消息等等这样一些图标，我们可以使用svg这种矢量图形。</p>
<p>说到矢量图形，肯定就要想怎么样去画它了，刚才说用文本编辑器肯定不行的，这样太麻烦了，那么其实大部分支持矢量图绘制的工具其实都支持绘制svg。</p>
<p>相比srcset和picture，picture对于IE浏览器是完全不兼容的，对于老的Safari浏览器和老的安卓浏览器也是不兼容的，对于srcset，比picture稍微好一点，对于老的IE和安卓浏览器也是不兼容的。而SVG兼容性就好的多了，除了IE8不支持外，其他的浏览器几乎都支持SVG。</p>
<h2 id="使用第三方库"><a href="#使用第三方库" class="headerlink" title="使用第三方库"></a>使用第三方库</h2><p>由于我们的广告的一看就是一个位图的图形，它的里边色彩比较丰富，所以我们使用svg不太合适，使用位图要实现响应式就要配合srcset或者picture，由于兼容性的问题一般在使用srcset或者picture的时候一般会使用一个polyfill。</p>
<p>什么是polyfill？它来自于一个家装产品，这个家装产品是一个刮墙的产品，中国人一般把这个产品的叫做腻子，就是刮墙的腻子，它可以把墙的一些裂缝给填平，比如说我们墙皮时间长了会出现一些裂缝，这个腻子可以把它给填平，让砖块变得更平滑，在js的世界里polyfill他的意思就是一个在浏览器上的一个腻子，就是填平浏览器上面的兼容性的一些东西，比如我们使用picture，如果浏览器支持那就没有问题，我们正常的使用就可以了，如果浏览器不支持那么就需要使用一个替代的方案来解决，polyfill就是填平了这些浏览器的兼容性的一些坑。</p>
<p>经常使用解决兼容性的一个polyfill，polyfill其实是一种想法，一种脚本，针对某些浏览器的兼容性就会有某些的polyfill出现，对于响应式图片最有名的polyfill就是<a href="http://scottjehl.github.io/picturefill/" target="_blank" rel="external">picturefill</a>库。</p>
<p>我们只需要引入这个库就行了（picturefill.min.js）<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ad"</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"owl-carousel owl-theme"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">picture</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">"img/ad001-l.png"</span> <span class="attr">media</span>=<span class="string">"(min-width:50em)"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">"img/ad001-m.png"</span> <span class="attr">media</span>=<span class="string">"(min-width:30em)"</span>&gt;</span></div><div class="line">     ![](img/ad001.png)</div><div class="line"> <span class="tag">&lt;/<span class="name">picture</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">picture</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">"img/ad002-l.png"</span> <span class="attr">media</span>=<span class="string">"(min-width:50em)"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">"img/ad002-m.png"</span> <span class="attr">media</span>=<span class="string">"(min-width:30em)"</span>&gt;</span></div><div class="line">     ![](img/ad002.png)</div><div class="line"> <span class="tag">&lt;/<span class="name">picture</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">picture</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">"img/ad003-l.png"</span> <span class="attr">media</span>=<span class="string">"(min-width:50em)"</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">source</span> <span class="attr">srcset</span>=<span class="string">"img/ad003-m.png"</span> <span class="attr">media</span>=<span class="string">"(min-width:30em)"</span>&gt;</span></div><div class="line">     ![](img/ad003.png)</div><div class="line"> <span class="tag">&lt;/<span class="name">picture</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vendor/OwlCarousel2/owl.carousel.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vendor/picturefill.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><a href="http://sandbox.runjs.cn/show/msx5rkla" target="_blank" rel="external">在线查看</a>，<a href="http://sandbox.runjs.cn/code/msx5rkla" target="_blank" rel="external">源码</a></p>
<p>跟多代码及完整响应式网页案例请查到这里<a href="https://github.com/dunizb/CodeTest/tree/master/%E7%A7%BB%E5%8A%A8Web%26%E5%93%8D%E5%BA%94%E5%BC%8F/licaibao" target="_blank" rel="external">GitHub</a>查看。</p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 响应式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何正确高效的使用群聊？]]></title>
      <url>/2017/02/13/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E9%AB%98%E6%95%88%E7%9A%84%E4%BD%BF%E7%94%A8%E7%BE%A4%E8%81%8A%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>完全没用过WeChat或扣扣群聊的人恐怕很少。我们工作和日常交流中，难免要借助于WeChat或是扣扣群的形式进行沟通。<br><a id="more"></a><br><img src="http://upload-images.jianshu.io/upload_images/68937-8fdbe43c3794e835.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="如何正确高效的使用群聊"></p>
<p>我观察到一个有趣的现象，确实不少人讨厌群组 (Group) 聊天，但也有更多人喜欢参与各种群，而且乐此不疲。</p>
<p>我个人是非常讨厌群聊的，特别是WeChat群？很多群没有任何规范，群里的人也没有学会正确的使用方法，导致群里大部分时间里都是低效和无意义的，是在浪费时间！</p>
<p>群是个杀时间的工具。如果不是有大把的时间，真没必要在各个群里参与各种话题，聊起来会没完没了，而且很容易跑题。说起跑题，建议有空看一下《罗伯特议事规则》，会有启发。</p>
<p>我们公司有个总群，就是所有公司员工都在的群，现在的情况是，变成了个别部门的聊天群了，不管什么消息，一股脑的往群里发，而且特别奇葩的是一条消息他们还要复制粘贴转发无数次。</p>
<p>特别的，WeChat群不同于扣扣群，没有屏蔽群聊消息功能，只有不提示新消息功能，但是只要有新群聊信息就会有小红点，如果你没兴趣看群聊，或者群聊信息跟你没什么关系的话，你只能接受新消息小红点，并且还要耗费流量（如果你用流量上网）和储存空间的（发的图片和视频）。</p>
<p>真是受够了！</p>
<p>有些人担心错过重要的信息，不用担心，如果一个信息确实与你有关，别人会主动来找你。如果一个消息可能重要，不会只出现一次。</p>
<p>那么如何才是正确的使用群聊的方法？</p>
<p>我的原则是这样：既然不得不使用，那就不如尝试高效一点。</p>
<p>1.最重要的一个好习惯：加入群后，迅速修改昵称，最好改成自己的名字。修改成「名字-部门名」，如果是对外合作，修改成「名字-公司名」，这样别人看信息一目了然。</p>
<p>2.提到某人，如果要提醒他/她看，学会使用 <code>@</code> 语法。</p>
<p>3.对于公司，应该各部门各小组建立自己的群，自己部门自己小组相关的信息发在自己的群。对于需要其他部门知晓的信息才可以在总群里发。</p>
<p>4.总群发言规范。<br>a. 需要全公司都知道的重要消息通知等<br>b. 各部门小组群需要同志其他部门小组的人的时候<br>c. 尽量一个消息说完，避免一个消息发很多条简短意义不明确的消息</p>
<p>以上是使用群聊的一些建议，供大家参考。</p>
<hr>
<p>参考文章：<a href="http://mp.weixin.qq.com/s/NEZc35JmT69EGVNwPssu0Q" target="_blank" rel="external">小道消息</a></p>
]]></content>
      
        <categories>
            
            <category> 随笔扯谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue.js常用开发知识简要入门（三）]]></title>
      <url>/2017/02/13/Vue.js%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%AE%80%E8%A6%81%E5%85%A5%E9%97%A8(%E4%B8%89)/</url>
      <content type="html"><![CDATA[<h2 id="组件的注册与使用"><a href="#组件的注册与使用" class="headerlink" title="组件的注册与使用"></a>组件的注册与使用</h2><p>例如，注册一个Hello组件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Hello = Vue.extend(&#123;        <span class="comment">//返回预设选项的Vue构造器（子类）</span></div><div class="line">   data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">msg</span>: <span class="string">'Hello，Vue.js'</span></div><div class="line">       &#125;</div><div class="line">   &#125;,</div><div class="line">   <span class="attr">template</span>: <span class="string">'&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;'</span>      </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这样，就创建了一个<code>h1</code>标签，标签内容为Hello，Vue.js的Hello组件，我们可以使用全局注册来使用这个组建：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">    &lt;Hello&gt;&lt;/Hello&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;script&gt;</div><div class="line">//全局注册</div><div class="line">Vue.component('Hello',Hello);</div><div class="line"></div><div class="line">new Vue(&#123;</div><div class="line">     el: 'body',</div><div class="line">     components: &#123;</div><div class="line">          // 'Hello': Hello,    //局部注册</div><div class="line">          'Temp': Temp</div><div class="line">     &#125;</div><div class="line">&#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>当然，我们也可以使用局部注册。</p>
<p>template实例模版，用户替换或插入挂载元素，元素可以使用<code>#</code>选择子，使用匹配元素的<code>innerHTML</code>作为模板<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">    &lt;Hello&gt;&lt;/Hello&gt;</div><div class="line">    &lt;Temp&gt;&lt;/Temp&gt;</div><div class="line"></div><div class="line">    &lt;template id="template-use"&gt;</div><div class="line">        &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</div><div class="line">        &lt;p&gt;Demos 代码演示、代码片段 - 读你 | 这世间唯有梦想和好姑娘不可辜负!&lt;/p&gt;</div><div class="line">    &lt;/template&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;script&gt;</div><div class="line">var Temp = Vue.extend(&#123; </div><div class="line">   data: function() &#123;</div><div class="line">       return &#123;</div><div class="line">            msg: '组件的注册与使用'</div><div class="line">       &#125;</div><div class="line">   &#125;,</div><div class="line">   template: '#template-use'      </div><div class="line">&#125;);</div><div class="line"></div><div class="line">new Vue(&#123;</div><div class="line">     el: 'body',</div><div class="line">     components: &#123;</div><div class="line">          'Hello': Hello,    //局部注册</div><div class="line">          'Temp': Temp</div><div class="line">     &#125;</div><div class="line">&#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p><strong>使用 Vue 扩展构造 Vue 实例时，实例选项中的 methods 属性会覆盖扩展选项中的 methods 属性？</strong></p>
<ul>
<li>Vue 扩展是一个提供了部分可复用的数据、方法……选项的 Vue 构造器，可以直接使用 new MyVue(options) 这样的方式来构造 Vue 实例；只要愿意，可以在一个页面上使用 Vue 构造器或者 Vue 扩展构造器创建任意个 Vue 实例；使用 Vue 扩展构造 Vue 实例时，选项级别的属性并不是直接覆盖.</li>
<li>如 Vue 扩展选项里包括 methods 属性，调用该扩展构造器时也传入了 methods，则会将两个 methods 中的内容合并成一个新对象，仅当存在键名冲突时，实例选项中的方法覆盖扩展选项中的同名方法.</li>
<li>data 属性的情况类似，但更复杂，键名冲突时，当 data 属性中的数据是数值时，使用实例选项中的数据覆盖扩展选项中的数据，当 data 属性中的数据是对象时，将两个对象按相同规则继续合并，此外，同名钩子会组成数组，在生命周期中事件触发时均会被调用.</li>
<li>使用 Vue.extend 创建 Vue 扩展时，扩展选项中的 data 和 el 必须是返回相关数据的函数，即使使用指向同一个数据对象的变量作为函数的返回值，通过 Vue 扩展创建的 Vue 实例的数据也是不同的。</li>
</ul>
<p><strong>注意：</strong><br>当自定义标签所对应的模板中可能包含多个顶级元素时，由于指令优先级的关系，不能使用 v-show 指令，并且在任何自定义标签后的元素中，v-else 均无效；由于 v-if 的初始化处理方式不同（根据绑定数据决定是否创建 DOM 元素，而不是设置 display 属性），在自定义标签中使用 v-if 指令是可以的，并且允许在后续标签中使用 v-else。</p>
<h2 id="使用props传递数据"><a href="#使用props传递数据" class="headerlink" title="使用props传递数据"></a>使用props传递数据</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">   &lt;child title="Vue.js权威指南" author="滴滴前端" price="89"&gt;&lt;/child&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;script src="http://cdnjs.cloudflare.com/ajax/libs/vue/1.0.26/vue.min.js"&gt;&lt;/script&gt;</div><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">    //注册组建</div><div class="line">    var child = Vue.component('child',&#123;</div><div class="line">        props: [</div><div class="line">            'title','author','price'</div><div class="line">        ],</div><div class="line">        template: `&lt;span :title="title"&gt;&#123;&#123;title&#125;&#125;&lt;/span&gt;</div><div class="line">                &lt;span :author="author"&gt;&#123;&#123;author&#125;&#125;&lt;/span&gt;</div><div class="line">                &lt;span :price="price"&gt;&#123;&#123;price&#125;&#125;&lt;/span&gt;`</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    //使用组建</div><div class="line">    new Vue(&#123;</div><div class="line">        el: 'body',</div><div class="line">        components: &#123; child &#125;</div><div class="line">    &#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>这里使用了另一种创建组建的方式，属于Vue语法糖，背后会自动使用<code>Vue.extend()</code>.</p>
<h3 id="prop-校验"><a href="#prop-校验" class="headerlink" title="prop 校验"></a>prop 校验</h3><ul>
<li>type：类型 </li>
<li>required：是否必须 </li>
<li>towWay：是否双向 </li>
<li>default：默认值</li>
<li>validator：自定义校验函数</li>
<li>coerce：转换函数</li>
<li>type 为 String、Number、Boolean、Function、Object、Array等原生构造器或自定义构造器</li>
<li>仅有 type 时可不适用对象语法</li>
<li>可设置为构造器数组</li>
<li>如果设置了转换函数，先转换再判断 type</li>
</ul>
<h2 id="单文件组建规范"><a href="#单文件组建规范" class="headerlink" title="单文件组建规范"></a>单文件组建规范</h2><h3 id="单文件组建的结构"><a href="#单文件组建的结构" class="headerlink" title="单文件组建的结构"></a>单文件组建的结构</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">    &lt;span&gt;![](../img/logo.png)&lt;/span&gt;</div><div class="line">&lt;/template&gt;</div><div class="line">&lt;script&gt;</div><div class="line">export default&#123;</div><div class="line">    props: ['componentName']</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;style&gt;</div><div class="line">img.log&#123;</div><div class="line">    width:16px;height:16px;</div><div class="line">&#125;</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure>
<h3 id="语言块"><a href="#语言块" class="headerlink" title="语言块"></a>语言块</h3><p><strong>template块</strong><br>默认语言html，每个文件允许最多一个template块</p>
<p><strong>script块</strong><br>默认语言js，每个文件允许最多一个script块</p>
<p><strong>style块</strong><br>默认语言CSS，支持多个style块</p>
<p>Vue.js 的单文件组件中不一定要有 template 语言块，再者，即使确实需要 template 属性，script 语言块中输出的组件选项中也可以包含字符串形式的 template属性。为了更好地组织样式，一个单文件组件中允许有多个 style 语言块。template 语言块的默认语言是 html，还可以设置为其他预处理的模板语言如 jade。script 语言块的默认语言是 js，也允许设置使用其他语言如 CoffeeScript、TypeScript 等。</p>
<h3 id="src引用"><a href="#src引用" class="headerlink" title="src引用"></a>src引用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;template src=<span class="string">"./template.html"</span>&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></div><div class="line">&lt;script src=<span class="string">"./script.js"</span>&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line">&lt;style src=<span class="string">"./style.css"</span>&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>支持src引用，遵循CommonJS路径规范。</p>
<hr>
<p>本人出售《Vue.js权威指南》，二手价20元！点击下图购买</p>
<p><strong>++++++++++<a href="http://dunizb.com/obook/">20元出售此书</a>++++++++++</strong><br><a href="http://dunizb.com/obook/"><img src="http://upload-images.jianshu.io/upload_images/68937-4b8b1cbd73a8fd1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Vue.js权威指南"></a></p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Vue.js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue.js常用开发知识简要入门（一）]]></title>
      <url>/2016/12/18/Vue.js%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E7%AE%80%E8%A6%81%E5%85%A5%E9%97%A8(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/68937-7689aa4711f8e5ed.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Vue.js常用开发知识简要入门（一）"></p>
<h2 id="Vue-cli创建项目"><a href="#Vue-cli创建项目" class="headerlink" title="Vue-cli创建项目"></a>Vue-cli创建项目</h2><ul>
<li>安装：npm install -g vue-cli</li>
<li>vue list命令 ：查看官方模版列表</li>
<li>初始化项目：vue init webpack 项目名 </li>
<li>安装依赖：npm install </li>
<li>运行：npm run dev</li>
</ul>
<h2 id="Vue动画支持（transition）"><a href="#Vue动画支持（transition）" class="headerlink" title="Vue动画支持（transition）"></a>Vue动画支持（transition）</h2><p>以DIV从右到做的飞入动画为例。<br>在需要加动画的组建上设置属性：transition=”动画名称”<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">"showFlag"</span> <span class="attr">transition</span>=<span class="string">"move"</span> <span class="attr">class</span>=<span class="string">"food"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这里给要添加动画的组建设置了transition属性，并且值等于move，也就是去个名字</p>
<p>然后在style样式中分别写两个样式：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"less"</span> <span class="attr">rel</span>=<span class="string">"stylesheet/less"</span>&gt;</span><span class="undefined"></span></div><div class="line">  .food&#123;</div><div class="line">    // 其他样式</div><div class="line">    ... ...</div><div class="line">    &amp;.move-transition&#123;</div><div class="line">      transition: all .2s linear;</div><div class="line">      transform: translate3d(0,0,0);</div><div class="line">    &#125;</div><div class="line">    &amp;.move-enter,&amp;.move-leave&#123;</div><div class="line">      transform: translate3d(100%,0,0);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>样式以“动画名称-transition”为名，表示动画开始的设置，以“enter”“leave”结尾的表示动画结束的设置。</p>
<p>这样就完成了一个简单的Vue动画。</p>
<h2 id="父组建调用子组件方法（v-ref）"><a href="#父组建调用子组件方法（v-ref）" class="headerlink" title="父组建调用子组件方法（v-ref）"></a>父组建调用子组件方法（v-ref）</h2><p>parent组件中有child组件，并且在子组件上设置v-ref属性：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">   // child组建</div><div class="line">   <span class="tag">&lt;<span class="name">child</span> <span class="attr">v-ref:child</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/ecmascript-6"</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</div><div class="line">        <span class="attr">methods</span>: &#123;</div><div class="line">            methodA() &#123;</div><div class="line">                <span class="comment">// 调用子组件方法</span></div><div class="line">                <span class="keyword">this</span>.$refs.child.show();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"less"</span> <span class="attr">rel</span>=<span class="string">"stylesheet/less"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>注意：v-ref后面的值是以“:”连接的而不是“=”号。“this.$refs.child”就是获取到子组件。</p>
<p>child子组件内容<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是child组建<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/ecmascript-6"</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</div><div class="line">        <span class="attr">methods</span>: &#123;</div><div class="line">            show() &#123;</div><div class="line">                <span class="comment">//方法内容</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"less"</span> <span class="attr">rel</span>=<span class="string">"stylesheet/less"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="子组建通知父组件（事件派发-dispatch）"><a href="#子组建通知父组件（事件派发-dispatch）" class="headerlink" title="子组建通知父组件（事件派发$dispatch）"></a>子组建通知父组件（事件派发$dispatch）</h2><p>在子组件方法中<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.$dispatch(<span class="string">'content.toggle'</span>, type);</div></pre></td></tr></table></figure></p>
<p><code>ratingtype.select</code>是自定义事件名，在父组件中可以监听该事件，在父组件中定义events属性处理事件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">events: &#123;</div><div class="line">      <span class="string">'ratingtype.select'</span>(type) &#123;</div><div class="line">        <span class="keyword">this</span>.selectType = type;</div><div class="line">      &#125;,</div><div class="line">      <span class="string">'content.toggle'</span>(onlyContent) &#123;</div><div class="line">        <span class="keyword">this</span>.onlyContent = onlyContent;</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="DOM绑定（v-el）"><a href="#DOM绑定（v-el）" class="headerlink" title="DOM绑定（v-el）"></a>DOM绑定（v-el）</h2><p>通过给div设置“v-el:xxx”就如同给div设置一个id属性，然后可以通过这个id获取DIV元素。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"food"</span> <span class="attr">v-el:food</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>然后在使用$els即可访问该元素<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> food = <span class="keyword">this</span>.$els.food;</div></pre></td></tr></table></figure></p>
<p>food得到的就是一个DOM对象</p>
<h2 id="阻止元素点击穿透和冒泡"><a href="#阻止元素点击穿透和冒泡" class="headerlink" title="阻止元素点击穿透和冒泡"></a>阻止元素点击穿透和冒泡</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.stop.prevent</span>=<span class="string">"test"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="生命周期不重新加载（keep-alive）"><a href="#生命周期不重新加载（keep-alive）" class="headerlink" title="生命周期不重新加载（keep-alive）"></a>生命周期不重新加载（keep-alive）</h2><p>在切换路由的时候不希望每次切换都重新被渲染一次，可以在路由出口上添加keep-alive属性即可<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">:user</span>=<span class="string">"user"</span> <span class="attr">keep-alive</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="项目编译打包注意"><a href="#项目编译打包注意" class="headerlink" title="项目编译打包注意"></a>项目编译打包注意</h2><p>使用vue-cli创建的项目使用npm run build命令进行打包编译成静态文件。但是可能遇到如下异常：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- building <span class="keyword">for</span> production...shell.js: internal error</div><div class="line"><span class="built_in">Error</span>: ENOENT: no such file or directory, stat <span class="string">'D:\xxxxxapp\static\*'</span></div><div class="line">... ...</div></pre></td></tr></table></figure></p>
<p>此时，可以尝试更新shelljs包的版本，如项目中shelljs当前版本是0.6.0，那么可以更新至0.7.4（npm update shelljs@0.7.4）后再次进行build命令</p>
<hr>
<p>本人出售《Vue.js权威指南》，二手价20元！点击下图购买</p>
<p><strong>++++++++++<a href="http://dunizb.com/obook/">20元出售此书</a>++++++++++</strong><br><a href="http://dunizb.com/obook/"><img src="http://upload-images.jianshu.io/upload_images/68937-4b8b1cbd73a8fd1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Vue.js权威指南"></a></p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> Vue.js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用SpringMVC+Mybatis搭建高性能安全站点]]></title>
      <url>/2016/11/01/%E4%BD%BF%E7%94%A8SpringMVC-Mybatis%E6%90%AD%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E5%AE%89%E5%85%A8%E7%AB%99%E7%82%B9/</url>
      <content type="html"><![CDATA[<h2 id="一、网站安全"><a href="#一、网站安全" class="headerlink" title="一、网站安全"></a>一、网站安全</h2><h3 id="1-1-XSS跨站脚本"><a href="#1-1-XSS跨站脚本" class="headerlink" title="1.1 XSS跨站脚本"></a>1.1 XSS跨站脚本</h3><p>XSS又称CSS，全称Cross Site Script，跨站脚本攻击，是Web程序中常见的漏洞，XSS属于被动式且用于客户端的攻击方式，所以容易被忽略其危害性。其原理是攻击者向有XSS漏洞的网站中输入(传入)恶意的HTML代码，当其它用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。如，盗取用户Cookie、破坏页面结构、重定向到其它网站等。</p>
<p>一个简单的例子，页面名字叫test.jsp：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>   </div><div class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span>     </div><div class="line">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>XSS测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span>   </div><div class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span>   </div><div class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span>     </div><div class="line">      页面内容：<span class="tag">&lt;<span class="name">%=request.getParameter("content")%</span>&gt;</span>   </div><div class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>请求下面链接就会出现问题了：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://www.domain.com/test.jsp?content=<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="string">'XSS注入'</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="1-2-SQL注入"><a href="#1-2-SQL注入" class="headerlink" title="1.2 SQL注入"></a>1.2 SQL注入</h3><p>SQL Injection，就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p>
<p>典型例子：<br>国内最大的程序员社区CSDN网站的用户数据库被黑客公开发布，600万用户的登录名及密码被公开泄露。</p>
<p>一个简单的例子，比如请求连接获取用户信息，请求连接为：<code>http://www.example.com/user?userId=1</code>，通常代码中会执行SQL语句：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_user <span class="keyword">where</span> userId=$&#123;userId&#125;</div></pre></td></tr></table></figure></p>
<p>假如SQL注入，请求连接为：<code>http://www.example.com/user?userId=1 or 1=1</code>，SQL会执行：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_user <span class="keyword">where</span> userId=<span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span>=<span class="number">1</span></div></pre></td></tr></table></figure></p>
<h2 id="二、解决之道-─-使用HttpServletRequestWrapper类"><a href="#二、解决之道-─-使用HttpServletRequestWrapper类" class="headerlink" title="二、解决之道 ─ 使用HttpServletRequestWrapper类"></a>二、解决之道 ─ 使用HttpServletRequestWrapper类</h2><p>定义一个Filter,使用HttpServletRequestWrapper类截获并处理参数：</p>
<ul>
<li><code>&lt;</code> –&gt; <code>&amp;lt;</code></li>
<li><code>&gt;</code> –&gt; <code>&amp;gt;</code></li>
<li><code>(</code> –&gt; <code>&amp;#40;</code></li>
<li><code>)</code> –&gt; <code>&amp;#41;</code></li>
<li><code>&#39;</code> –&gt; <code>&amp;#39;</code></li>
<li><code>eval((.*))</code>  –&gt; <code>空</code></li>
<li><code>[\&quot;\&#39;][\s]*javascript:(.*)[\&quot;\&#39;]</code>  –&gt; <code>空</code></li>
<li><code>script</code>  –&gt; <code>空</code></li>
</ul>
<h3 id="2-1-定义XssFilter过滤器类"><a href="#2-1-定义XssFilter过滤器类" class="headerlink" title="2.1 定义XssFilter过滤器类"></a>2.1 定义XssFilter过滤器类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.dunizb.demo.common;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> javax.servlet.Filter;</div><div class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</div><div class="line"><span class="keyword">import</span> javax.servlet.FilterConfig;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletException;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XssFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span></div><div class="line">            FilterChain chain) <span class="keyword">throws</span> IOException, ServletException &#123;</div><div class="line">        chain.doFilter(request, response);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig arg0)</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">        <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-2-在web-xml中配置过滤器"><a href="#2-2-在web-xml中配置过滤器" class="headerlink" title="2.2 在web.xml中配置过滤器"></a>2.2 在web.xml中配置过滤器</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">&lt;filter&gt;</div><div class="line">  &lt;filter-name&gt;XssFilter&lt;/filter-name&gt;</div><div class="line">  &lt;filter-class&gt;com.jikexueyuan.demo.common.XssFilter&lt;/filter-class&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;filter-mapping&gt;</div><div class="line">  &lt;filter-name&gt;XssFilter&lt;/filter-name&gt;</div><div class="line">  &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;</div><div class="line">&lt;/filter-mapping&gt;</div><div class="line">```  </div><div class="line"></div><div class="line">### 2.3 使用HttpServletRequestWrapper拦截请求</div><div class="line"></div><div class="line">```java</div><div class="line">package com.dunizb.demo.common;</div><div class="line">import javax.servlet.http.HttpServletRequest;</div><div class="line">import javax.servlet.http.HttpServletRequestWrapper;</div><div class="line"></div><div class="line">public class XssHttpServletRequestWraper extends HttpServletRequestWrapper &#123;</div><div class="line">    public XssHttpServletRequestWraper(HttpServletRequest request) &#123;</div><div class="line">        super(request);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public String getParameter(String name) &#123;</div><div class="line">        return clearXss(super.getParameter(name));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public String getHeader(String name) &#123;</div><div class="line">        return clearXss(super.getHeader(name));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @Override</div><div class="line">    public String[] getParameterValues(String name) &#123;</div><div class="line">        String[] values = super.getParameterValues(name);</div><div class="line">        String[] newValues = new String[values.length];</div><div class="line">        </div><div class="line">        for(int i =0; i&lt; values.length; i++)&#123;</div><div class="line">            newValues[i] = clearXss(values[i]);</div><div class="line">        &#125;</div><div class="line">        return newValues;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 处理字符转义</div><div class="line">     * @param value</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    private String clearXss(String value)&#123;</div><div class="line">        if (value == null || "".equals(value)) &#123;</div><div class="line">            return value;</div><div class="line">        &#125;</div><div class="line">        value = value.replaceAll("&lt;", "&amp;lt;").replaceAll("&gt;", "&amp;gt;");</div><div class="line">        value = value.replaceAll("\\(", "&amp;#40;").replace("\\)", "&amp;#41;");</div><div class="line">        value = value.replaceAll("'", "&amp;#39;");</div><div class="line">        value = value.replaceAll("eval\\((.*)\\)", "");</div><div class="line">        value = value.replaceAll("[\\\"\\\'][\\s]*javascript:(.*)[\\\"\\\']", "\"\"");</div><div class="line">        value = value.replace("script", "");</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="三、提升性能：使用Mybatis的二级缓存策略"><a href="#三、提升性能：使用Mybatis的二级缓存策略" class="headerlink" title="三、提升性能：使用Mybatis的二级缓存策略"></a>三、提升性能：使用Mybatis的二级缓存策略</h2><p>一级缓存是SqlSession级别的缓存，MyBatis默认开启一级缓存。</p>
<p>二级缓存是mapper级别的缓存，是多个SqlSession共享的，其作用域是mapper的同一个namespace，MyBatis默认没有开启二级缓存，需要在setting全局参数中配置开启二级缓存。如果缓存中有数据就不用从数据库中获取，大大提高系统性能。</p>
<h3 id="3-1-配置缓存"><a href="#3-1-配置缓存" class="headerlink" title="3.1 配置缓存"></a>3.1 配置缓存</h3><p>mybaits的二级缓存是mapper范围级别，除了在SqlMapConfig.xml设置二级缓存的总开关，还要在具体的mapper.xml中开启二级缓存。</p>
<p>Mybatis缓存使用起来非常方便，三个配置就搞定：</p>
<p><strong>第一个需要配置config.xml ，开启缓存</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>第二个需要在M apper文件头指定使用缓存</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">readOnly</span>=<span class="string">"true"</span> <span class="attr">size</span>=<span class="string">"500"</span> <span class="attr">flushInterval</span>=<span class="string">"120000"</span> <span class="attr">eviction</span>=<span class="string">"LRU"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>其中：<br><strong>readOnly=”true”</strong>则所有相同的SQL语句返回的是同一个对象，这样有助于提高性能，但并发操作同一条数据时可能不安全，如果设置为false，则相同的SQL语句访问的是cache中的副本。</p>
<p><strong>size=500</strong>是指缓存多少个对象，默认值是1024。</p>
<p><strong>flushInterval=”120000”</strong>指定缓存过期的时间，单位为毫秒，默认是空，也就是说只要容量足够永远不会过期。</p>
<p><strong>eviction=”LRU”</strong>是缓存的淘汰算法，默认算法是最近最少使用算法，也就是LRU。</p>
<p>第三个配置，在具体的SQ L语句处指定使用缓存，默认开启</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectCount"</span> <span class="attr">useCache</span>=<span class="string">"true"</span>&gt;</span>   </div><div class="line">    ...</div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="3-2-缓存策略"><a href="#3-2-缓存策略" class="headerlink" title="3.2 缓存策略"></a>3.2 缓存策略</h3><p>Mybatis有4个最常见的缓存策略：</p>
<ul>
<li>LRU，最近最少使用，移除最长时间不被使用的对象，默认策略</li>
<li>FIFO，先进先出，按对象进入缓存的顺序来移除它们</li>
<li>SOFT，软引用，移除基于垃圾回收器状态和软引用规则的对象</li>
<li>WEAK，弱引用，更积极地移除基于垃圾收集器状态和弱引用规则的对象</li>
</ul>
<h2 id="四、在Linux服务器上部署项目"><a href="#四、在Linux服务器上部署项目" class="headerlink" title="四、在Linux服务器上部署项目"></a>四、在Linux服务器上部署项目</h2><p>需要Linux操作系统具备如下环境：</p>
<ol>
<li>JDK7+</li>
<li>Tomcat7+</li>
<li>MySQL5</li>
<li>Nginx</li>
</ol>
<p>部署过程：</p>
<ol>
<li>导出项目为war包，重命名为ROOT.war</li>
<li>上传到服务器Tomcat的webapps目录</li>
<li>把本地的MySQL数据库导入到服务器上，把xxx.sql上传到服务器</li>
<li><p>创建数据库：</p>
<ul>
<li>连接数据库：<code>mysql -uroot -p</code></li>
<li>显示数据库：<code>show database;</code></li>
<li>创建数据库：<code>create database 数据库名</code></li>
<li>打开创建的数据库：<code>use 数据库名</code></li>
<li>执行xxx.sql文件：<code>source /expost/tomcat/webapps/xxx.sql</code></li>
<li>显示数据库中的表：<code>show tables;</code></li>
<li>退出MySQL：<code>exit</code></li>
</ul>
</li>
<li><p>定义Tomcat端口号为808：<code>vi config/server.xml</code></p>
</li>
<li>退出vi编辑器：<code>:wq</code></li>
<li>启动Tomcat：<code>./bin/startup.sh</code>,观察日志：<code>tail -f logs/catalina.out</code></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript面向对象核心知识归纳]]></title>
      <url>/2016/10/25/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E5%BD%92%E7%BA%B3/</url>
      <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol>
<li>面向对象就是使用对象。面向对象开发就是使用对象开发。</li>
<li>面向过程就是用过程的方式进行开发。面向对象是对面向过程的封装。</li>
</ol>
<h3 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h3><p><strong>抽象性</strong><br>所谓的抽象性就是：如果需要一个对象描述数据，需要抽取这个对象的核心数据</p>
<ol>
<li>提出需要的核心属性和方法</li>
<li>不在特定的环境下无法明确对象的具体意义</li>
</ol>
<p><strong>封装性</strong><br>对象是将数据与功能组合到一起，即封装</p>
<ol>
<li>JS对象就是键值对的集合，键值如果是数据（基本数据、符合数据、空数据）就称为属性，如果键值是函数那么就称为方法</li>
<li>对象就是将属性与方法封装起来</li>
<li>方法是将过程封装起来</li>
</ol>
<p><strong>继承性</strong><br>所谓继承性就是自己没有但是别人有，拿过来成为自己的，就是继承，继承是实现复用的一种手段</p>
<ul>
<li>在Java等语言中继承满足一个class的规则，类是一个class，他规定了一个对象有什么属性和方法。</li>
<li>在这些语言中继承是class之间的继承，一个class继承另一个class，那么该class就有了另一个class的成员，那么由该class创建出来的对象就同时具有两个class的成员。</li>
</ul>
<p>在JS中没有明确的继承语法（ES6提供了class extend语法），一般都是按照继承的理念实现对象的成员扩充实现继承，因此JS中实现继承的方法非常对多。</p>
<p>传统继承基于类，JS继承基于对象</p>
<p> 一个简单的继承模式：混入（mix）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mix</span> (<span class="params"> o1, o2 </span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> ( <span class="keyword">var</span> k <span class="keyword">in</span> o2 ) &#123;</div><div class="line">        o1[ k ] = o2[ k ];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="关于面向对象的一些其他概念"><a href="#关于面向对象的一些其他概念" class="headerlink" title="关于面向对象的一些其他概念"></a>关于面向对象的一些其他概念</h3><p><strong>类class：在JS中就是构造函数</strong></p>
<ul>
<li>在传统的面向对象语言中，使用一个叫类的东西定义模板，然后使用模板创建对象。</li>
<li>在构造方法中也具有类似的功能，因此也称其为类</li>
</ul>
<p><strong>实例（instance）与对象（object）</strong></p>
<ul>
<li>实例一般是指某一个构造函数创建出来的对象，我们称为XXXX 构造函数的实例</li>
<li>实例就是对象。对象是一个泛称</li>
<li>实例与对象是一个近义词</li>
</ul>
<p><strong>键值对与属性和方法</strong></p>
<ul>
<li>在JS中键值对的集合称为对象</li>
<li>如果值为数据（非函数），就称该键值对为属性</li>
<li>如果值为函数（方法），就称该键值对为方法method</li>
</ul>
<p><strong>父类与子类（基类和派生类）</strong></p>
<ul>
<li>传统的面向对象语言中使用类来实现继承那么就有父类、子类的概念</li>
<li>父类又称为基类，子类又称为派生类</li>
<li>在JS中没有类的概念，在JS中常常称为父对象，子对象，基对象，派生对象。</li>
</ul>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="构造函数是干什么用的"><a href="#构造函数是干什么用的" class="headerlink" title="构造函数是干什么用的"></a>构造函数是干什么用的</h3><ol>
<li>初始化数据的</li>
<li>在JS中给对象添加属性用的，初始化属性值用的</li>
</ol>
<h3 id="创建对象的过程"><a href="#创建对象的过程" class="headerlink" title="创建对象的过程"></a>创建对象的过程</h3><ol>
<li>代码：<code>var p = new Person();</code></li>
<li>首先运算符<code>new</code>创建了一个对象，类似于<code>{}</code>，是一个没有任何（自定义）成员的对象。<ul>
<li>使用<code>new</code> 创建对象，那么对象的类型就是创建他的构造函数名</li>
<li>使用<code>{}</code>无论如何都是Object类型，相当于<code>new Object</code></li>
</ul>
</li>
<li>然后调用构造函数，为其初始化成员<ul>
<li>构造函数在调用的一开始，有一个赋值操作，即this = 刚刚创建出来的对象。</li>
<li>因此在构造函数中this表示刚刚创建出来的对象。</li>
</ul>
</li>
<li>在构造函数中 利用 对象的动态特性 为其对象添加成员。</li>
</ol>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h3><p>域表示的就是范围，即作用域，就是一个名字在什么地方可以使用，什么时候不能使用。</p>
<h3 id="JS中词法作用域的规则"><a href="#JS中词法作用域的规则" class="headerlink" title="JS中词法作用域的规则"></a>JS中词法作用域的规则</h3><ol>
<li>函数允许访问函数外部的数据</li>
<li>整个代码结构中只有函数可以限定作用域</li>
<li>作用规则首先使用提升规则分析</li>
<li>如果当前作用域中有了名字了，就不考虑外面的名字</li>
</ol>
<h3 id="属性搜索原则"><a href="#属性搜索原则" class="headerlink" title="属性搜索原则"></a>属性搜索原则</h3><ul>
<li>所谓的属性搜索原则，就是对象在访问属性或方法的时候，首先在当前对象中查找</li>
<li>如果当前对象中存储着属性或方法，停止查找，直接使用该属性或方法</li>
<li>如果当前对象没有该成员，那么再在其原型对象中查找</li>
<li>如果原型对象中含有该成员，那么停止查找，直接使用</li>
<li>如果原型中还没有，就到原型的原型中查找</li>
<li>如此往复，直到Object.protitype还没有，那么就返回undefined</li>
<li>如果是调用方法就报错，该xxx不是一个函数</li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h3><p><strong>什么是闭包？</strong><br>闭包的含义就是闭合，包起来，简单的来说，就是一个具有封闭功能与包裹功能的结构。所谓的闭包就是一个具有封闭的对外不公开的，包裹结构，或空间。</p>
<p><strong>为什么函数可以构成闭包？</strong><br>闭包就是一个具有封闭与包裹功能的结构，是为了实现具有私有访问空间的函数的。函数可以构成闭包。函数内部定义的数据函数外部无法访问，即函数具有封闭性；函数可以封装代码即具有包裹性，所以函数可以构成闭包。</p>
<h3 id="闭包有什么用"><a href="#闭包有什么用" class="headerlink" title="闭包有什么用"></a>闭包有什么用</h3><p>闭包不允许外部访问，要解决的问题就是让外部间接访问函数内部的数据。事实上，通过使用闭包，我们可以做很多事情。比如模拟面向对象的代码风格；更优雅，更简洁的表达出代码；在某些方面提升代码的执行效率。利用闭包可以实现如下需求：</p>
<ol>
<li>匿名自执行函数<br>一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在执行完后很快就会被释放，关键是这种机制不会污染全局对象。</li>
<li>缓存<br>闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。</li>
<li>实现封装</li>
<li>模拟面向对象的代码风格</li>
</ol>
<h3 id="闭包的基本模型"><a href="#闭包的基本模型" class="headerlink" title="闭包的基本模型"></a>闭包的基本模型</h3><ol>
<li>对象模式<br>函数内部定义个一个对象，对象中绑定多个函数（方法），返回对象，利用对象的方法访问函数内的数据</li>
<li>函数模式<br>函数内部定义一个新函数，返回新函数，用新函数获得函数内的数据</li>
<li>沙箱模式<br>沙箱模式就是一个自调用函数，代码写到函数中一样会执行，但是不会与外界有任何的影响</li>
</ol>
<h3 id="闭包的作用举例"><a href="#闭包的作用举例" class="headerlink" title="闭包的作用举例"></a>闭包的作用举例</h3><ol>
<li>获得超过一个数据，返回一个对象</li>
<li>完成读取一个数据和修改这个数据，对象里面的get\set方法</li>
</ol>
<h3 id="闭包的性能问题"><a href="#闭包的性能问题" class="headerlink" title="闭包的性能问题"></a>闭包的性能问题</h3><p>函数执行需要内存，那么函数中定义的变量，会在函数执行结束后自动回收，凡是因为闭包结构的，被引出的数据，如果还有变量引用这些数据的话，那么这些数据就不会被回收。因此在使用闭包的时候如果不使用某些数据了，一定要赋值一个null<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> num = <span class="number">123</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> num;</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div><div class="line"><span class="comment">// f 引用着函数，函数引用着变量num</span></div><div class="line"><span class="comment">// 因此在不使用该数据的时候，最好写上</span></div><div class="line">f = <span class="literal">null</span>;</div></pre></td></tr></table></figure></p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="什么是原型"><a href="#什么是原型" class="headerlink" title="什么是原型"></a>什么是原型</h3><p>一句话说明什么是原型：原型能存储我们的方法，构造函数创建出来的实例对象能够引用原型中的方法。</p>
<p>JS中一切皆对象，而每个对象都有一个原型（Object除外），这个原型，大概就像Java中的父类，所以，基本上你可以认为原型就是这个对象的父对象，即每一个对象（Object除外）内部都保存了它自己的父对象，这个父对象就是原型。一般创建的对象如果没有特别指定原型，那么它的原型就是Object(这就很类似Java中所有的类默认继承自Object类)。</p>
<p>ES6通过引入class ,extends等关键字，以一种语法糖的形式把构造函数包装成类的概念，更便于大家理解。是希望开发者不再花精力去关注原型以及原型链，也充分说明原型的设计意图和类是一样的。</p>
<h3 id="查看对象的原型"><a href="#查看对象的原型" class="headerlink" title="查看对象的原型"></a>查看对象的原型</h3><p>当对象被创建之后，查看它们的原型的方法不止一种，以前一般使用对象的<code>__proto__</code>属性，ES6推出后，推荐用<code>Object.getPrototypeOf()</code>方法来获取对象的原型<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name=<span class="string">'lala'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a=<span class="keyword">new</span> A();</div><div class="line"><span class="built_in">console</span>.log(a.__proto__) </div><div class="line"><span class="comment">//输出：Object &#123;&#125;</span></div><div class="line"> </div><div class="line"><span class="comment">//推荐使用这种方式获取对象的原型</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(a)) </div><div class="line"><span class="comment">//输出：Object &#123;&#125;</span></div></pre></td></tr></table></figure></p>
<p>无论对象是如何创建的，默认原型都是Object，在这里需要提及的比较特殊的一点就是，通过构造函数来创建对象，函数A本身也是一个对象，而A有两个指向表示原型的属性，分别是proto和prototype，而且两个属性并不相同<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name=<span class="string">'lala'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a=<span class="keyword">new</span> A();</div><div class="line"><span class="built_in">console</span>.log(A.prototype) </div><div class="line"><span class="comment">//输出：Object &#123;&#125;</span></div><div class="line"> </div><div class="line"><span class="built_in">console</span>.log(A.__proto__) </div><div class="line"><span class="comment">//输出：function () &#123;&#125;</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(A))</div><div class="line"><span class="comment">//输出：function () &#123;&#125;</span></div></pre></td></tr></table></figure></p>
<p>函数的的prototype属性只有在当作构造函数创建的时候，把自身的prototype属性值赋给对象的原型。而实际上，作为函数本身，它的原型应该是function对象，然后function对象的原型才是Object。</p>
<p><strong>总之，建议使用ES6推荐的查看原型和设置原型的方法。</strong></p>
<h3 id="原型的用法"><a href="#原型的用法" class="headerlink" title="原型的用法"></a>原型的用法</h3><p>其实原型和类的继承的用法是一致的：当你想用某个对象的属性时，将当前对象的原型指向该对象，你就拥有了该对象的使用权了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name=<span class="string">'world '</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.bb=<span class="string">"hello"</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a=<span class="keyword">new</span> A();</div><div class="line"><span class="keyword">var</span> b=<span class="keyword">new</span> B();</div><div class="line"></div><div class="line"><span class="comment">//将b设置为a的原型,此处有一个问题，即a的constructor也指向了B构造函数，可能需要纠正 </span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(a,b);</div><div class="line">a.constructor=A;</div><div class="line"><span class="built_in">console</span>.log(a.bb);    <span class="comment">//hello</span></div></pre></td></tr></table></figure></p>
<p>如果使用ES6来做的话则简单许多，甚至不涉及到prototype这个属性<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</div><div class="line">     <span class="keyword">constructor</span>()&#123;</div><div class="line">         <span class="keyword">this</span>.bb=<span class="string">'hello'</span></div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>  <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</div><div class="line">     <span class="keyword">constructor</span>()&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.name=<span class="string">'world'</span>;</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> a=<span class="keyword">new</span> A();</div><div class="line"><span class="built_in">console</span>.log(a.bb+<span class="string">" "</span>+a.name);    <span class="comment">//hello world</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(A))                <span class="comment">//"function"</span></div></pre></td></tr></table></figure></p>
<p>怎么样？是不是已经完全看不到原型的影子了？活脱脱就是类继承，但是你也看得到实际上类A 的类型是function，所以说，本质上class在JS中是一种语法糖，JS继承的本质依然是原型，不过，ES6引入class，extends 来掩盖原型的概念也是一个很友好的举动，对于长期学习那些类继承为基础的面对对象编程语言的程序员而言。</p>
<p>我的建议是，尽可能理解原型，尽可能用class这种语法糖。</p>
<p>好了，问自己两个问题：</p>
<ol>
<li>为什么要使用原型？——提高函数的复用性。</li>
<li>为什么属性不放在原型上而方法要放在原型上？<ul>
<li>利用对象的动态特性：<code>构造函数.prototype.xxxx = vvv</code></li>
<li>利用直接替换<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Student.prototype = &#123;</div><div class="line">    <span class="attr">sayHello</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</div><div class="line">    <span class="attr">study</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p><strong>什么是原型链？</strong><br>凡是对象就有原型，那么原型又是对象，因此凡是给定一个对象，那么就可以找到他的原型，原型还有原型，那么如此下去，就构成一个对象的序列，称该结构为原型链。</p>
<p>这个概念其实也变得比较简单，可以类比类的继承链条，即每个对象的原型往上追溯，一直到Object为止，这组成了一个链条，将其中的对象串联起来，当查找当前对象的属性时，如果没找到，就会沿着这个链条去查找，一直到Object，如果还没发现，就会报undefined。</p>
<p><strong>原型链的结构</strong><br>凡是使用构造函数，创建出对象，并且没有利用赋值的方式修改原型，就说该对象保留默认的原型链。<br>默认原型链结构是什么样子呢？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div><div class="line"><span class="comment">//p 具有默认的原型链</span></div></pre></td></tr></table></figure></p>
<p>默认的原型链结构就是：<code>当前对象 -&gt; 构造函数.prototype -&gt; Object.prototype -&gt; null</code></p>
<p>在实现继承的时候，有时候会利用替换原型链结构的方式实现原型继承，那么原型链结构就会发生改变<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">DunizbCollection</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">DunizbCollection.prototype = [];</div><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> DunizbCollection();</div></pre></td></tr></table></figure></p>
<p>此时arr对象的原型链结构被指向了数组对象的原型链结构了：<code>arr -&gt; [] -&gt; Array.prototype -&gt; Object.prototype -&gt; null</code></p>
<p><strong>用图形表示对象的原型链结构</strong><br>以如下代码为例绘制原型链结构<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure></p>
<p>原型链结构图为：<br><img src="http://img.mukewang.com/580365b70001795f06520439.jpg" alt="图片描述"></p>
<p>使用原型需要注意两点：</p>
<ol>
<li>原型继承链条不要太长，否则会出现效率问题。</li>
<li>指定原型时，注意constructor也会改变。</li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>实现继承有两种常见方式：</p>
<ol>
<li><p><strong>混合式继承</strong>：最简单的继承就是将别的对象的属性强加到我身上，那么我就有这个成员了。<br>混合式继承的简单描述：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">Person.prototype.extend = <span class="function"><span class="keyword">function</span> (<span class="params"> o </span>) </span>&#123;</div><div class="line">     <span class="keyword">for</span> ( <span class="keyword">var</span> k <span class="keyword">in</span> o ) &#123;</div><div class="line">          <span class="keyword">this</span>[ k ] = o[ k ];</div><div class="line">     &#125;</div><div class="line">&#125;;</div><div class="line">Person.prototype.extend(&#123;</div><div class="line">      <span class="attr">run</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">'我能跑了'</span> ); &#125;,</div><div class="line">      <span class="attr">eat</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">'我可以吃了'</span> ); &#125;,</div><div class="line">      <span class="attr">sayHello</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">'我吃饱了'</span> ); &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p><strong>原型继承</strong>：利用原型也可以实现继承，不需要在我身上添加任何成员，只要原型有了我就有了。</p>
</li>
<li><strong>借用构造函数继承</strong><br>这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数，而函数只不过是在特定环境中执行代码的对象，因此通过使用<code>apply()</code>和<code>call()</code>方法也可以在（将来）新创建的对象上执行构造函数<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"> name, age, gender </span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">        <span class="keyword">this</span>.gender = gender;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 需要提供一个 Student 的构造函数创建学生对象</span></div><div class="line"><span class="comment">// 学生也应该有 name, age, gender, 同时还需要有 course 课程</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params"> name, age, gender, course </span>) </span>&#123;</div><div class="line">        Person.call( <span class="keyword">this</span>, name, age, gender )；</div><div class="line">        <span class="keyword">this</span>.course = course;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在《JavaScript高级程序设计（第三版）》中详细介绍了继承的6种方式</p>
<h2 id="函数的四种调用模式"><a href="#函数的四种调用模式" class="headerlink" title="函数的四种调用模式"></a>函数的四种调用模式</h2><h3 id="函数模式"><a href="#函数模式" class="headerlink" title="函数模式"></a>函数模式</h3><p>就是一个简单的函数调用。函数名的前面没有任何引导内容。</p>
<h3 id="方法模式"><a href="#方法模式" class="headerlink" title="方法模式"></a>方法模式</h3><p>方法一定式依附与一个对象，将函数赋值给对象的一个属性，那么就成为了方法。</p>
<h3 id="构造器调用模式"><a href="#构造器调用模式" class="headerlink" title="构造器调用模式"></a>构造器调用模式</h3><p>创建对象的时候构造函数做了什么？由于构造函数只是给 this 添加成员，没有做其他事情。而方法也可以完成这个操作，就是 this 而言，构造函数与方法没有本质的区别。</p>
<p><strong>特征</strong></p>
<ol>
<li>使用 new 关键字，来引导构造函数。</li>
<li>构造函数中的 this 与方法中的一样，表示对象，但是构造函数中的对象是刚刚创建出来的对象</li>
<li>构造函数中不需要 return ，就会默认的 return this。<ul>
<li>如果手动添加return ，就相当于 return this</li>
<li>如果手动的添加 return 基本类型，无效，还是保留原来 返回 this</li>
<li>如果手动添加的 return null，或 return undefined ，无效</li>
<li>如果手动添加 return 对象类型，那么原来创建的 this 就会被丢掉，返回的是 return 后面的对象</li>
</ul>
</li>
</ol>
<p><strong>创建对象的模式</strong></p>
<ol>
<li>工厂方法，工厂就是用来生产的，因此如果函数创建对象并返回，就称该函数为工厂函数</li>
<li>构造方法</li>
<li>寄生式创建</li>
<li>混合式创建</li>
</ol>
<h3 id="上下文调用模式"><a href="#上下文调用模式" class="headerlink" title="上下文调用模式"></a>上下文调用模式</h3><p>上下文就是环境。就是自己定义设置 this 的含义。</p>
<p><strong>语法</strong></p>
<ol>
<li>函数名.apply( 对象, [ 参数 ] );</li>
<li>函数名.call( 对象, 参数 );</li>
</ol>
<p><strong>描述</strong></p>
<ol>
<li>函数名就是表示函数本身，使用函数进行调用的时候默认 this 是全局变量</li>
<li>函数名也可以是方法提供，使用方法调用的时候，this 是指向当前对象</li>
<li>使用 apply 进行调用后，无论是函数还是方法都无效了，我们的 this ，由 apply 的第一个参数决定</li>
</ol>
<p><strong>参数问题</strong><br>无论是 call 还是 apply 在没有后面的参数的情况下（函数无参数，方法五参数）是完全一致的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span> );</div><div class="line">&#125;</div><div class="line">foo.apply( obj );</div><div class="line">foo.call( obj );</div></pre></td></tr></table></figure></p>
<p>第一个参数的使用也是有规则的:</p>
<ol>
<li>如果传入的是一个对象，那么就相当于设置该函数中的 this 为参数</li>
<li><p>如果不传入参数，或传入 null 、undefined 等，那么相当于 this 默认为 window</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">foo();</div><div class="line">foo.apply();</div><div class="line">foo.apply( <span class="literal">null</span> );</div><div class="line">foo.call( <span class="literal">undefined</span> );</div></pre></td></tr></table></figure>
</li>
<li><p>如果传入的是基本类型，那么 this 就是基本类型对应的包装类型的引用</p>
</li>
</ol>
<p>在使用上下文调用的时候，原函数（方法）可能会带有参数，那么这个参数再上下文调用中使用 第二个（第 n 个）参数来表示<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"> num </span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( num );</div><div class="line">&#125;</div><div class="line">foo.apply( <span class="literal">null</span>, [ <span class="number">123</span> ] );</div><div class="line"><span class="comment">// 等价于</span></div><div class="line">foo( <span class="number">123</span> );</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>参考资料</strong></p>
<ul>
<li>本文原型部分部分引用自<a href="http://www.admin10000.com/document/9336.html" target="_blank" rel="external">《JavaScript原型详解》</a>，版权归原作者所有</li>
<li><a href="http://blog.csdn.net/sunlylorn/article/details/6534610" target="_blank" rel="external">js闭包的用途</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[零碎笔记：移动Web特别样式处理]]></title>
      <url>/2016/10/10/%E9%9B%B6%E7%A2%8E%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%A7%BB%E5%8A%A8Web%E7%89%B9%E5%88%AB%E6%A0%B7%E5%BC%8F%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/68937-49a43d786521310a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="零碎笔记：移动Web特别样式处理"></p>
<h2 id="高清图片问题"><a href="#高清图片问题" class="headerlink" title="高清图片问题"></a>高清图片问题</h2><p>高清图片跟我们平时下的那种电影高清图片是不一样的，移动Web的高清图片的概念是我这张图这么大，清晰度这么多，那么我们在移动设备上就该展示这么清晰。那么为什么会产生模糊呢？假如一张图片 <code>100px * 100px</code> 那我们在移动设备上就以 <code>100px * 100px</code> 去展示，这想想也是没有问题的。</p>
<p>但我们想想，在Retina屏幕，一个px等于两个dp，那你拿 <code>100px*100px</code> 实际上是拿了 <code>200dp * 200dp</code> 物理像素去渲染，图片就会被拉大被模糊。</p>
<p>在移动Web页面上渲染图片，为了避免图片产生模糊，图片的宽高应该用物理像素单位渲染，即是 <code>100 * 100</code> 的图片，应该使用 <code>100dp * 100dp。</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">width:(w_value/dpr) px;</div><div class="line">height:(h_value/dpr) px;</div></pre></td></tr></table></figure>
<p>那说白了，在高清屏幕下，假如100<em>100的图片，那么我们就应该使用50</em>50的px去渲染，那如果在iPhone6 Plus下这时候dpr大于2的话，那我们就应该除以它的dpr(3)这样的方式。</p>
<h2 id="一像素边框"><a href="#一像素边框" class="headerlink" title="一像素边框"></a>一像素边框</h2><p>一像素的边框的问题其实最根本的问题还是Retina屏幕的问题，那我们设置了border:1px，那1px就等于2个dp，那它实际上这个1像素边框拿了2个dp来渲染，所以那条线就不是很细，如果我们拿1dp来渲染的话就会更加精致更加细腻。</p>
<p>那怎么解决呢？</p>
<p>如果把border:0.5px可以不可以呢？答案是不可以的，因为它仅仅是ios8可以用。</p>
<p>实际上更通用的方案是使用sacleY(0.5)来进行缩放处理：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.sidbar</span> <span class="selector-class">.folder</span> <span class="selector-tag">li</span>&#123;</div><div class="line">    <span class="attribute">padding</span>:<span class="number">8px</span> <span class="number">0</span> <span class="number">8px</span> <span class="number">15px</span>;</div><div class="line">    <span class="attribute">color</span>:<span class="number">#7c7c7c</span>;</div><div class="line">    <span class="attribute">cursor</span>:pointer;</div><div class="line">    <span class="attribute">position</span>:relative;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.folder</span> <span class="selector-tag">li</span> + <span class="selector-tag">li</span><span class="selector-pseudo">:before</span>&#123;</div><div class="line">    <span class="attribute">position</span>:absolute;</div><div class="line">    <span class="attribute">top</span>:-<span class="number">1px</span>;</div><div class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</div><div class="line">    <span class="attribute">content</span>:<span class="string">''</span>,</div><div class="line">    width:<span class="number">100%</span>;</div><div class="line">    <span class="attribute">height</span>:<span class="number">1px</span>;</div><div class="line">    <span class="attribute">border-top</span>:<span class="number">1px</span> solid <span class="number">#ddd</span>;</div><div class="line">    <span class="attribute">-webkit-transform</span>:<span class="built_in">scaleY</span>(0.5);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，网上还有其他方案可以选择。</p>
<h2 id="相对单位rem"><a href="#相对单位rem" class="headerlink" title="相对单位rem"></a>相对单位rem</h2><p>为了适应各大屏幕的手机，px略显固定，不能根据尺寸的大小而改变，使用相对单位更能体验页面的兼容性。相对单位有两个：</p>
<ul>
<li>em：是根据父节点的font-size为相对单位</li>
<li>rem：是根据html的font-size为相对单位</li>
</ul>
<p>em在多层嵌套下，变得非常难以使用和维护了，rem更加能作为全局同意设置的度量，我们推荐使用rem。</p>
<p>rem的基值设置多少好？回归我们的目的：为了适应各大手机屏幕，我们可以这样： rem = screen.width / 20 ，或者除以10等。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 默认320px</div><div class="line">html&#123; font-size: 32px; &#125;</div><div class="line">// iphone6</div><div class="line">@media (min-device-wdith : 375px) &#123;</div><div class="line">    html&#123;font-size: 37.5px;&#125;</div><div class="line">&#125;</div><div class="line">// ihpone6 plus</div><div class="line">@media (min-device-width : 414px) &#123;</div><div class="line">    html&#123;font-size: 41.4px;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如iphone5上的rem基值为32px，渲染一张64<em>64px的div，则用2rem</em>2rem去渲染。换算公式非常简单：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">width: px/rem基值</div><div class="line">height: px/rem基值</div></pre></td></tr></table></figure></p>
<h2 id="不使用rem的情况：font-size"><a href="#不使用rem的情况：font-size" class="headerlink" title="不使用rem的情况：font-size"></a>不使用rem的情况：font-size</h2><p>一般来讲font-size是并不应该使用rem等相对单位的。因为字体的大小是趋于阅读的实用性，并不适合与排版布局。</p>
<p>同理，趋向于一些固定的元素的特性。我们不使用rem而改为使用px去确保在不同的屏幕上表现一致（跟rem的目的相反）。</p>
<h2 id="多行文本溢出…"><a href="#多行文本溢出…" class="headerlink" title="多行文本溢出…"></a>多行文本溢出…</h2><p><img src="http://img.mukewang.com/57fa57ac000171eb02870090.jpg" alt="图片描述"><br>单行文本溢出，对title类的使用非常多，而多行文本类，在详情介绍则用的比较多。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*单行文本溢出*/</span></div><div class="line"><span class="selector-class">.inaline</span>&#123;</div><div class="line">      <span class="attribute">overflow</span>: hidden;</div><div class="line">      <span class="attribute">white-space</span>: nowrap;</div><div class="line">      <span class="attribute">text-overflow</span>: ellipsis;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*多行文本溢出*/</span></div><div class="line"><span class="selector-class">.intwoline</span>&#123;</div><div class="line">      <span class="attribute">display</span>: -webkit-box <span class="meta">!important</span>;</div><div class="line">      <span class="attribute">overflow</span>: hidden;</div><div class="line">      <span class="attribute">text-overflow</span>: ellipsis;</div><div class="line">      <span class="attribute">word-break</span>: break-all;</div><div class="line">      <span class="attribute">-webkit-box-orient</span>:vertical;</div><div class="line">      <span class="attribute">-webkit-line-clamp</span>:<span class="number">4</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>属性-webkit-line-clamp就可以控制几行溢出，4就是第四行进行截断加“…”</p>
<hr>
<p><strong>参考资料：</strong><br><a href="http://www.imooc.com/learn/494" target="_blank" rel="external">Hello，移动Web</a></p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
            <category> 移动Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[零碎笔记：浏览器访问一个网站所经历的步骤]]></title>
      <url>/2016/10/08/%E9%9B%B6%E7%A2%8E%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99%E6%89%80%E7%BB%8F%E5%8E%86%E7%9A%84%E6%AD%A5%E9%AA%A4/</url>
      <content type="html"><![CDATA[<h2 id="浏览器访问一个网站所经历的步骤"><a href="#浏览器访问一个网站所经历的步骤" class="headerlink" title="浏览器访问一个网站所经历的步骤"></a>浏览器访问一个网站所经历的步骤</h2><ol>
<li>Chrome搜索自身的DNS缓存</li>
<li><p>搜索操作系统自身的DNS缓存（浏览器没有找到缓存或缓存已经失效）<br>查看Chrome浏览器的DNS缓存信息(chrome://net-internals/#dns)：<br><img src="http://upload-images.jianshu.io/upload_images/68937-2717abdc8d91ee0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6ebdf4a6-b6d0-4a0f-ab98-84c394cce9d9.png"></p>
</li>
<li><p>读取本地HOST文件</p>
</li>
<li>浏览器发起一个DNS的一个系统调用<ul>
<li>宽带运营商服务器查看本身缓存</li>
<li>运营商服务器发起一个迭代DNS解析的请求<ul>
<li>运营商服务器把结果返回操作系统内核同时缓存起来</li>
<li>操作系统内核把结果返回浏览器</li>
<li>最终浏览器拿到www.jianshu.com对应的IP地址</li>
</ul>
</li>
</ul>
</li>
<li>浏览器获得域名对应的IP地址后，发起HTTP“三次握手”</li>
<li>TCP/IP连接建立起来后，浏览器就可以向服务器发送HTTP请求了。（使用了比如说，用HTTP的GET方法请求一个跟域名，协议可以采用HTTP1.0。）</li>
<li>服务器端接受到了这个请求，根据路径参数，经过后端的一些处理之后，把处理后的一个结果的数据返回给浏览器。如果是慕课网的页面就会把完整的HTML页面代码返回给浏览器。</li>
<li>浏览器拿到了简书网的完整的HTML页面代码，在解析和渲染这个页面的时候，里面的JS、CSS、图片静态资源，他们同样也是一个个HTTP请求都需要经过上面的主要的七个步骤。</li>
<li>浏览器根据拿到的资源对页面进行渲染，最终把一个完整的页面呈现给了用户。</li>
</ol>
<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><h3 id="1-什么是回调？"><a href="#1-什么是回调？" class="headerlink" title="1. 什么是回调？"></a>1. 什么是回调？</h3><p>回调是异步编程时的基础，将后续逻辑封装成起始函数的参数，逐层嵌套</p>
<h3 id="2-什么是同步-异步？"><a href="#2-什么是同步-异步？" class="headerlink" title="2. 什么是同步/异步？"></a>2. 什么是同步/异步？</h3><p>同步是指：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。<br>异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。 </p>
<h3 id="3-什么是I-O？"><a href="#3-什么是I-O？" class="headerlink" title="3. 什么是I/O？"></a>3. 什么是I/O？</h3><p>磁盘的写入（in）磁盘的读取（out）</p>
<h3 id="4-什么的单线程-多线程？"><a href="#4-什么的单线程-多线程？" class="headerlink" title="4. 什么的单线程/多线程？"></a>4. 什么的单线程/多线程？</h3><p>一次只能执行一个程序叫做单线程<br>一次能执行多个程序叫多线程</p>
<h3 id="5-什么是阻塞-非阻塞？"><a href="#5-什么是阻塞-非阻塞？" class="headerlink" title="5. 什么是阻塞/非阻塞？"></a>5. 什么是阻塞/非阻塞？</h3><p>阻塞：前一个程序未执行完就得一直等待<br>非阻塞：前一个程序未执行完时可以挂起，继续执行其他程序，等到使用时再执行</p>
<h3 id="6-什么是事件？"><a href="#6-什么是事件？" class="headerlink" title="6. 什么是事件？"></a>6. 什么是事件？</h3><p>一个触发动作（例如点击按钮）</p>
<h3 id="7-什么是事件驱动？"><a href="#7-什么是事件驱动？" class="headerlink" title="7. 什么是事件驱动？"></a>7. 什么是事件驱动？</h3><p>一个触发动作引起的操作（例如点击按钮后弹出一个对话框）</p>
<h3 id="8-什么是基于事件驱动的回调？"><a href="#8-什么是基于事件驱动的回调？" class="headerlink" title="8. 什么是基于事件驱动的回调？"></a>8. 什么是基于事件驱动的回调？</h3><p>为了某个事件注册了回调函数，但是这个回调函数不是马上执行，只有当事件发生的时候，才会调用回调函数，这种函数执行的方式叫做事件驱动~这种注册回调就是基于事件驱动的回调，如果这些回调和异步I/O(数据写入、读取)操作有关，可以看作是基于回调的异步I/O，只不过这种回调在nodejs中是有事件来驱动的</p>
<h3 id="9-什么是事件循环？"><a href="#9-什么是事件循环？" class="headerlink" title="9. 什么是事件循环？"></a>9. 什么是事件循环？</h3><p>事件循环Eventloop,倘若有大量的异步操作，一些I/O的耗时操作，甚至是一些定时器控制的延时操作，它们完成的时候都要调用相应的回调函数，从而来完成一些密集的任务，而又不会阻塞整个程序执行的流程，此时需要一种机制来管理，这种机制叫做事件循环.<br>总而言之就是：管理大量异步操作的机制叫做事件循环</p>
<p>Event Loop:<br>回调函数队列。异步执行的函数会被压入这个队列; 队列被循环查询。</p>
<hr>
<p><strong>参考资料：</strong><br><a href="http://www.imooc.com/view/348" target="_blank" rel="external">慕课网《进击NodeJS基础（一）》</a></p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 小知识 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[剖析简易计算器带你入门微信小程序开发]]></title>
      <url>/2016/10/06/%E5%89%96%E6%9E%90%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</url>
      <content type="html"><![CDATA[<h2 id="写在前面，但是重点在后面"><a href="#写在前面，但是重点在后面" class="headerlink" title="写在前面，但是重点在后面"></a>写在前面，但是重点在后面</h2><p>这是教程，也不是教程。</p>
<p>可以先看Demo的操作动图，看看是个什么玩意儿，<a href="https://github.com/dunizb/wxapp-sCalc" target="_blank" rel="external">GitHub地址（https://github.com/dunizb/wxapp-sCalc）</a><br><img src="http://img.mukewang.com/57efda8900019bef00410570.gif" alt="图片描述"></p>
<p>自从微信小程序内测以来，我的网络信息几乎被它刷屏，一瞬间，都不知道发生了什么。特别是当晚有人熬夜吐血出教程，我勒个去，这么拼，感觉不立马学习等会儿就会被别人踩死在这个行业。惶恐惶恐的过来几天，等到了国庆终于也可以跟风熬夜研究了。</p>
<p>好吧，来吧，所以说菜鸟只会写计算器。。。。嗯，是的，我想不出什么好创意。下面介绍一下这个简易计算器，以及开发过程中踩的一些坑吧。</p>
<p>首先，什么Web开发者工具之类的、文档之类的，网上多的是，我就不重复了，已经不需要什么破解了，微信官方已经修改验证机制，没有APPID也能玩了，只不过部分功能受限。</p>
<p>其次，微信小程序开发其实不难，在没掌握之前我也是不明觉厉，看似高大上。其实他相对我们传统的写法更简单，高度封装了，按照他们的规则和规范来，写起来体验还是很不错的。</p>
<p>但因为没有权限，目前的微信小程序都是在开发者工具的模拟器中运行的，不知道在微信上真实情况如何。</p>
<h2 id="xxx-wxml文件和xxx-wxss文件"><a href="#xxx-wxml文件和xxx-wxss文件" class="headerlink" title="xxx.wxml文件和xxx.wxss文件"></a>xxx.wxml文件和xxx.wxss文件</h2><p>wxml是微信自己开发的一套标记语言，你可以直接看做是HTML文件也没问题，因为我们的界面构建都是在这个文件里编写，只是没有HTML标签了，只有wxml标签了，而wxml标签数量也是很少的。<br><img src="http://img.mukewang.com/57efd975000101ee11100482.png" alt="图片描述"><br>wxss是微信自己开发的一套样式文件格式，等同于我们的CSS文件，写法也是一样的，只是换了个文件后缀，以前我们怎么写CSS的在微信小程序中我们依然怎么写。<br><img src="http://img.mukewang.com/57efd97e00016c8609480490.png" alt="图片描述"></p>
<p>wxml加上wxss我们就可以构建出我们想要的界面UI了。</p>
<h2 id="xxx-js和xxx-json文件"><a href="#xxx-js和xxx-json文件" class="headerlink" title="xxx.js和xxx.json文件"></a>xxx.js和xxx.json文件</h2><p>xxx.js文件就是写JS的地方，每个xxx.js对应一个同名的xxx.wxml文件，xxx.js文件必须有Page对象，哪怕该页面没有任何业务逻辑。输入Page微信Web开发者工具会自动生成一些列空方法待你实现，当然你可以不实现，只是把你把骨架搭好而已。<br><img src="http://img.mukewang.com/57efd9880001a92609540582.png" alt="图片描述"></p>
<p>xxx.josn文件就是配置文件，一般是全局配置才用，比如根目录的<code>app.josn</code>，定义了小程序由哪些页面构成，小程序导航Bar样式等，属性看名字就知道什么意思了。<br><img src="http://img.mukewang.com/57efd9910001298408830465.png" alt="图片描述"></p>
<p><code>pages</code>属性配置的是页面，第一个就是启动页，所有页面都必须在这里配置，如果你建了一个页面忘记在这里添加了，那么你会很郁闷的，应为到时候页面跳转的时候<code>onLoad</code>方法不会执行，我就被这个浪费好多时间抓耳饶腮好奇不断。</p>
<h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>看看下面的项目结构图，一个页面是一个文件夹，一个面通常都有js、wxml、wxss，wxml和js文件是必须的，可以有没有样式。<br><img src="http://img.mukewang.com/57efd9990001919d03620738.png" alt="图片描述"></p>
<p>calc（计算器页面）、history（历史记录）、index（小程序首页、启动页）、logs（日志信息）、utils（js工具类）,logs和utils是自带的，可以有可以没有。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>这个简易计算器界面布局依然延续祖制，采用CSS Flexbox布局，貌似微信官方也是这么推荐的（官方文档中就是使用Flexbox）。</p>
<p>计算器的按键，都是用<code>&lt;text&gt;</code>标签来做的，加上wxss样式即可，当然也可以直接用button组件。</p>
<p>wxml:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"btnGroup"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"item blue"</span> <span class="attr">bindtap</span>=<span class="string">"clickBtn"</span> <span class="attr">id</span>=<span class="string">"&#123;&#123;id9&#125;&#125;"</span>&gt;</span>9<span class="tag">&lt;/<span class="name">view</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"item blue"</span> <span class="attr">bindtap</span>=<span class="string">"clickBtn"</span> <span class="attr">id</span>=<span class="string">"&#123;&#123;id8&#125;&#125;"</span>&gt;</span>8<span class="tag">&lt;/<span class="name">view</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"item blue"</span> <span class="attr">bindtap</span>=<span class="string">"clickBtn"</span> <span class="attr">id</span>=<span class="string">"&#123;&#123;id7&#125;&#125;"</span>&gt;</span>7<span class="tag">&lt;/<span class="name">view</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"item orange"</span> <span class="attr">bindtap</span>=<span class="string">"clickBtn"</span> <span class="attr">id</span>=<span class="string">"&#123;&#123;idj&#125;&#125;"</span>&gt;</span>－<span class="tag">&lt;/<span class="name">view</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这里<code>bindtap</code>，看名字就知道是用来绑定事件的，跟我们在HTML中使用<code>onclick</code>一个道理。<code>id=</code> 双大括号中的值来自js文件中data属性定义的同名属性<br><img src="http://img.mukewang.com/57efd9a300015be305390311.png" alt="图片描述"></p>
<p>wxss:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.btnGroup</span> &#123;</div><div class="line">    <span class="attribute">display</span>: flex;</div><div class="line">    <span class="attribute">flex-direction</span>: row;</div><div class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.item</span> &#123;</div><div class="line">    <span class="attribute">width</span>:<span class="number">25%</span>;</div><div class="line">    <span class="attribute">display</span>: flex;</div><div class="line">    <span class="attribute">align-items</span>: center;</div><div class="line">    <span class="attribute">flex-direction</span>: column;</div><div class="line">    <span class="attribute">justify-content</span>: center;</div><div class="line">    <span class="attribute">margin-top</span>: <span class="number">1px</span>;</div><div class="line">    <span class="attribute">margin-right</span>: <span class="number">1px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.item</span><span class="selector-pseudo">:active</span> &#123;</div><div class="line">    <span class="attribute">background-color</span>: <span class="number">#ff0000</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>css就没什么好说的了，唯一需要注意的是微信提供了一个尺寸单位<code>rpx</code>，responsive pixel ，可以根据屏幕宽度进行自适应，<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxss.html" target="_blank" rel="external">官网文档有详细解析</a>。我在计算器的history页面也有使用：<br><img src="http://img.mukewang.com/57efd9ab0001570f06250434.png" alt="图片描述"></p>
<h3 id="主要涉及组件"><a href="#主要涉及组件" class="headerlink" title="主要涉及组件"></a>主要涉及组件</h3><ul>
<li>view、text，大部分页面都是它俩哥们。</li>
<li><p>按钮（button），index页面的按钮“简易计算器”<br><img src="http://img.mukewang.com/57efd9b40001296c11970327.png" alt="图片描述"></p>
</li>
<li><p>图标（icon）,计算机的历史记录安静使用的就是icon自带的图标之一。<br><img src="http://img.mukewang.com/57efd9bb00015a6307580197.png" alt="图片描述"></p>
</li>
<li><p>标记方式调整页面（navigator）<br><img src="http://img.mukewang.com/57efd9c20001e3ca09360230.png" alt="图片描述"></p>
</li>
<li><p>图片（Image），首页头像<br><img src="http://img.mukewang.com/57efd9ca00017eaf09070261.png" alt="图片描述"></p>
</li>
<li><p>for循环，历史记录显示页面用到了，得从Storage中读取数据展示，而Storage中保存就是一个数组</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;logs&#125;&#125;"</span> <span class="attr">wx:for-item</span>=<span class="string">"log"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>&#123;&#123;log&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="主要涉及API"><a href="#主要涉及API" class="headerlink" title="主要涉及API"></a>主要涉及API</h3><ul>
<li><p>wx.navigateTo，导航，跳转，在当前页面打开新页面<br><img src="http://img.mukewang.com/57efd9d1000184fd08110253.png" alt="图片描述"></p>
</li>
<li><p>Storage，本地存储，保存计算历史记录用到了它<br>有setStorage、getStorage，同时还有带Sync结尾的异步方法<br><img src="http://img.mukewang.com/57efd9d80001f7fa08990303.png" alt="图片描述"></p>
</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li><p>每新建一个页面一定要记得去app.josn的pages属性中添加，不然的话使用<code>navigateTo</code>跳转到新页面后新页面的<code>onLoad</code>方法不会执行。</p>
</li>
<li><p>微信小程序中没有window等JavaScript对象，所以在写JS前想好替代方案，比如本计算器就被坑大了，本来使用<code>eval</code>函数可以方便的计算表达式，结果没法用，绕了好大的弯。</p>
</li>
<li><p>微信小程序中的JS并不是真正的JS，wxss也并不是真正的CSS，所以写的时候还是要注意一下。</p>
</li>
<li><p>本计算器存在不完善和bug，因为重点不是实现全部功能，而是搞清楚微信小程序开发方法，所以非关注点不用在意。</p>
</li>
</ol>
<p>微信小程序总体来说不难，官方的文档也写的非常好，认真阅读官方文档就好。</p>
<hr>
<p>最后，欢迎小伙伴star或fork<a href="https://github.com/dunizb/wxapp-sCalc" target="_blank" rel="external">【微信小程序版简易计算器】</a>进行参考和学习，由于本人水平有限，程序中或博客中如有不对或错误之处请留言指出，谢谢！</p>
<p>另外，我的github还有<a href="https://github.com/dunizb/wxapp-movie" target="_blank" rel="external">【微信小程序-豆瓣电影】</a>项目，欢迎学习</p>
]]></content>
      
        <categories>
            
            <category> 微信开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[纯HTML+CSS+JavaScript编写的计算器应用]]></title>
      <url>/2016/09/24/%E7%BA%AFHTML+CSS+JavaScript%E7%BC%96%E5%86%99%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="一道笔试题"><a href="#一道笔试题" class="headerlink" title="一道笔试题"></a>一道笔试题</h2><p>之前偶然看到一个公司的笔试题，题目如下：</p>
<p>用HTML5、CSS3、JavaScript，做一个网页，实现如下图形式计算器</p>
<p><img src="https://segmentfault.com/img/bVDrd0?w=464&amp;h=640" alt="图片描述"></p>
<p>具体要求：</p>
<ol>
<li>有且只有一个文件：index.html。不允许再有其他文件，不允许再有单独的CSS、JS、PNG、JPG文件。  </li>
<li>运行环境为 Google Chrome。  </li>
<li>必须支持标准的四则运算。例如：1+2*3=7。  </li>
<li>请在收到邮件的48小时内独立完成本测试，并回复本邮件。  </li>
</ol>
<h2 id="一道笔试题引发的一个练手项目"><a href="#一道笔试题引发的一个练手项目" class="headerlink" title="一道笔试题引发的一个练手项目"></a>一道笔试题引发的一个练手项目</h2><p>花了一点时间写好的第一版，符合了笔试题的要求。后来左看右看觉得还可以改进做的更好，于是给它不断的改进，加新功能等，这样下来没完没了，利用业余时间一点一点的写，从刚开始的网页版，到后来做响应式的移动版，再到现在的移动App，短短续续大概写了3个月吧。</p>
<h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p>最终版的计算器，项目地址和预览图片在 GitHub：<a href="https://github.com/dunizb/sCalc" target="_blank" rel="external">https://github.com/dunizb/sCalc</a>。</p>
<h3 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h3><p>最终版的功能如下：  </p>
<ol>
<li>界面布局采用CSS3 的 Flex box布局  </li>
<li>内置两套主题可切换  </li>
<li>计算历史记录显示  </li>
<li>左滑右滑可以切换单手模式(App)  </li>
<li>当输入手机号码后长按等于号可以拨打手机号码(App)  </li>
<li>版本更新检查(App)  </li>
</ol>
<p><strong>界面布局</strong></p>
<p>由于这个项目只是练手,所以采用了HTML5个CSS3技术，也不打算兼容IE等低版本浏览器，所以直接使用CSS3提供的Flexbox布局方式。并且使用rem单位来进行自动计算尺寸。</p>
<p>计算计算历史记录显示功能，使用HTML5提供的本地存储功能之Local Storage，为了方便使用Local Storage，对它进行了简单的封装（见<code>js/common.js</code>文件）使之key值按一定规律生产，方便管理。</p>
<p><img src="https://segmentfault.com/img/bVDreb?w=1086&amp;h=316" alt="图片描述"></p>
<p>key由appName+id组成，id是自动增长不重复的，可以按id和appName删除一条记录，输入<code>*</code>则全部删除。</p>
<p><strong>打包APP</strong></p>
<p>移动Web版计算器写完后，又想把他做成APP在手机上运行，由于本人没用过混合APP诸如ionic之类的框架，所以参考了一下，选择了Hbuild来进行开发和APP的打包，非常方便。（<a href="http://www.dcloud.io/index.html" target="_blank" rel="external">HBuild</a>）.</p>
<p><strong>单手模式</strong></p>
<p>左滑右滑可以切换单手模式，这就需要移动端的touch事件了，使用如下代码判断是左滑还是又滑：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 单手模式 */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">singleModel</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> calc = <span class="built_in">document</span>.getElementById(<span class="string">"calc"</span>);</div><div class="line">    <span class="keyword">var</span> startX = <span class="number">0</span>,moveX = <span class="number">0</span>,distanceX = <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> distance = <span class="number">100</span>;  </div><div class="line">    <span class="keyword">var</span> width = calc.offsetWidth;</div><div class="line">    <span class="comment">//滑动事件</span></div><div class="line">    calc.addEventListener(<span class="string">"touchstart"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">        startX = e.touches[<span class="number">0</span>].clientX;</div><div class="line">    &#125;);</div><div class="line">    calc.addEventListener(<span class="string">"touchmove"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">        moveX = e.touches[<span class="number">0</span>].clientX;</div><div class="line">        distanceX = moveX - startX;</div><div class="line">        isMove = <span class="literal">true</span>;</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">"touchend"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">Math</span>.abs(distanceX) &gt; width/<span class="number">3</span> &amp;&amp; isMove)&#123;</div><div class="line">            <span class="keyword">if</span>( distanceX &gt; <span class="number">0</span> )&#123;</div><div class="line">                positionFun(<span class="string">"right"</span>);        <span class="comment">//右滑</span></div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                positionFun(<span class="string">"left"</span>);          <span class="comment">//作滑</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        startY = moveY = <span class="number">0</span>;</div><div class="line">        isMove = <span class="literal">false</span>;</div><div class="line">    &#125;);   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果是坐滑，就<code>position:absolut;left:0,bottom:0</code>，再把最外层DIV缩小到80%，这样就实现了左滑计算器缩小移动到左下角。右滑道理一样。</p>
<p><strong>电话拨打功能</strong></p>
<p>当输入手机号码后长按等于号可以拨打手机号码。这个功能没什么神奇，在移动Web上会对那些看起来像是电话号码的数字处理为电话链接，比如：</p>
<ul>
<li>7位数字，形如：1234567</li>
<li>带括号及加号的数字，形如：(+86)123456789</li>
<li>双连接线的数字，形如：00-00-00111</li>
<li>11位数字，形如：13800138000</li>
</ul>
<p>可能还有其他类型的数字也会被识别。我们可以通过如下的meta来开启电话号码的自动识别：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telephone=yes"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p>开启电话功能<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"tel:123456"</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>开启短信功能：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"sms:123456"</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>但是，在Android系统上，只能调用系统的拨号界面，在iOS上则能调过这一步直接把电话拨打出去。</p>
<p><strong>版本更新检查</strong></p>
<p>在关于页面，有一个版本更新检查按钮，就能检查是否有新版本，这个功能的原理是发送一个JSOPN请求去检查服务器上的JSON文件，比对版本号，如果服务器上的版本比APP的版本高则会提示有新版本可以下载。\</p>
<p>客户端JavaScript代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateApp</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//检查新版本</span></div><div class="line">    <span class="keyword">var</span> updateApp = <span class="built_in">document</span>.getElementById(<span class="string">"updateApp"</span>);</div><div class="line">    updateApp.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> _this = <span class="keyword">this</span>;</div><div class="line">        $.ajax(&#123;</div><div class="line">            <span class="attr">type</span>:<span class="string">'get'</span>,</div><div class="line">            <span class="attr">url</span>:<span class="string">'http://duni.sinaapp.com/demo/app.php?jsoncallback=?'</span>,</div><div class="line">            <span class="attr">dataType</span>:<span class="string">'jsonp'</span>,</div><div class="line">            <span class="attr">beforeSend</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                _this.innerHTML = <span class="string">"&lt;i class='iconfont updateAppIcon updateAppIconRotate'&gt;&lt;/i&gt; 正在检查新版本..."</span>;</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">success</span>:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">                <span class="keyword">var</span> newVer = data[<span class="number">0</span>].version;</div><div class="line">                <span class="keyword">if</span>(newVer &gt; appConfig.version)&#123;</div><div class="line">                    <span class="keyword">var</span> log = data[<span class="number">0</span>].log;</div><div class="line">                    <span class="keyword">var</span> downloadUrl = data[<span class="number">0</span>].downloadUrl;</div><div class="line">                    <span class="keyword">if</span>(confirm(<span class="string">"检查到新版本【"</span>+newVer+<span class="string">"】，是否立即下载？\n 更新日志：\n "</span> + log))&#123;</div><div class="line">                        <span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">"telPhone"</span>);</div><div class="line">                        a.href = downloadUrl;</div><div class="line">                        a.target = <span class="string">"_blank"</span>;</div><div class="line">                        a.click();</div><div class="line">                    &#125;</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    alert(<span class="string">"你很潮哦，当前已经是最新版本！"</span>);</div><div class="line">                &#125;</div><div class="line">                _this.innerHTML = <span class="string">"&lt;i class='iconfont updateAppIcon'&gt;&lt;/i&gt; 检查新版本"</span>;</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">error</span>:<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</div><div class="line">                _this.innerHTML = <span class="string">"&lt;i class='iconfont updateAppIcon'&gt;&lt;/i&gt; 检查新版本"</span>;</div><div class="line">                alert(<span class="string">"检查失败："</span>+msg.message);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>服务端JSON：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    &#123;</div><div class="line">        <span class="string">"version"</span>:<span class="string">"3.1.0"</span>,</div><div class="line">        <span class="string">"downloadUrl"</span>:<span class="string">"http://dunizb.b0.upaiyun.com/demo/app/myCalc-3.1.0.apk"</span>,</div><div class="line">        <span class="string">"hashCode"</span>:<span class="string">"20160812224616"</span>,</div><div class="line">        <span class="string">"log"</span>:<span class="string">"1.新增切换主题功能 \n 2.新增单手切换模式功能 \n 3.调整UI "</span></div><div class="line">    &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h2 id="下个版本计划"><a href="#下个版本计划" class="headerlink" title="下个版本计划"></a>下个版本计划</h2><p>当前3.1.0版本还存在一些问题：  </p>
<ol>
<li>由于JS本身存在计算浮点数精度丢失问题，所以这个问题在项目中同意存在，需要自己去处理这个问题  </li>
<li>由于使用了第三方的天气接口，用了jquery.Ajax方法，所以违背了使用纯原生写的初衷。  </li>
</ol>
<p>所以下个版本的开发计划为：  </p>
<ol>
<li>解决浮点数计算精度问题  </li>
<li>把获取天气信息的jquery.Ajax方法替换为原生JavaScript代码，自己封装JSONP请求函数  </li>
<li>使用面向对象方式重构APP  </li>
</ol>
<p>欢迎大家到github上来看看，如果喜欢可以star、watch一下，或提issue。</p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> JavaScript </tag>
            
            <tag> html </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[进击JavaScript之（五）原型与继承]]></title>
      <url>/2016/09/19/%E8%BF%9B%E5%87%BBJavaScript%E4%B9%8B%EF%BC%88%E4%BA%94%EF%BC%89%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<h1 id="一、原型"><a href="#一、原型" class="headerlink" title="一、原型"></a>一、原型</h1><p>一句话说明什么是原型：原型能存储我们的方法，构造函数创建出来的实例对象能够引用原型中的方法。</p>
<h2 id="1-1-JS的对象比较"><a href="#1-1-JS的对象比较" class="headerlink" title="1.1 JS的对象比较"></a>1.1 JS的对象比较</h2><p>由于JS是解析执行的语言，那么在代码中出现函数与对象如果重复执行，会创建多个副本。</p>
<ol>
<li>在代码中重复执行的代码容易出现重复的对象</li>
<li>传统的构造函数定义方式会影响性能</li>
<li>可以考虑将方法全部放到外面但是会有安全问题<ul>
<li>在开发中会引入各种框架和库，自定义的成员越多，出现命名冲突的几率越大</li>
<li>在开发中可能会有多个构造函数，每一个构造函数应该有多个方法，那么就会变得不容易维护。</li>
</ul>
</li>
<li>任意一个对象都会默认的链接到它的原型中    <ul>
<li>创建一个函数，会附带的创建一个特殊的对象，该对象使用函数<code>.prototype</code>引用。称其为函数的<strong>原型属性</strong></li>
<li>每一个由该函数作为构造函数创建的对象，都会默认的连接到该对象上</li>
<li>在该对象访问某一个方法或属性时的时候，如果该对象中没有，就会到这个原型中去查找。</li>
</ul>
</li>
</ol>
<h2 id="1-2-传统构造函数的问题"><a href="#1-2-传统构造函数的问题" class="headerlink" title="1.2 传统构造函数的问题"></a>1.2 传统构造函数的问题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>由于对象是调用<code>new Foo()</code>所创建出来的，因此每一个对象在创建的时候，函数sayHello都会呗创建一次</li>
<li>那么没一个对象都含有一个独立的，不同的，但是功能逻辑一样的函数，比如：<code>{} == {}</code></li>
<li>在代码中方法就会消耗性能，最典型的资源就越是内存</li>
<li>这里最好的方法就是将函数放在构造函数之外，那么在构造函数中引用该函数即可    </li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.say = sayHello；</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>会在开发中变得困难：引入框架危险，代码繁冗不好维护。解决方法就是如果外面的函数不占用其名字，而且在函数名下</li>
<li>每一个函数在定义的时候，有一个神秘对象（即原型）被创建出来。</li>
<li>每一个由构造函数创建的对象都会默认的连接到该神秘对象上。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo();</div><div class="line"><span class="keyword">var</span> f2 = <span class="keyword">new</span> Foo();</div><div class="line">f1.sayHello();    <span class="comment">//如果f1没有sayHello那么就会在Foo.prototype中去找</span></div></pre></td></tr></table></figure>
<ul>
<li>由构造函数创建出来的众多对象共享一个对象就是构造函数.prototype</li>
<li>只需要将共享的东西，重复会多占用内存的东西放到构造函数.prototype中，那么所有的对象就可以共享了。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Foo.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"...."</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo();</div><div class="line">f1.sayHello();</div><div class="line"><span class="keyword">var</span> f2 = <span class="keyword">new</span> Foo();</div><div class="line">f2.sayHello();</div><div class="line"><span class="built_in">console</span>.log(f1.sayHello === f2.sayHello);</div></pre></td></tr></table></figure>
<p>下面写一个构造函数 Student, 有 name, age, gender, sayHello, study. 构造函数带参数.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Student = <span class="function"><span class="keyword">function</span>(<span class="params">name,age,gender</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="keyword">this</span>.age = age;</div><div class="line">    <span class="keyword">this</span>.gender = gender;</div><div class="line">&#125;</div><div class="line">Student.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"你好，我是："</span>+<span class="keyword">this</span>.name;</div><div class="line">&#125;</div><div class="line">Student.prototype.study = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"我正在学习JavaScript"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> stu1 = <span class="keyword">new</span> Student(<span class="string">"zhangsan"</span>,<span class="number">19</span>,<span class="string">"man"</span>);</div><div class="line"><span class="built_in">console</span>.log(stu1);</div><div class="line"><span class="built_in">console</span>.log(stu1.sayHello());</div><div class="line"><span class="keyword">var</span> stu2 = <span class="keyword">new</span> Student(<span class="string">"李四"</span>,<span class="number">20</span>,<span class="string">"woman"</span>);</div><div class="line"><span class="built_in">console</span>.log(stu2);</div><div class="line"><span class="built_in">console</span>.log(stu2.study());</div></pre></td></tr></table></figure>
<h2 id="1-3-常见错误"><a href="#1-3-常见错误" class="headerlink" title="1.3 常见错误"></a>1.3 常见错误</h2><p>写 构造函数<code>.prototype</code> 的时候, 将属性也加到里面.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">Person.prototype.name = <span class="string">'张三'</span>;</div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure>
<p>赋值的错误</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">Person.prototype.name = <span class="string">'张三'</span>;</div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();</div><div class="line">p1.name = <span class="string">'李四'</span>;</div><div class="line"><span class="built_in">console</span>.log( p1.name );</div><div class="line"><span class="built_in">console</span>.log( p2.name );</div><div class="line"><span class="comment">// 如果是访问数据, 当前对象中如果没有该数据就到构造函数的原型属性中去找</span></div><div class="line"><span class="comment">// 如果是写数据, 当对象中有该数据的时候, 就是修改值; 如果对象没有该数据, 那么就添加值</span></div></pre></td></tr></table></figure>
<h2 id="1-4-原型相关的概念"><a href="#1-4-原型相关的概念" class="headerlink" title="1.4 原型相关的概念"></a>1.4 原型相关的概念</h2><h3 id="1-4-1-关于面向对象的概念"><a href="#1-4-1-关于面向对象的概念" class="headerlink" title="1.4.1 关于面向对象的概念"></a>1.4.1 关于面向对象的概念</h3><ul>
<li>类class：在JS中就是构造函数<ul>
<li>在传统的面向对象语言中，使用一个叫类的东西定义模板，然后使用模板创建对象。</li>
<li>在构造方法中也具有类似的功能，因此也称其为类</li>
</ul>
</li>
<li>实例（instance）与对象（object）<ul>
<li>实例一般是指某一个构造函数创建出来的对象，我们称为XXXX 构造函数的实例</li>
<li>实例就是对象。对象是一个泛称</li>
<li>实例与对象是一个近义词</li>
</ul>
</li>
<li>键值对与属性和方法<ul>
<li>在JS中键值对的集合称为对象</li>
<li>如果值为数据（非函数），就称该键值对为属性</li>
<li>如果值为函数（方法），就称该键值对为方法method</li>
<li>父类与子类（基类和派生类）</li>
<li>传统的面向对象语言中使用类来实现继承那么就有父类、子类的概念</li>
<li>父类又称为基类，子类又称为派生类</li>
<li>在JS中没有类的概念，在JS中常常称为父对象，子对象，基对象，派生对象。</li>
</ul>
</li>
</ul>
<h3 id="1-4-2-原型相关的概念"><a href="#1-4-2-原型相关的概念" class="headerlink" title="1.4.2 原型相关的概念"></a>1.4.2 原型相关的概念</h3><ul>
<li>原型针对构造函数称为原型属性<ul>
<li>原型就是构造函数的原型属性，简称<strong>原型</strong></li>
</ul>
</li>
<li>原型与构造函数创造出来的对象也有一定的关系：<ul>
<li>原型针对构造函数创建出来的对象称为原型对象，简称原型</li>
<li>对象继承自其原型</li>
<li>构造函数创建的对象 继承自 构造函数的原型属性</li>
<li>构造函数创建的对象 继承自 该对象的原型对象</li>
<li>构造函数所创建出来的对象与构造函数的原型属性表示的对象是两个不同的对象    </li>
<li>原型中的成员，可以直接被实例对象所使用</li>
<li>也就是说实例对象直接含有原型中的成员</li>
<li>因此实例对象继承自原型</li>
<li>这样的继承就是原型继承</li>
</ul>
</li>
</ul>
<h2 id="1-5-如何使用原型"><a href="#1-5-如何使用原型" class="headerlink" title="1.5 如何使用原型"></a>1.5 如何使用原型</h2><p>为什么要使用原型？——提高函数的复用性。<br>为什么属性不放在原型上而方法要放在原型上？</p>
<ol>
<li>利用对象的动态特性<ul>
<li>构造函数.prototype.xxxx = vvv;</li>
</ul>
</li>
<li>利用直接替换</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Student.prototype = &#123;</div><div class="line">    <span class="attr">sayHello</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</div><div class="line">    <span class="attr">study</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="1-6-——proto——"><a href="#1-6-——proto——" class="headerlink" title="1.6 ——proto——"></a>1.6 <code>——proto——</code></h2><p>以前要访问原型，必须使用构造函数来实现，无法直接使用实例对象来访问原型。<br>火狐最早引入属性<code>__proto__</code>表示使用实例对象引用原型。但是早期是非标准的。<br>通过该属性可以允许使用实例对象直接访问原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="comment">// 神秘对象就是Person.prototype</span></div><div class="line"><span class="comment">//那么只有使用构造函数才可以访问它</span></div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Person();</div><div class="line"><span class="comment">//以前不能直接使用o来访问神秘对象</span></div><div class="line"><span class="comment">//现在有了__proto__后，</span></div><div class="line">o.__proto__也可以直接访问神秘对象</div><div class="line"><span class="comment">//那么o.__proto__ === Person.prototype</span></div></pre></td></tr></table></figure>
<ol>
<li>神秘对象（原型）中都有一个属性<code>constructor</code>，翻译为 构造器 。表示该原型是与什么构造函数联系起来的。</li>
<li><code>__proto__</code>有什么用?<ul>
<li>可以访问原型</li>
<li>由于在开发中除非特殊要求，不要使用实例去修改原型的成员，因此该属性开发时使用较少。</li>
<li>但是在调试过程中非常方便，可以轻易的访问原型进行查看成员</li>
</ul>
</li>
<li><p>如果在早期的浏览器中使用实例需要访问原型如何处理？</p>
<ul>
<li>可以使用实例对象访问构造器，然后使用构造器访问原型<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Person();</div><div class="line">o.constructor.prototype</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>如果给实例继承自原型的属性赋值</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>);</span></div><div class="line"><span class="title">Foo</span>.<span class="title">prototype</span>.<span class="title">name</span> = "<span class="title">test</span>";</div><div class="line"><span class="title">var</span> <span class="title">o1</span> = <span class="title">new</span> <span class="title">Foo</span>(<span class="params"></span>);</div><div class="line"><span class="title">var</span> <span class="title">o2</span> = <span class="title">new</span> <span class="title">Foo</span>(<span class="params"></span>);</div><div class="line"><span class="title">o1</span>.<span class="title">name</span> = "张三";    // 不是修改原型中的<span class="title">name</span>而是自己增加了一个<span class="title">name</span>属性</div><div class="line"><span class="title">console</span>.<span class="title">log</span>(<span class="params">o1.name + <span class="string">'，'</span>+ o2.name</span>);    // 张三，<span class="title">test</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h1><ol>
<li>最简单的继承就是将别的对象的属性强加到我身上，那么我就有这个成员了。</li>
<li>利用原型也可以实现继承，不需要在我身上添加任何成员，只要原型有了我就有了。</li>
</ol>
<p><strong>结论</strong><br>将属性，方法等成员利用混入的办法，加到构造器函数的原型上，那么构造器函数的实例就具有该方法了。</p>
<h2 id="2-1-混合式继承的简单描述"><a href="#2-1-混合式继承的简单描述" class="headerlink" title="2.1 混合式继承的简单描述"></a>2.1 混合式继承的简单描述</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"><span class="keyword">var</span> extend = <span class="function"><span class="keyword">function</span> (<span class="params"> o1, o2 </span>) </span>&#123;</div><div class="line">      <span class="keyword">for</span> ( <span class="keyword">var</span> k <span class="keyword">in</span> o2 ) &#123;</div><div class="line">           o1[ k ] = o2[ k ];</div><div class="line">      &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">extend( Person.prototype, &#123;</div><div class="line">     <span class="attr">run</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">'我能跑了'</span> ); &#125;,</div><div class="line">     <span class="attr">eat</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">'我可以吃了'</span> ); &#125;,</div><div class="line">     <span class="attr">sayHello</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">'我吃饱了'</span> ); &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>改良<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">Person.prototype.extend = <span class="function"><span class="keyword">function</span> (<span class="params"> o </span>) </span>&#123;</div><div class="line">     <span class="keyword">for</span> ( <span class="keyword">var</span> k <span class="keyword">in</span> o ) &#123;</div><div class="line">          <span class="keyword">this</span>[ k ] = o[ k ];</div><div class="line">     &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">Person.prototype.extend(&#123;</div><div class="line">      <span class="attr">run</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">'我能跑了'</span> ); &#125;,</div><div class="line">      <span class="attr">eat</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">'我可以吃了'</span> ); &#125;,</div><div class="line">      <span class="attr">sayHello</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log( <span class="string">'我吃饱了'</span> ); &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="2-2-细节"><a href="#2-2-细节" class="headerlink" title="2.2 细节"></a>2.2 细节</h2><p>使用点语法给原型添加成员与直接替换修改原型对象有什么区别？</p>
<ol>
<li>原型指向发生了变化</li>
<li>构造函数所创建的对象所继承的原型不同</li>
<li>新增的对象默认是没有<code>constructor</code>属性</li>
</ol>
<p>注意：在使用替换方式修改原型的时候，一般都会添加constructor属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">Person.prototype = &#123;</div><div class="line">    <span class="attr">constructor</span>: Person</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 拆解</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> o = &#123;&#125;;</div><div class="line">o.constructor = Person;    <span class="comment">// 属性中就存储着函数的地址</span></div><div class="line"></div><div class="line">Person.prototype = o;</div><div class="line"></div><div class="line">Person = <span class="number">123</span>;</div></pre></td></tr></table></figure></p>
<h2 id="2-3-静态成员与实例成员的概念"><a href="#2-3-静态成员与实例成员的概念" class="headerlink" title="2.3 静态成员与实例成员的概念"></a>2.3 静态成员与实例成员的概念</h2><p>也是从面向对象的语言中引入的</p>
<ol>
<li>静态成员表示的是 静态方法和静态属性的概念，所谓的静态，就是由构造函数所提供的。</li>
<li>实例成员表示的是 实例方法 和 实例属性，所谓实例就是由构造函数所创建的对象。</li>
</ol>
<p>一般工具型方法都有静态成员提供，一般与实例对象有关的方法有实例成员表示。</p>
<h2 id="2-4-构造、原型、实例三角结构图"><a href="#2-4-构造、原型、实例三角结构图" class="headerlink" title="2.4 构造、原型、实例三角结构图"></a>2.4 构造、原型、实例三角结构图</h2><p><img src="http://img.imooc.com/57d226440001674106910470.png" alt="构造、原型、实例三角结构图"></p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[进击JavaScript之（四）玩转递归与数列]]></title>
      <url>/2016/09/06/%E8%BF%9B%E5%87%BBJavaScript%E4%B9%8B%EF%BC%88%E5%9B%9B%EF%BC%89%E7%8E%A9%E8%BD%AC%E9%80%92%E5%BD%92%E4%B8%8E%E6%95%B0%E5%88%97/</url>
      <content type="html"><![CDATA[<h2 id="1、-什么是递归"><a href="#1、-什么是递归" class="headerlink" title="1、 什么是递归"></a>1、 什么是递归</h2><p>在程序中，所谓的递归，就是函数自己直接或间接调用自己</p>
<h3 id="1-1-直接调用自己"><a href="#1-1-直接调用自己" class="headerlink" title="1.1 直接调用自己"></a>1.1 直接调用自己</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( <span class="number">1</span> );</div><div class="line">    f();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1-2-间接调用自己"><a href="#1-2-间接调用自己" class="headerlink" title="1.2 间接调用自己"></a>1.2 间接调用自己</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    f2();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    f1();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就递归而言，最重要的是跳出结构，因为只有跳出结构才可以有结果。</p>
<h3 id="1-3-所谓的递归就是化归思想"><a href="#1-3-所谓的递归就是化归思想" class="headerlink" title="1.3 所谓的递归就是化归思想"></a>1.3 所谓的递归就是化归思想</h3><p>递归的调用，写递归函数，最终还是要转换为自己这个函数</p>
<p>加入有一个函数f，如果他是递归函数的话，也就是说函数体内的问题还是转化为 f 的形式。</p>
<p>递归思想就是将一个问题转换为一个已解决的问题来实现</p>
<p>例子：1,2,3,4，…,100，累加的结果</p>
<p>1.首先假定递归函数已经写好，假设是foo，即foo(100) 就是求1到100的和;<br>2.寻找递推关系，就是<code>n</code>与<code>n - 1</code>，或<code>n - 2</code>之间的关系：<code>foo( n ) == n + foo( n -1 )</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> res = foo( <span class="number">100</span> );</div><div class="line"><span class="keyword">var</span> res = foo( <span class="number">99</span> ) + <span class="number">100</span>;</div></pre></td></tr></table></figure></p>
<p>3.将递推结果转换为递归体<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"> n </span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> n + foo( n <span class="number">-1</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>a.将求100转换为求99<br>b.将求99转换为求98<br>c….<br>d.将求2转换为求1<br>e.求1结果就是1<br>f.即：foo( 1 ) 是1</p>
<p>将临界条件加到递归体中<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"> n </span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> ( n == <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> n + foo( n <span class="number">-1</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="2、-递归求值举例"><a href="#2、-递归求值举例" class="headerlink" title="2、 递归求值举例"></a>2、 递归求值举例</h2><h3 id="2-1-等差数列1"><a href="#2-1-等差数列1" class="headerlink" title="2.1 等差数列1"></a>2.1 等差数列1</h3><p>数列：求 1, 3, 5, 7, 9, … 第 n 项的结果与前 n 项和. 序号从 0 开始</p>
<p><strong>求第 n 项的值</strong><br>1.首先假定递归函数已经写好, 假设是 fn. 那么 第 n 项就是 fn( n )<br>2.找递推关系: fn( n ) == f( n - 1 ) + 2<br>3.递归体<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"> n </span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> fn( n<span class="number">-1</span> ) + <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.找临界条件</p>
<ul>
<li>求 n -&gt; n-1</li>
<li>求 n-1 -&gt; n-2</li>
<li>…</li>
<li>求 1 -&gt; 0</li>
<li>求 第 0 项, 就是 1</li>
<li>加入临界条件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"> n </span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> ( n == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> fn( n<span class="number">-1</span> ) + <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>前N项的和</strong><br>1.假设已完成, sum( n ) 就是前 n 项和<br>2.找递推关系: 前 n 项和 等于 第 n 项 + 前 n-1 项的和<br>3.得到递归体<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"> n </span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> fn( n ) + sum( n - <span class="number">1</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>找临界条件：n == 1 结果为1<br>得到递归函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"> n </span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> ( n == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> fn( n ) + sum( n - <span class="number">1</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="2-2-等差数列2"><a href="#2-2-等差数列2" class="headerlink" title="2.2 等差数列2"></a>2.2 等差数列2</h3><p>数列：2, 4, 6, 8, 10 第 n 项与 前 n 项和</p>
<p><strong>第n项</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"> n </span>) </span>&#123;</div><div class="line">   <span class="keyword">if</span> ( n == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">2</span>; </div><div class="line">   <span class="keyword">return</span> fn( n<span class="number">-1</span> ) + <span class="number">2</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>前n项和</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"> n </span>) </span>&#123; </div><div class="line">   <span class="keyword">if</span> ( n == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">2</span>; </div><div class="line">   <span class="keyword">return</span> sum( n - <span class="number">1</span> ) + fn( n ); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="2-3-差分数列"><a href="#2-3-差分数列" class="headerlink" title="2.3 差分数列"></a>2.3 差分数列</h3><p>数列: 1, 1, 2, 4, 7, 11, 16, … 求 第 n 项, 求前 n 项和.</p>
<p><strong>求第 n 项，从0开始</strong><br>1.假设已经得到结果 fn, fn( 10 ) 就是第 10 项<br>2.找递推关系</p>
<ul>
<li>第 0 项和第 1 项，相差0 =&gt; fn( 0 ) + 0 = fn( 1 )</li>
<li>第 1 项和第 2 项，相差1 =&gt; fn( 1 ) + 1 = fn( 2 )</li>
<li>第 2 项和第 3 项，相差2 =&gt; fn( 2 ) + 2 = fn( 2 )</li>
<li>… </li>
<li>第 n-1 项和第 n 项，相差n-1 =&gt; fn( n -1 ) + n -1 = fn( n )</li>
<li>递归体也就清楚了, 临界条件是 n == 0 =&gt; 1</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"> n </span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>( n == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> fn( n <span class="number">-1</span> ) + n - <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>如果从 1 开始表示, 那么第 n 项为</strong><br>1.假设已经得到结果 fn, fn( 10 ) 就是第 10 项<br>2.找递推关系</p>
<ul>
<li>第 1 项和第 2 项，相差0 =&gt; fn( 1 ) + 0 = fn( 2 )</li>
<li>第 2 项和第 3 项，相差1 =&gt; fn( 2 ) + 1 = fn( 3 )</li>
<li>第 3 项和第 4 项，相差2 =&gt; fn( 3 ) + 2 = fn( 4 )</li>
<li>…</li>
<li>第 n-1 项和第第 n 项，相差 n - 1 =&gt; fn( n -1 ) + n -2 = fn( n )</li>
<li>临界条件 n == 1 =&gt; 1</li>
</ul>
<p><strong>前n项和</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"> n </span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> ( n == <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> sum( n - <span class="number">1</span> ) + fn( n ); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="2-4-斐波那契数列"><a href="#2-4-斐波那契数列" class="headerlink" title="2.4 斐波那契数列"></a>2.4 斐波那契数列</h3><p>这是最常见，面试最爱问的知识之一，斐波那契数列为：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, … </p>
<p><strong>求其第 n 项</strong><br>递推关系 fn(n) == fn( n- 1) + fn( n - 2)，于是，递归函数为<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span> (<span class="params"> n </span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>( n ==<span class="number">0</span> || n == <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> fib( n <span class="number">-1</span> ) + fib( n <span class="number">-2</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="3、高级递归"><a href="#3、高级递归" class="headerlink" title="3、高级递归"></a>3、高级递归</h2><h3 id="3-1-阶乘"><a href="#3-1-阶乘" class="headerlink" title="3.1 阶乘"></a>3.1 阶乘</h3><p>计算阶乘是递归程序设计的一个经典示例。阶乘是一个运算,计算某个数的阶乘就是用那个数去乘包括 1 在内的所有比它小的数。例如，factorial(5) 等价于 <code>5*4*3*2*1</code>，而 factorial(3) 等价于 <code>3*2*1</code>。 </p>
<p>5! 就是  <code>1 * 2 * 3 * 4 * 5</code>. 0 的阶乘是1, 阶乘 从 1 开始。</p>
<p><strong>求 n 的阶乘</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"> n </span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>( n == <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> foo( n <span class="number">-1</span> ) * n; </div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(foo(<span class="number">5</span>));    <span class="comment">//120</span></div></pre></td></tr></table></figure></p>
<p>跟前面的1到100的求和的递归函数很相似，只是一个变种</p>
<h3 id="3-2-求幂"><a href="#3-2-求幂" class="headerlink" title="3.2 求幂"></a>3.2 求幂</h3><p>求幂就是求 某一个数 几次方<br>2*2 2 的 平方, 2 的 2 次方</p>
<p><strong>求 n 的 m 次方</strong><br>最终要得到一个函数 power( n, m )<br>n 的 m 次方就是 m 个 n 相乘 即 n 乘以 (m-1) 个 n 相乘<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">power</span>(<span class="params"> n, m </span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>( m == <span class="number">1</span> ) <span class="keyword">return</span> n;</div><div class="line">    <span class="keyword">return</span> power( n , m <span class="number">-1</span> ) * n;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(power(<span class="number">2</span>,<span class="number">3</span>)); <span class="comment">//8</span></div></pre></td></tr></table></figure></p>
<h2 id="4、递归深拷贝"><a href="#4、递归深拷贝" class="headerlink" title="4、递归深拷贝"></a>4、递归深拷贝</h2><p>如果要实现深拷贝，那么就需要考虑将对象的属性，与属性的属性，….都拷贝过来</p>
<h3 id="4-1-简单实现"><a href="#4-1-简单实现" class="headerlink" title="4.1 简单实现"></a>4.1 简单实现</h3><p>如果要实现：<br>1.假设已经实现clone( o1,o2 )，将对象 o2 的成员拷贝一份交给 o1<br>2.简单的算法，将 o2 的属性拷贝到 o1 中去<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params"> o1,o2 </span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> k <span class="keyword">in</span> o2 )&#123;</div><div class="line">        o1[ k ] = o2[ k ]; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.找递推关系，或叫化归为已解决的问题</p>
<ul>
<li>假设方法已经实现，问一下，如果o2[ k ] 是对象</li>
<li>继续使用这个方法</li>
<li>因此需要考虑的是o2[ k ] 如果是引用类型，再使用一次clone()函数</li>
<li>如果o2[ k ] 不是引用类型，那么就直接赋值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params"> o1, o2 </span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span> ( <span class="keyword">var</span> k <span class="keyword">in</span> o2 ) &#123;</div><div class="line">            <span class="keyword">if</span> ( <span class="keyword">typeof</span> o2[ k ] == <span class="string">'object'</span> ) &#123;</div><div class="line">                o1[ k ] = &#123;&#125;;</div><div class="line">                clone( o1[ k ] , o2[ k ] );</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                o1[ k ] = o2[ k ];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = &#123;</div><div class="line">       <span class="attr">name</span>: <span class="string">'张三'</span>,</div><div class="line">       <span class="attr">children</span>: [</div><div class="line">            &#123; <span class="attr">name</span>: <span class="string">'张一'</span> &#125;,</div><div class="line">            &#123; <span class="attr">name</span>: <span class="string">'张二'</span> &#125;,</div><div class="line">            &#123; <span class="attr">name</span>: <span class="string">'王三'</span> &#125;</div><div class="line">       ]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person2 = &#123;&#125;;</div><div class="line">clone( person2, person1 );</div></pre></td></tr></table></figure>
<h3 id="4-2-复杂实现-clone-o-gt-newObj"><a href="#4-2-复杂实现-clone-o-gt-newObj" class="headerlink" title="4.2 复杂实现 clone( o ) -&gt; newObj"></a>4.2 复杂实现 clone( o ) -&gt; newObj</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params"> o </span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> temp = &#123;&#125;;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> k <span class="keyword">in</span> o ) &#123;</div><div class="line">        <span class="keyword">if</span>( <span class="keyword">typeof</span> o[ k ] == <span class="string">'object'</span> )&#123;</div><div class="line">             temp[ k ] = clone( o[ k ] );</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">             temp[ k ] = o[ k ];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = &#123;</div><div class="line">     <span class="attr">name</span>: <span class="string">'张三'</span>,</div><div class="line">     <span class="attr">children</span>: [</div><div class="line">        &#123; <span class="attr">name</span>: <span class="string">'张一'</span> &#125;,</div><div class="line">        &#123; <span class="attr">name</span>: <span class="string">'张二'</span> &#125;,</div><div class="line">        &#123; <span class="attr">name</span>: <span class="string">'王三'</span> &#125;</div><div class="line">    ]</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"> <span class="keyword">var</span> person2 = clone(person1);</div><div class="line"><span class="comment">// 修改一个看另一个是否也修改</span></div><div class="line">person2.name = <span class="string">'李四'</span>;</div><div class="line"> </div><div class="line">person2.children[ <span class="number">0</span> ].name = <span class="string">'王小虎'</span>;</div><div class="line">person2.children[ <span class="number">1</span> ].name = <span class="string">'张大虎'</span>;</div><div class="line">person2.children[ <span class="number">2</span> ].name = <span class="string">'李长虎'</span>;</div></pre></td></tr></table></figure>
<h3 id="4-3-递归实现getElementsByClassName方法"><a href="#4-3-递归实现getElementsByClassName方法" class="headerlink" title="4.3 递归实现getElementsByClassName方法"></a>4.3 递归实现getElementsByClassName方法</h3><p>有如下DIV结构：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>1</div><div class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"c"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"c"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>5</div><div class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"c"</span>&gt;</span>7<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>8<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>1.如果实现一个方法<code>byClass( node, &#39;c&#39;, list )</code>，表示在某个节点上查找符合 class 属性为 c 的元素<br>2.在当前元素的子元素中查找，如果有符合要求的吗，存储早一个数组中<br>3.首先遍历子节点，然后看子节点是否还有子节点，如果没有直接判断，如果有再递归</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">byClass</span>(<span class="params"> node, className, list </span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> nodes = node.childNodes;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>; i&lt;ndoes.length; i++ )&#123;</div><div class="line">         <span class="keyword">if</span>( nodes[ i ].className == className )&#123;</div><div class="line">             list.push( nodes[ i ] );</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">if</span>( nodes[ i ].childNodes.length &gt; <span class="number">0</span> )&#123;</div><div class="line">             byClass( nodes[ i ], className, list );</div><div class="line">         &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = [];</div><div class="line">byClass( <span class="built_in">document</span>.body, <span class="string">'c'</span>, arr );</div><div class="line"><span class="built_in">console</span>.log(arr);</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[进击JavaScript之（三）玩转闭包]]></title>
      <url>/2016/08/28/%E8%BF%9B%E5%87%BBJavaScript%E4%B9%8B%EF%BC%88%E4%B8%89%EF%BC%89%E7%8E%A9%E8%BD%AC%E9%97%AD%E5%8C%85/</url>
      <content type="html"><![CDATA[<blockquote>
<p>为了更好的理解，在阅读此文之前建议先阅读上一篇<a href="http://dunizb.com/2017/08/19/进击JavaScript之（二）词法作用域与作用域链/">《进击JavaScript之词法作用域与作用域链》</a></p>
</blockquote>
<h2 id="1-什么是闭包"><a href="#1-什么是闭包" class="headerlink" title="1.什么是闭包"></a>1.什么是闭包</h2><p>闭包的含义就是闭合，包起来，简单的来说，就是一个具有封闭功能与包裹功能的结构。所谓的闭包就是一个具有封闭的对外不公开的，包裹结构，或空间。</p>
<p>在JS中函数构成闭包。一般函数是一个代码结构的封闭结构，即包裹的特性，同时根据作用域规则只允许函数访问外部的数据，外部无法访问函数内部的数据，即封闭的对外不公开的特性，因此说函数可以构成闭包。</p>
<blockquote>
<p>概括：闭包就是一个具有封闭与包裹功能的结构。函数可以构成闭包。函数内部定义的数据函数外部无法访问，即函数具有封闭性；函数可以封装代码即具有包裹性，所以函数可以构成闭包。</p>
</blockquote>
<h2 id="2-闭包有什么用（解决什么问题）？"><a href="#2-闭包有什么用（解决什么问题）？" class="headerlink" title="2.闭包有什么用（解决什么问题）？"></a>2.闭包有什么用（解决什么问题）？</h2><ol>
<li>闭包不允许外部访问</li>
<li>要解决的问题就是间接访问该数据</li>
</ol>
<p>函数就可以构成闭包，要解决的问题就是如何访问到函数内部的数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> num  = <span class="number">123</span>;</div><div class="line">    <span class="keyword">return</span> num;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> res = foo();</div><div class="line"><span class="built_in">console</span>.log( res );    <span class="comment">// =&gt;123</span></div></pre></td></tr></table></figure></p>
<p>这里的确是访问到函数中的数据了。但是该数据不能第二次访问，因此第二次访问的时候又要调用一次foo，表示又有一个新的num = 123出来了。</p>
<p>在函数内的数据，不能直接在函数外部访问，那么在函数内如果定义一个函数，那么在这个函数内部中是可以直接访问的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> num = <span class="built_in">Math</span>.random();</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> mun;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> func;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> f = foo();</div><div class="line"><span class="comment">// f 可以直接访问这个 num</span></div><div class="line"><span class="keyword">var</span> res1 = f();</div><div class="line"><span class="keyword">var</span> res2 = f();</div></pre></td></tr></table></figure></p>
<p>我们使用前面学习的绘制作用域链结构图的方法来绘制闭包的作用域链结构图，如下： </p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-29f42ee2c9f5f863.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.jpg"></p>
<h2 id="3-闭包使用举例"><a href="#3-闭包使用举例" class="headerlink" title="3.闭包使用举例"></a>3.闭包使用举例</h2><h3 id="3-1-如何获得超过一个数据"><a href="#3-1-如何获得超过一个数据" class="headerlink" title="3.1 如何获得超过一个数据"></a>3.1 如何获得超过一个数据</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> num1 = <span class="built_in">Math</span>.random();</div><div class="line">    <span class="keyword">var</span> num2 = <span class="built_in">Math</span>.random();</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">num1</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> num1;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">num2</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> num2;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-如何完成读取一个数据和修改这个数据"><a href="#3-2-如何完成读取一个数据和修改这个数据" class="headerlink" title="3.2 如何完成读取一个数据和修改这个数据"></a>3.2 如何完成读取一个数据和修改这个数据</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> num = <span class="built_in">Math</span>.random();</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">get_num</span> : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> num;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">set_num</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> value </span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> num = value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-基本的闭包结构"><a href="#4-基本的闭包结构" class="headerlink" title="4.基本的闭包结构"></a>4.基本的闭包结构</h2><p>一般闭包的问题就是要想办法简洁的获取函数内的数据使用权，那么我们就可以总结出一个基本的使用模型。</p>
<ol>
<li>写一个函数，函数内部定义一个新函数，返回新函数，用新函数获得函数内的数据</li>
<li>写一个函数，函数内部定义个一个对象，对象中绑定多个函数（方法），返回对象，利用对象的方法访问函数内的数据</li>
</ol>
<h2 id="5-闭包的基本用法"><a href="#5-闭包的基本用法" class="headerlink" title="5.闭包的基本用法"></a>5.闭包的基本用法</h2><p>闭包是为了实现具有私有访问空间的函数的</p>
<p><strong>带有私有访问数据的对象</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">"张三"</span>;</div><div class="line">    <span class="comment">// setName( '' )</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有的私有数据，就是说只有函数内部可以访问的数据，或对象内部的方法可以访问的数据</p>
<p>最简单的实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> __name__ = <span class="string">""</span>;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> __name__;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">setName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"> value </span>) </span>&#123;</div><div class="line">            <span class="comment">// 如果不姓张就报错</span></div><div class="line">            <span class="keyword">if</span> ( value.charAt(<span class="number">0</span>) === <span class="string">'张'</span> ) &#123;</div><div class="line">                __name__ = value;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">'姓氏不对，不能取名'</span> );</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> p = createPerson();</div><div class="line">p.set_Name( <span class="string">'张三丰'</span> );</div><div class="line"><span class="built_in">console</span>.log( p.get_Name() );</div><div class="line">p.set_Name( <span class="string">'张王富贵'</span> );</div><div class="line"><span class="built_in">console</span>.log( p.get_Name() );</div></pre></td></tr></table></figure></p>
<p><strong>带有私有数据的函数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 私有数据</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// 可以使用私有的数据</span></div><div class="line">        ...</div><div class="line">    &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="6-闭包基本模型"><a href="#6-闭包基本模型" class="headerlink" title="6.闭包基本模型"></a>6.闭包基本模型</h2><h3 id="6-1-对象模型"><a href="#6-1-对象模型" class="headerlink" title="6.1 对象模型"></a>6.1 对象模型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 私有数据</span></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">         <span class="attr">method</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">             <span class="comment">// 操作私有数据</span></div><div class="line">         &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6-2-函数模型"><a href="#6-2-函数模型" class="headerlink" title="6.2 函数模型"></a>6.2 函数模型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// 私有数据</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">         <span class="comment">// 可以操作私有数据</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="7-沙箱模式（闭包应用的一个典范）"><a href="#7-沙箱模式（闭包应用的一个典范）" class="headerlink" title="7.沙箱模式（闭包应用的一个典范）"></a>7.沙箱模式（闭包应用的一个典范）</h2><h3 id="7-1-沙箱的概念"><a href="#7-1-沙箱的概念" class="headerlink" title="7.1 沙箱的概念"></a>7.1 沙箱的概念</h3><p>沙盘与盒子，就可以在一个笑笑的空间内模拟显示世界，特点是执行效果与现实世界一模一样，但是在沙箱中模拟与现实无关.</p>
<h3 id="7-2-沙箱模式"><a href="#7-2-沙箱模式" class="headerlink" title="7.2 沙箱模式"></a>7.2 沙箱模式</h3><p>沙箱模式就是一个自调用函数，代码写到函数中一样会执行，但是不会与外界有任何的影响</p>
<p>例如，在jQuery中<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 所有的算法 &#125;</span></div><div class="line">   <span class="comment">// .... // .... jQuery.each = function () &#123;&#125;</span></div><div class="line">   <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery;</div><div class="line">&#125;)();</div><div class="line">$.each( ... )</div></pre></td></tr></table></figure></p>
<h2 id="8-带有缓存功能的函数"><a href="#8-带有缓存功能的函数" class="headerlink" title="8.带有缓存功能的函数"></a>8.带有缓存功能的函数</h2><p>以 Fibonacci 数列为例，改进传统计算斐波那契数列方法<br>我们来回顾一下传统递归方式求斐波那契数列方法，我们定义一个count变量来查看递归了多少次：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibo</span>(<span class="params"> n </span>)</span>&#123;</div><div class="line">    count++;</div><div class="line">    <span class="keyword">if</span>( n ==<span class="number">0</span> || n == <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> fibo( n - <span class="number">1</span> ) + fibo( n - <span class="number">2</span> );</div><div class="line">&#125;</div><div class="line">fib1( <span class="number">20</span> );</div><div class="line"><span class="built_in">console</span>.log( count1 );</div><div class="line"><span class="comment">// 5: 15</span></div><div class="line"><span class="comment">// 6: 25</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="comment">// 20: 21891</span></div></pre></td></tr></table></figure>
<p>当 n = 5 式，count = 15，当时当 n = 20 的时候，count就达到惊人的21891次，性能太低了</p>
<p>性能低的原因是 重复计算。如果每次将计算的结果存起来</p>
<ul>
<li>那么每次需要的时候先看看有没有存储过该数据，如果有，直接拿来用。</li>
<li>如果没有再递归，但是计算的结果需要再次存储起来，以便下次使用</li>
</ul>
<p>改进版：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> data = [ <span class="number">1</span>, <span class="number">1</span> ];</div><div class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibo</span>(<span class="params"> n </span>) </span>&#123;</div><div class="line">    count++;</div><div class="line">    <span class="keyword">var</span> v = data[ n ];</div><div class="line">    <span class="keyword">if</span>( v === <span class="literal">undefined</span> )&#123;</div><div class="line">         v = fibo( n - <span class="number">1</span> ) + fibo( n - <span class="number">2</span> );</div><div class="line">         data[ n ] = v;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> v;</div><div class="line">&#125;</div><div class="line">fibo( <span class="number">100</span> );</div><div class="line"><span class="built_in">console</span>.log( count );    <span class="comment">// 199</span></div></pre></td></tr></table></figure></p>
<p>改进之后， n = 100的时候也才199次，大大提高了性能。</p>
<h2 id="9-闭包的性能问题"><a href="#9-闭包的性能问题" class="headerlink" title="9.闭包的性能问题"></a>9.闭包的性能问题</h2><p>函数执行需要内存，那么函数中定义的变量，会在函数执行结束后自动回收，凡是因为闭包结构的，被引出的数据，如果还有变量引用这些数据的话，那么这些数据就不会被回收。</p>
<p>因此在使用闭包的时候如果不适用某学数据了，一定要赋值一个null</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> num = <span class="number">123</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> num;</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div><div class="line"><span class="comment">// f 引用着函数，函数引用着变量num</span></div><div class="line"><span class="comment">// 因此在不适用该数据的时候，最好写上</span></div><div class="line">f = <span class="literal">null</span>;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[进击JavaScript之（二）词法作用域与作用域链]]></title>
      <url>/2016/08/19/%E8%BF%9B%E5%87%BBJavaScript%E4%B9%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
      <content type="html"><![CDATA[<h2 id="一、作用域"><a href="#一、作用域" class="headerlink" title="一、作用域"></a>一、作用域</h2><p>域表示的就是范围，即作用域，就是一个名字在什么地方可以使用，什么时候不能使用。想了解更多关于作用域的问题推荐阅读《你不知道的JavaScript上卷》第一章（或第一部分），从编译原理的角度说明什么是作用域。概括的说作用域就是一套设计良好的规则来存储变量，并且之后可以方便地找到这些变量。<br><a id="more"></a></p>
<h3 id="1-1-块级作用域"><a href="#1-1-块级作用域" class="headerlink" title="1.1 块级作用域"></a>1.1 块级作用域</h3><p>在C、Java、C#等编程语言中，下面的语法报错（伪代码）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">var</span> num = <span class="number">123</span>;</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">console</span>.log( num );    <span class="comment">// num =&gt; 123</span></div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( num );   <span class="comment">//报错</span></div></pre></td></tr></table></figure></p>
<h3 id="1-2-JS的词法作用域"><a href="#1-2-JS的词法作用域" class="headerlink" title="1.2 JS的词法作用域"></a>1.2 JS的词法作用域</h3><p>所谓的词法（代码）作用域，就是代码在编写过程中体现出来的作用范围，代码一旦写好，不用执行，作用范围就已经确定好了，这个就是所谓的词法作用域。</p>
<p>在JS中词法作用域的规则：</p>
<ol>
<li>函数允许访问函数外部的数据</li>
<li>整个代码结构中只有函数可以限定作用域</li>
<li>作用规则首先使用提升规则分析</li>
<li>如果当前作用域中有了名字了，就不考虑外面的名字</li>
</ol>
<p>例子1：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">123</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( num );</div><div class="line">&#125;</div><div class="line">foo();    <span class="comment">//123</span></div></pre></td></tr></table></figure></p>
<p>例子2：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>( <span class="literal">false</span> )&#123;</div><div class="line">    <span class="keyword">var</span> num = <span class="number">123</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( num ); <span class="comment">//undefined</span></div></pre></td></tr></table></figure></p>
<p>例子3：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span>  num = <span class="number">123</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> num = <span class="number">456</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( num );</div><div class="line">     &#125;</div><div class="line">     func();</div><div class="line">&#125;</div><div class="line">foo();    <span class="comment">//456</span></div></pre></td></tr></table></figure></p>
<h2 id="二、作用域链"><a href="#二、作用域链" class="headerlink" title="二、作用域链"></a>二、作用域链</h2><p>只有函数才能制造作用域结构，那么只要是代码，至少有一个作用域，即全局作用域。 </p>
<p>凡是代码中有函数，那么这个函数就构成另一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域，那么将这样的所有作用域列出来，可以有一个结构：函数内指向函数外的链式结构</p>
<p>例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> num = <span class="number">456</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f4</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>作用域链结构与DOM树结构很相似.</p>
<h3 id="2-1-绘制作用域链"><a href="#2-1-绘制作用域链" class="headerlink" title="2.1 绘制作用域链"></a>2.1 绘制作用域链</h3><p>步骤：</p>
<ol>
<li>看整个全局是一条链，即顶级链，记为0级链</li>
<li>看全局作用域中有什么成员声明，就以方格的形式绘制到0级链上</li>
<li>再找函数，只有函数可以限制作用域，因此从函数中引出新链，标记为1级链</li>
<li>然后在每一个1级链中再次往复刚才的行为<br><img src="http://img.mukewang.com/57aeec6800014ac807440440.jpg" alt="图片描述"></li>
</ol>
<h3 id="2-2-变量的访问（搜索）规则"><a href="#2-2-变量的访问（搜索）规则" class="headerlink" title="2.2 变量的访问（搜索）规则"></a>2.2 变量的访问（搜索）规则</h3><ol>
<li>首先看变量在第几条链上，在该链上看是否有变量的定义与赋值，如果有直接使用</li>
<li>如果没有到上一级链上找（ n - 1 级链）,如果有直接使用，停止继续查找。</li>
<li>如果还没有在此往上找… 直到全局链（0级），还没有就是is not defined</li>
<li>注意，切记：同级的链不可混合查找</li>
</ol>
<p>练习： 绘制作用域链</p>
<p>绘制如下程序的作用域链<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> num = <span class="number">123</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( num ); </div><div class="line">     &#125;</div><div class="line">    f2();</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span>  num = <span class="number">456</span>;</div><div class="line">f1();    <span class="comment">//123</span></div></pre></td></tr></table></figure></p>
<p><img src="http://img.mukewang.com/57aeec79000175cb07250232.jpg" alt="图片描述"></p>
<p>函数f1 和变量 num=456， 在0级链，而f1下又可以展开1级链，1级链上有num=123和函数f2。程序f1()调用进入左边1级链，而f1中又调用了f2函数，f2函数中<code>console.log(num)</code>可以看作在2级链，此时，程序会向这一条链向上查找，首先2级链没有num，向上到达1级链，刚好1级链上有num=123，所以就直接使用123，程序最后的结果就是打印123.</p>
<h3 id="2-3-如何分析代码"><a href="#2-3-如何分析代码" class="headerlink" title="2.3 如何分析代码"></a>2.3 如何分析代码</h3><ol>
<li>在分析代码的时候切记从代码的运行角度上来分析，如果代码给变量赋值了，一定要标记到图中</li>
<li>如果代码比较复杂，可以在图中表示代码的内容，有时候还要将原型图与作用域图结合起来分析</li>
</ol>
<p>分析如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">123</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( num );</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> num = <span class="number">456</span>;</div><div class="line">    f1();</div><div class="line">&#125;</div><div class="line">f2();    <span class="comment">//123</span></div></pre></td></tr></table></figure></p>
<p>作用域链图： </p>
<p><img src="http://img.mukewang.com/57aeec83000177e107180335.jpg" alt="图片描述"></p>
<p>首先把num=123，函数f1，函数f2画在0级链上。f1中只有一句console，画出一条1级链，f2也下画出1级链，链上有num=456和函数调用语句f1();</p>
<p>调用f2()，进入f2函数的作用域链，而在f2中又调用了f1函数，程序进入f1的作用域链，所以<code>console.log(num)</code>会在此链上查找是否存在num，没有，继续向上一级链查找，刚好在0级链上找到了num=123，所以f1函数中的<code>console.log(num)</code>就是123.</p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[进击JavaScript之（一）变量声明提升]]></title>
      <url>/2016/08/09/%E8%BF%9B%E5%87%BBJavaScript%E4%B9%8B%EF%BC%88%E4%B8%80%EF%BC%89%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87/</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/68937-4cc0fdff5666ed18.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>如下代码输出的结果是？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">123</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( num );    <span class="comment">//undefined</span></div><div class="line">    <span class="keyword">var</span> num = <span class="number">456</span>;</div><div class="line">   <span class="built_in">console</span>.log( num );    <span class="comment">//456</span></div><div class="line">&#125;</div><div class="line">foo1();</div></pre></td></tr></table></figure></p>
<p>Javascript代码执行分为两个大步：</p>
<p>预解析的过程<br>代码的执行过程  </p>
<h2 id="1-预解析与变量声明提升"><a href="#1-预解析与变量声明提升" class="headerlink" title="1.预解析与变量声明提升"></a>1.预解析与变量声明提升</h2><p>程序在执行过程中，会先将代码读取到内存中检查，会将所有的声明在此进行标记，所谓的标记就是让JS解析器知道有这个名字，后面在使用名字的时候不会出现未定义的错误。这个标记过程就是提升。</p>
<p><strong>声明：</strong></p>
<ol>
<li><p>名字的声明，标识符声明（变量名声明）</p>
<ul>
<li>名字的声明就是让解析器知道有这个名字</li>
<li>名字没有任何数据与之对应</li>
</ul>
</li>
<li><p>函数的声明</p>
<ul>
<li>函数声明包含两部分</li>
<li><p>函数声明与函数表达式有区别，函数声明是单独写在一个结构中，不存在任何语句，逻辑判断等结构中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">&#125; <span class="comment">// 函数声明</span></div><div class="line"><span class="keyword">if</span> ( <span class="literal">true</span> ) &#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func2</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">//函数表达式</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">func3</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">//函数表达式</span></div><div class="line"><span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">//函数表达式</span></div><div class="line"><span class="keyword">var</span> i= <span class="number">1</span>；</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func4</span> (<span class="params"></span>) </span>&#123;&#125;    <span class="comment">// 函数声明</span></div><div class="line">    <span class="keyword">var</span> j = <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p><strong>分析</strong></p>
<ol>
<li><p>预解析代码，提示名字    </p>
<ul>
<li>首先提升名字num</li>
<li>再提升函数名，但是名字已经存在，因此只做第二部，让名字与函数体对应上</li>
<li>结论就是 代码中已经有一个函数 num 了</li>
</ul>
</li>
<li><p>开始执行代码，第一句话从赋值语句开始执行</p>
<ul>
<li>给num赋值为1</li>
<li>覆盖了函数 </li>
</ul>
</li>
<li><p>调用num，由于num中存储的是数组1，因此报错</p>
</li>
</ol>
<h2 id="2-代码分析举例"><a href="#2-代码分析举例" class="headerlink" title="2.代码分析举例"></a>2.代码分析举例</h2><h3 id="程序1"><a href="#程序1" class="headerlink" title="程序1"></a>程序1</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">123</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( num );    <span class="comment">//undefined</span></div><div class="line">    <span class="keyword">var</span> num = <span class="number">456</span>;</div><div class="line">    <span class="built_in">console</span>.log( num );    <span class="comment">//456</span></div><div class="line">&#125;</div><div class="line">foo1();</div></pre></td></tr></table></figure>
<ol>
<li>预解析，提升 num 名字和 foo1 函数</li>
<li>执行第一句话：<code>num = 123;</code></li>
<li>执行函数调用<ul>
<li>函数调用进入函数的一瞬间也要进行预解析，此时解析的是变量名 num</li>
<li>在函数内部是一个独立的空间，允许使用外部的数据，但是现在 num 声明同名，即覆盖外面的</li>
<li>执行第一句 打印num，没有数据，undefined</li>
<li>执行第二句 赋值：num = 456；</li>
<li>执行第三句 打印num，结果456</li>
</ul>
</li>
</ol>
<h3 id="程序2"><a href="#程序2" class="headerlink" title="程序2"></a>程序2</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( ！ <span class="string">'a'</span> <span class="keyword">in</span> <span class="built_in">window</span> ) &#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">123</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( a );</div></pre></td></tr></table></figure>
<ol>
<li>预解析，读取提升a，有一个名字a 存在了</li>
<li>in 运算符：判断某一个字符串描述的属性名是否在对象中<ul>
<li>var o = { name:’jim’ }; ‘name’ in o，’age’ in o</li>
<li>执行第一个判断：! ‘a’ in window</li>
</ul>
<ul>
<li>‘a’ in window 结果为真</li>
<li>！得到假</li>
</ul>
<ul>
<li>if内部的赋值不进行</li>
</ul>
</li>
<li>打印结果 a 的值为 undefined  </li>
</ol>
<h3 id="程序3"><a href="#程序3" class="headerlink" title="程序3"></a>程序3</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( <span class="literal">false</span> ) &#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f1</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">'true'</span> );</div><div class="line">     &#125;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f1</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( <span class="string">'false'</span> );</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line">f1();</div></pre></td></tr></table></figure>
<ol>
<li>预解析：提升 f1 函数，只保留提升后的内容，所以打印是 false</li>
<li><p>执行代码，第一句话就是一个空的if结构  </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if ( true ) &#123;</div><div class="line">&#125; else &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>执行函数调用，得到 false    </p>
</li>
</ol>
<h2 id="3-问题"><a href="#3-问题" class="headerlink" title="3.问题"></a>3.问题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) &#125; </span>&#123;&#125;</div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div></pre></td></tr></table></figure>
<ol>
<li>上面的语法是声明，可以提升，因此在函数上方也可以调用</li>
<li>下面的语法是函数表达式，函数名就是foo ，他会提升，提升的不是函数体</li>
<li><p>函数表达式也是支持名字语法</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var foo = function func1 () &#123;&#125;;</div><div class="line">func();</div></pre></td></tr></table></figure>
</li>
<li><p>函数有一个属性name，表示的是函数名，只有带有名字的函数定义，才会有name属性值，否则是“”</p>
<ul>
<li>但是，函数表达式的名字，只允许在函数内部使用，IE8可以访问</li>
<li>（）可以将数据转化为表达式</li>
</ul>
</li>
</ol>
<p>新的浏览器中，写在if、while、do..while结构中的函数，都会将函数的声明转换成特殊的函数表达式<br>将代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (...) &#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>转换成<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (...) &#123;</div><div class="line">    <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123; .... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTML5 VideoAPI，打造自己的Web视频播放器]]></title>
      <url>/2016/08/04/HTML5-VideoAPI%EF%BC%8C%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84Web%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本文将使用HTML5提供的VideoAPI做一个自定义的视频播放器，需要用到HTML5提供的video标签、以及HTML5提供的对JavascriptAPI的扩展。<br><a id="more"></a><br><img src="http://upload-images.jianshu.io/upload_images/68937-2499781ec1b7afb2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="video.jpg"></p>
</blockquote>
<h2 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h2><h3 id="1-用法"><a href="#1-用法" class="headerlink" title="1.用法"></a>1.用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;video src=&quot;./video/mv.mp4&quot;&gt;&lt;/video&gt;</div></pre></td></tr></table></figure>
<p>注意：audio和video元素必须同时包含开始和结束标签，不能使用<code>&lt;audio /&gt;</code>这样的空元素语法形式。</p>
<h3 id="2-重要HTML属性"><a href="#2-重要HTML属性" class="headerlink" title="2.重要HTML属性"></a>2.重要HTML属性</h3><p><strong>controls</strong>：ontrol：如果出现该属性，则向用户显示控件，比如播放按钮。每个浏览器中的播放控件都不太一样，但用途都一样，都可以控制开始和结束，跳到新位置和调节音量<br><strong>autoplay</strong>：autoplay：如果出现该属性，则视频在就绪后马上播放。如果不设置autoplay属性，必须是用户单击播放按钮才会播放音频文件。<br><strong>loop</strong>：loop：(循环播放)告诉浏览器在音频到达末尾时，再从头开始重新播放<br><strong>preload</strong>：auto、mete、none：告诉浏览器如何下载音频  </p>
<ul>
<li>auto：让浏览器下载整个文件，以便用户单击播放按钮时就能播放。当然，下载过程是后台进行的，网页访客不必等待下载完成，而且仍然可以随意查看网页。</li>
<li>meta：告诉浏览器先获取音频文件开头的数据块，从而足以确定一些基本信息（比如音频的总时长） </li>
<li>none：**告诉浏览器不必预先下载。恰当地利用这些值，可以节省带宽。</li>
</ul>
<p>如果没有设置preload属性，浏览器就自己决定是否预先下载了。对这一点，不同浏览器的处理方式也不一样。多数浏览器将auto作为默认值，但Firefox的默认值是metadata。不过，也请大家注意，这个preload属性也不是必须严格执行的规则，而只是你对浏览器的建议。根据具体情况，浏览器可以忽略你的设置。（有些旧版本浏览器根据不会在意preload属性。）</p>
<h3 id="3-常用事件"><a href="#3-常用事件" class="headerlink" title="3.常用事件"></a>3.常用事件</h3><p>事件名称 ： 解释<br><strong>oncanplay</strong>：当文件就绪可以开始播放时运行的脚本（缓冲已足够开始时）。<br><strong>ontimeupdate</strong>： 当播放位置改变时（比如当用户快进到媒介中一个不同的位置时）运行的脚本。<br><strong>onended</strong>：当媒介已到达结尾时运行的脚本（可发送类似“感谢观看”之类的消息）。    </p>
<h3 id="4-常用方法"><a href="#4-常用方法" class="headerlink" title="4.常用方法"></a>4.常用方法</h3><p>方法名称 ：解释<br><strong>play()</strong>：开始播放音频/视频<br><strong>pause()</strong>：暂停当前播放的音频/视频    </p>
<h3 id="5-常用API属性"><a href="#5-常用API属性" class="headerlink" title="5.常用API属性"></a>5.常用API属性</h3><p>属性名称 ： 解释<br><strong>duration</strong>：返回当前音频/视频的长度（以秒计）<br><strong>paused</strong>：设置或返回音频/视频是否暂停<br><strong>currentTime</strong>：设置或返回音频/视频中的当前播放位置（以秒计）<br><strong>ended</strong>：返回音频/视频的播放是否已结束    </p>
<p>更多属性、事件、方法请查看<a href="http://www.w3school.com.cn/tags/html_ref_audio_video_dom.asp" target="_blank" rel="external">w3school</a></p>
<h2 id="二、打造自己的播放器"><a href="#二、打造自己的播放器" class="headerlink" title="二、打造自己的播放器"></a>二、打造自己的播放器</h2><p>我们使用JavaScript控制播放控件的行为（自定义播放控件），实现如下功能：</p>
<ul>
<li>利用HTML+CSS制作一个自己的播放控件条，然后定位到视频最下方</li>
<li>视频加载loading效果</li>
<li>播放、暂停</li>
<li>总时长和当前播放时长显示</li>
<li>播放进度条</li>
<li>全屏显示</li>
</ul>
<h3 id="1-播放控件"><a href="#1-播放控件" class="headerlink" title="1.播放控件"></a>1.播放控件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>视频播放器<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"player"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"./video/mv.mp4"</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"controls"</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!-- 播放/暂停 --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span> <span class="attr">class</span>=<span class="string">"switch fa fa-play"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!-- 全屏 --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span> <span class="attr">class</span>=<span class="string">"expand fa fa-expand"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!-- 进度条 --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"progress"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"loaded"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"line"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!-- 时间 --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"timer"</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"current"</span>&gt;</span>00:00:00<span class="tag">&lt;/<span class="name">span</span>&gt;</span> /</div><div class="line">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"total"</span>&gt;</span>00:00:00<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!-- 声音 --&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></div></pre></td></tr></table></figure>
<p>上面是全部HTML代码，<code>.controls</code>类就是播放控件HTML，引用CSS代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./css/font-awesome.css"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./css/player.css"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>为了显示播放按钮等图标我使用了字体图标</p>
<h3 id="2-视频加载loading效果"><a href="#2-视频加载loading效果" class="headerlink" title="2.视频加载loading效果"></a>2.视频加载loading效果</h3><p>一开始先隐藏视频，用一个背景图片替代，等到视频加载完成可以播放时在显示视频<br>CSS：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.player</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">720px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">360px</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#000</span> <span class="built_in">url</span>(../images/loading.gif) center/<span class="number">300px</span> no-repeat;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="selector-tag">video</span> &#123;</div><div class="line">    <span class="attribute">display</span>: none;</div><div class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-播放功能"><a href="#3-播放功能" class="headerlink" title="3.播放功能"></a>3.播放功能</h3><p>让我们开始写javascript代码吧，首先我们先获取要用到的DOM元素：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> video = <span class="built_in">document</span>.querySelector(<span class="string">"video"</span>);</div><div class="line"><span class="keyword">var</span> isPlay = <span class="built_in">document</span>.querySelector(<span class="string">".switch"</span>);</div><div class="line"><span class="keyword">var</span> expand = <span class="built_in">document</span>.querySelector(<span class="string">".expand"</span>);</div><div class="line"><span class="keyword">var</span> progress = <span class="built_in">document</span>.querySelector(<span class="string">".progress"</span>);</div><div class="line"><span class="keyword">var</span> loaded = <span class="built_in">document</span>.querySelector(<span class="string">".progress &gt; .loaded"</span>);</div><div class="line"><span class="keyword">var</span> currPlayTime = <span class="built_in">document</span>.querySelector(<span class="string">".timer &gt; .current"</span>);</div><div class="line"><span class="keyword">var</span> totalTime = <span class="built_in">document</span>.querySelector(<span class="string">".timer &gt; .total"</span>);</div></pre></td></tr></table></figure></p>
<p>当视频可以播放时，显示视频<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//当视频可播放的时候</span></div><div class="line">video.oncanplay = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="comment">//显示视频</span></div><div class="line">      <span class="keyword">this</span>.style.display = <span class="string">"block"</span>;</div><div class="line">      <span class="comment">//显示视频总时长</span></div><div class="line">      totalTime.innerHTML = getFormatTime(<span class="keyword">this</span>.duration);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="4-播放、暂停"><a href="#4-播放、暂停" class="headerlink" title="4.播放、暂停"></a>4.播放、暂停</h3><p>点击播放按钮时显示暂停图标，在播放和暂停状态之间切换图标<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//播放按钮控制</span></div><div class="line">isPlay.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(video.paused) &#123;</div><div class="line">            video.play();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            video.pause();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.classList.toggle(<span class="string">"fa-pause"</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="5-总时长和当前播放时长显示"><a href="#5-总时长和当前播放时长显示" class="headerlink" title="5.总时长和当前播放时长显示"></a>5.总时长和当前播放时长显示</h3><p>前面代码中其实已经设置了相关代码，此时我们只需要把获取到的毫秒数转换成我们需要的时间格式即可，提供<code>getFormatTime()</code>函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFormatTime</span>(<span class="params">time</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> time = time  <span class="number">0</span>;</div><div class="line"> </div><div class="line">        <span class="keyword">var</span> h = <span class="built_in">parseInt</span>(time/<span class="number">3600</span>),</div><div class="line">            m = <span class="built_in">parseInt</span>(time%<span class="number">3600</span>/<span class="number">60</span>),</div><div class="line">            s = <span class="built_in">parseInt</span>(time%<span class="number">60</span>);</div><div class="line">        h = h &lt; <span class="number">10</span> ? <span class="string">"0"</span>+h : h;</div><div class="line">        m = m &lt; <span class="number">10</span> ? <span class="string">"0"</span>+m : m;</div><div class="line">        s = s &lt; <span class="number">10</span> ? <span class="string">"0"</span>+s : s;</div><div class="line"> </div><div class="line">        <span class="keyword">return</span> h+<span class="string">":"</span>+m+<span class="string">":"</span>+s;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="6-播放进度条"><a href="#6-播放进度条" class="headerlink" title="6.播放进度条"></a>6.播放进度条</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//播放进度</span></div><div class="line">video.ontimeupdate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> currTime = <span class="keyword">this</span>.currentTime,    <span class="comment">//当前播放时间</span></div><div class="line">    duration = <span class="keyword">this</span>.duration;       <span class="comment">// 视频总时长</span></div><div class="line">    <span class="comment">//百分比</span></div><div class="line">    <span class="keyword">var</span> pre = currTime / duration * <span class="number">100</span> + <span class="string">"%"</span>;</div><div class="line">    <span class="comment">//显示进度条</span></div><div class="line">    loaded.style.width = pre;</div><div class="line"> </div><div class="line">     <span class="comment">//显示当前播放进度时间</span></div><div class="line">    currPlayTime.innerHTML = getFormatTime(currTime);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样就可以实时显示进度条了，此时，我们还需要点击进度条进行跳跃播放，即我们点击任意时间点视频跳转到当前时间点播放：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//跳跃播放</span></div><div class="line">progress.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> event = e  <span class="built_in">window</span>.event;</div><div class="line">    video.currentTime = (event.offsetX / <span class="keyword">this</span>.offsetWidth) * video.duration;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="7-全屏显示"><a href="#7-全屏显示" class="headerlink" title="7.全屏显示"></a>7.全屏显示</h3><p>这个功能可以使用HTML5提供的全局API：<code>webkitRequestFullScreen</code>实现，跟<code>video</code>无关：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//全屏</span></div><div class="line">expand.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">     video.webkitRequestFullScreen();</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><a href="http://dunizb.com/demo/html-css/HTML5%E8%A7%86%E9%A2%91API%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/">完整示例和源码请点这里</a><br><a href="https://github.com/dunizb/CodeTest/tree/master/HTML%26CSS/html5/%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8" target="_blank" rel="external">github</a></p>
<p>经测试在firefox、IE下全屏功能不可用，这样正常了，全屏API是针对webkit内核的。</p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTML5 </tag>
            
            <tag> HTML </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS3聊天气泡框以及inherit、currentColor关键字]]></title>
      <url>/2016/07/20/CSS3%E8%81%8A%E5%A4%A9%E6%B0%94%E6%B3%A1%E6%A1%86%E4%BB%A5%E5%8F%8Ainherit%E3%80%81currentColor%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/68937-8642008c12f3ddf0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="聊天气泡框"><br>效果如上图所示，主要用到CSS3的伪类<code>::after</code>、<code>::before</code>，以及圆角边框<code>border-radius</code>属性。对于下面的气泡框，可以有两种方式实现小三角：</p>
<ul>
<li>传统方式，利用CSS画小三角，利用到了透明背景和边框属性<code>transparent</code>的应用。</li>
<li>CSS3的<code>transform</code>属性的使用</li>
</ul>
<p>然后通过<code>position</code>定位到合适的位置。</p>
<p>此外，本文还会讲一下CSS的<code>inherit</code>属性值的知识。</p>
<h2 id="实现气泡框"><a href="#实现气泡框" class="headerlink" title="实现气泡框"></a>实现气泡框</h2><p>HTML结果也很简单，就一个DIV。下三角部分使用了CSS画三角的知识，<br>HTML：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"message1"</span>&gt;</span></div><div class="line">    Demos 代码演示、代码片段 - 读你，欢迎来到读你，http://dunizb.com/demo/</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"> </div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"message2"</span>&gt;</span></div><div class="line">    Demos 代码演示、代码片段 - 读你，欢迎来到读你，http://dunizb.com/demo/</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>CSS：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.message1</span>,<span class="selector-class">.message2</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">80px</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">100px</span> auto;</div><div class="line">    <span class="attribute">background-color</span>: green;</div><div class="line">    <span class="attribute">border-bottom-color</span>:green;<span class="comment">/*为了给after伪元素自动继承*/</span></div><div class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</div><div class="line">    <span class="attribute">font-family</span>: Arial;</div><div class="line">    <span class="attribute">line-height</span>: <span class="number">18px</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">12px</span> <span class="number">5px</span> <span class="number">12px</span>;</div><div class="line">    <span class="attribute">box-sizing</span>: border-box;</div><div class="line">    <span class="attribute">border-radius</span>: <span class="number">6px</span>;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">word-break</span>: break-all;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.message1</span><span class="selector-pseudo">::after</span> &#123;</div><div class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">right</span>: -<span class="number">24px</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">border-width</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">20px</span> <span class="number">20px</span>;</div><div class="line">    <span class="attribute">border-style</span>: solid;</div><div class="line">    <span class="attribute">border-bottom-color</span>: inherit;   <span class="comment">/*自动继承父元素的border-bottom-color*/</span></div><div class="line">    <span class="attribute">border-left-color</span>: transparent;</div><div class="line">    <span class="attribute">border-radius</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">60px</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/** 通过对小正方形旋转45度解决 **/</span></div><div class="line"><span class="selector-class">.message2</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</div><div class="line">    <span class="attribute">left</span>: -<span class="number">5px</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">10px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">10px</span>;</div><div class="line">    <span class="attribute">margin-top</span>: -<span class="number">10px</span>;</div><div class="line">    <span class="attribute">background</span>: inherit;<span class="comment">/*自动继承父元素的背景*/</span></div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(45deg);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** 通过画三角形解决 */</span></div><div class="line"><span class="comment">/*.message2::before &#123;*/</span></div><div class="line">    <span class="comment">/*content: '';*/</span></div><div class="line">    <span class="comment">/*position: absolute;*/</span></div><div class="line">    <span class="comment">/*top: 50%;*/</span></div><div class="line">    <span class="comment">/*left: -20px;*/</span></div><div class="line">    <span class="comment">/*width: 0px;*/</span></div><div class="line">    <span class="comment">/*height: 0px;*/</span></div><div class="line">    <span class="comment">/*margin-top: -10px;*/</span></div><div class="line">    <span class="comment">/*border-width: 10px;*/</span></div><div class="line">    <span class="comment">/*border-style: solid;*/</span></div><div class="line">    <span class="comment">/*border-color: transparent green transparent transparent;*/</span></div><div class="line"><span class="comment">/*&#125;*/</span></div></pre></td></tr></table></figure></p>
<p>以上就是全部代码。<br>上面对小正方形使用了inherit属性值，通过把正方形旋转45度形成对外的三角而得到。</p>
<h2 id="被刻意遗忘的inherit关键字"><a href="#被刻意遗忘的inherit关键字" class="headerlink" title="被刻意遗忘的inherit关键字"></a>被刻意遗忘的inherit关键字</h2><p>尽管绝大多数人都知道inherit这个关键字，但是很多人可能自始自终都没实际用过它，包括我自己，从来没有，在查询CSS文档时，习惯性的忽略它，直到看到《CSS揭秘》这本书。</p>
<p><code>inherit</code>可以用在任何CSS属性中，这从w3cschool文档中就已经体现了，它总是绑定到父元素的计算值（对伪元素来说，则会取生成该伪元素的宿主元素）。举例来说，要把表单元素的字体设定为与页面的其他部分相同，你并不需要重复指定字体属性，只需要利用<code>inherit</code>的特性即可：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">input</span>,<span class="selector-tag">select</span>,<span class="selector-tag">button</span> &#123; <span class="attribute">font</span>: inherit &#125;</div></pre></td></tr></table></figure></p>
<p>与此类似，要把超链接的颜色设定为与页面中其他文本相同，还是要用<code>inherir</code>，比如下面的代码：<br>HTML：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Demos 代码演示、代码片段 - 读你 | 这世间唯有梦想和好姑娘不可辜负!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://dunizb.com/demo/"</span>&gt;</span>Demos<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>CSS：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.article</span> &#123;</div><div class="line">      <span class="attribute">font-family</span>: <span class="string">"Microsoft YaHei"</span>;</div><div class="line">      <span class="attribute">font-size</span>: <span class="number">14px</span>;</div><div class="line">      <span class="attribute">color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果：<br><img src="http://upload-images.jianshu.io/upload_images/68937-a04e98b56c9d710c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"><br>此时文字的颜色是红色，而超链接默认是蓝色，并不会被改变，这是我们都知道的，那么我想让超链接也是跟父元素一样的红色呢？此时我们只需要给超链接inherit即可：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.article</span> <span class="selector-tag">a</span> &#123; <span class="attribute">color</span>: inherit; &#125;</div></pre></td></tr></table></figure>
<p>效果：<br><img src="http://upload-images.jianshu.io/upload_images/68937-e8fd4165783bd2ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"><br>这个inherit对于背景色相同非常有用，但是需要注意的是，想要子元素设置属性的inherit关键字生效，父元素必须设置过使用inherit为值的属性。</p>
<h2 id="CSS3的currentColor关键字"><a href="#CSS3的currentColor关键字" class="headerlink" title="CSS3的currentColor关键字"></a>CSS3的currentColor关键字</h2><p>与之类似的还有一个新的CSS颜色属性：<code>currentColor</code>。这个属性是在CSS颜色（第三版）规范中新增加的，它是从SVG那里借鉴过来的，这个关键字并没有绑定到一个固定的颜色值，而是一直被解析为color。实际上，这是CSS中有史以来第一个变量，虽然功能很有限，但它真的是个变量。</p>
<p>举个例子，假如我们想让所有的水平分割线（所有<code>&lt;hr&gt;</code>元素）自动与文本颜色保持一致。</p>
<p>例如在上面的例子中添加水平线：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.article</span> <span class="selector-tag">hr</span> &#123;</div><div class="line">      <span class="attribute">height</span>: .<span class="number">5em</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>默认情况下是这样的：<br><img src="http://upload-images.jianshu.io/upload_images/68937-8e8dd2704af71755.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"><br> 此时，添加 <code>currentColor</code><br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.article</span> <span class="selector-tag">hr</span> &#123;</div><div class="line">      <span class="attribute">height</span>: .<span class="number">5em</span>;</div><div class="line">      <span class="attribute">background</span>: currentColor;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>效果：<br><img src="http://upload-images.jianshu.io/upload_images/68937-d17333924adecaf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.png"><br>当我在把文字颜色设为蓝色的时候，它们会保持跟文字颜色一致</p>
<p><a href="http://dunizb.com/demo/view.html?url=./list/CSS3%E8%BE%B9%E6%A1%86%E6%95%88%E6%9E%9C%E5%A4%A7%E5%85%A8.html">更多CSS3边框特效，请查看该页面</a></p>
<hr>
<p><strong>参考资料：</strong><br>《CSS解密》[美]Lea Verou (作者) ，[中]CSS魔法 (译者)，图灵教育，人民有点出版社</p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[书写高质量jQuery代码的12条经验]]></title>
      <url>/2016/07/15/%E4%B9%A6%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FjQuery%E4%BB%A3%E7%A0%81%E7%9A%8412%E6%9D%A1%E7%BB%8F%E9%AA%8C/</url>
      <content type="html"><![CDATA[<h1 id="1、正确引用jQuery"><a href="#1、正确引用jQuery" class="headerlink" title="1、正确引用jQuery"></a>1、正确引用jQuery</h1><ol>
<li>尽量在body结束前才引入jQuery，而不是在head中。</li>
<li>借助第三方提供的CDN来引入jQuery，同时注意当使用第三方CDN出现问题时，要引入本地的jQuery文件。</li>
<li>如果在前引入script文件的话，就不用写document.ready了，因为这时执行js代码时DOM已经加载完毕了。<a id="more"></a>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </div><div class="line">     <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://lib.sinaapp.com/js/jquery11/1.8/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </div><div class="line">     <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">window</span>.jQuery || <span class="built_in">document</span>.write(<span class="string">'&lt;script src="jquery1.8.min.js"&gt;\x3C/script&gt;'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="2、优化jQuery选择器"><a href="#2、优化jQuery选择器" class="headerlink" title="2、优化jQuery选择器"></a>2、优化jQuery选择器</h1><p>高效正确的使用jQuery选择器是熟练使用jQuery的基础，而掌握jQuery选择器需要一定的时间积累，我们开始学习jQuery时就应该注意选择器的使用。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"nav"</span> <span class="attr">class</span>=<span class="string">"nav"</span>&gt;</span> </div><div class="line">     <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"home"</span> <span class="attr">href</span>=<span class="string">"http://www.jquery001.com"</span>&gt;</span>jQuery学习网<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </div><div class="line">     <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"articles"</span> <span class="attr">href</span>=<span class="string">"http://www.jquery001.com/articles/"</span>&gt;</span>jQuery教程<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>如果我们选择class为home的a元素时，可以使用下边代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'.home'</span>); <span class="comment">//1 </span></div><div class="line">$(<span class="string">'#nav a.home'</span>); <span class="comment">//2 </span></div><div class="line">$(<span class="string">'#nav'</span>).find(<span class="string">'a.home'</span>); <span class="comment">//3</span></div></pre></td></tr></table></figure></p>
<p>方法1，会使jQuery在整个DOM中查找class为home的a元素，性能可想而知。<br>方法2，为要查找的元素添加了上下文，在这里变为查找id为nav的子元素，查找性能得到了很大提升。<br>方法3，使用了find方法，它的速度更快，所以方法三最好。<br>关于jQuery选择器的性能优先级，ID选择器快于元素选择器，元素选择器快于class选择器。因为ID选择器和元素选择器是原生的JavaScript操作，而类选择器不是，大家顺便可以看下find context 区别，find() children区别。</p>
<h3 id="2-1、一些规则"><a href="#2-1、一些规则" class="headerlink" title="2.1、一些规则"></a>2.1、一些规则</h3><ul>
<li>CSS解析引擎将自右向左计算每一条规则，它从关键选择器开始，自右向左计算每一个选择器，直到发现一个匹配的选择器，如果没有找到匹配的选择器则放弃查找。</li>
<li>使用较低层的规则通常更有效率。</li>
<li>尽可能的具体化的选择器——ID要比tag更好。</li>
<li>避免不必要的冗余。</li>
</ul>
<p>通常请情况下，请保持选择器简单明了（比如充分使用ID选择器），尽可能的使用关键选择器更具体，无论对JavaScript还是CSS，这都可以加块网站的速度。到目前为止，无论使用哪一种浏览器，使用ID选择器和当个类选择器都是选中元素最快的方式。</p>
<h3 id="2-2、避免多个ID选择符"><a href="#2-2、避免多个ID选择符" class="headerlink" title="2.2、避免多个ID选择符"></a>2.2、避免多个ID选择符</h3><p>Id选择符应该是唯一的，所以没有必要添加额外的选择符。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 糟糕</span></div><div class="line">$(<span class="string">'div#myid'</span>);</div><div class="line">$(<span class="string">'div#footer a.myLink'</span>);</div><div class="line"><span class="comment">// 建议</span></div><div class="line">$(<span class="string">'#myid'</span>);</div><div class="line">$(<span class="string">'#footer .myLink'</span>);</div></pre></td></tr></table></figure></p>
<p>在此强调，ID 选择符应该是唯一的，不需要添加额外的选择符，更不需要多个后代ID选择符。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 糟糕</span></div><div class="line">$(<span class="string">'#outer #inner'</span>);</div><div class="line"><span class="comment">// 建议</span></div><div class="line">$(<span class="string">'#inner'</span>);</div></pre></td></tr></table></figure></p>
<h3 id="2-3、避免隐式通用选择符"><a href="#2-3、避免隐式通用选择符" class="headerlink" title="2.3、避免隐式通用选择符"></a>2.3、避免隐式通用选择符</h3><p>通用选择符有时是隐式的，不容易发现。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 糟糕</span></div><div class="line">$(<span class="string">'.someclass :radio'</span>);</div><div class="line"><span class="comment">// 建议</span></div><div class="line">$(<span class="string">'.someclass input:radio'</span>);</div></pre></td></tr></table></figure></p>
<h3 id="2-4、避免通用选择符"><a href="#2-4、避免通用选择符" class="headerlink" title="2.4、避免通用选择符"></a>2.4、避免通用选择符</h3><p>将通用选择符放到后代选择符中，性能非常糟糕。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 糟糕</span></div><div class="line">$(<span class="string">'.container &gt; *'</span>);</div><div class="line"><span class="comment">// 建议</span></div><div class="line">$(<span class="string">'.container'</span>).children();</div></pre></td></tr></table></figure></p>
<h3 id="2-5、选择捷径"><a href="#2-5、选择捷径" class="headerlink" title="2.5、选择捷径"></a>2.5、选择捷径</h3><p>精简代码的其中一种方式是利用编码捷径。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 糟糕</span></div><div class="line"><span class="keyword">if</span>(collection.length &gt; <span class="number">0</span>)&#123;..&#125;</div><div class="line"><span class="comment">// 建议</span></div><div class="line"><span class="keyword">if</span>(collection.length)&#123;..&#125;</div></pre></td></tr></table></figure></p>
<h3 id="2-6、为选择器指定上下文"><a href="#2-6、为选择器指定上下文" class="headerlink" title="2.6、为选择器指定上下文"></a>2.6、为选择器指定上下文</h3><p>默认情况下，当把一个选择器传递给jQuery时，它将遍历整个DOM，jQuery方法还具有一个未充分利用的参数，既可以将一个上下文参数传入jQuery，以限制它只搜索DOM中特定的一部分。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//糟糕，会遍历整个DOM</span></div><div class="line">$(<span class="string">".class"</span>);</div><div class="line"><span class="comment">//建议，只搜索#id元素</span></div><div class="line">$(<span class="string">".class"</span>,<span class="string">"#id"</span>);</div></pre></td></tr></table></figure></p>
<p>jQuery选择器的性能比较：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">".class"</span>,<span class="string">"#id"</span>) &gt; $(<span class="string">"#id .class"</span>) &gt; $(<span class="string">".class"</span>)</div></pre></td></tr></table></figure></p>
<h1 id="3、缓存jQuery对象"><a href="#3、缓存jQuery对象" class="headerlink" title="3、缓存jQuery对象"></a>3、缓存jQuery对象</h1><p>缓存jQuery对象可以减少不必要的DOM查找，关于这点大家可以参考下缓存jQuery对象来提高性能。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 糟糕</span></div><div class="line">h = $(<span class="string">'#element'</span>).height();</div><div class="line">$(<span class="string">'#element'</span>).css(<span class="string">'height'</span>,h<span class="number">-20</span>);</div><div class="line"><span class="comment">// 建议</span></div><div class="line">$element = $(<span class="string">'#element'</span>);</div><div class="line">h = $element.height();</div><div class="line">$element.css(<span class="string">'height'</span>,h<span class="number">-20</span>);</div></pre></td></tr></table></figure></p>
<h3 id="3-1、使用子查询缓存的父元素"><a href="#3-1、使用子查询缓存的父元素" class="headerlink" title="3.1、使用子查询缓存的父元素"></a>3.1、使用子查询缓存的父元素</h3><p>正如前面所提到的，DOM遍历是一项昂贵的操作。典型做法是缓存父元素并在选择子元素时重用这些缓存元素。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 糟糕</span></div><div class="line"><span class="keyword">var</span></div><div class="line">    $container = $(<span class="string">'#container'</span>),</div><div class="line">    $containerLi = $(<span class="string">'#container li'</span>),</div><div class="line">    $containerLiSpan = $(<span class="string">'#container li span'</span>);</div><div class="line"><span class="comment">// 建议 (高效)</span></div><div class="line"><span class="keyword">var</span></div><div class="line">    $container = $(<span class="string">'#container '</span>),</div><div class="line">    $containerLi = $container.find(<span class="string">'li'</span>),</div><div class="line">    $containerLiSpan= $containerLi.find(<span class="string">'span'</span>);</div></pre></td></tr></table></figure></p>
<h1 id="4、变量"><a href="#4、变量" class="headerlink" title="4、变量"></a>4、变量</h1><h3 id="4-1、避免全局变量"><a href="#4-1、避免全局变量" class="headerlink" title="4.1、避免全局变量"></a>4.1、避免全局变量</h3><p>jQuery与javascript一样，一般来说,最好确保你的变量在函数作用域内。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 糟糕</span></div><div class="line">$element = $(<span class="string">'#element'</span>);</div><div class="line">h = $element.height();</div><div class="line">$element.css(<span class="string">'height'</span>,h<span class="number">-20</span>);</div><div class="line"><span class="comment">// 建议</span></div><div class="line"><span class="keyword">var</span> $element = $(<span class="string">'#element'</span>);</div><div class="line"><span class="keyword">var</span> h = $element.height();</div><div class="line">$element.css(<span class="string">'height'</span>,h<span class="number">-20</span>);</div></pre></td></tr></table></figure></p>
<h3 id="4-2、使用匈牙利命名法"><a href="#4-2、使用匈牙利命名法" class="headerlink" title="4.2、使用匈牙利命名法"></a>4.2、使用匈牙利命名法</h3><p>在变量前加$前缀，便于识别出jQuery对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 糟糕</span></div><div class="line"><span class="keyword">var</span> first = $(<span class="string">'#first'</span>);</div><div class="line"><span class="keyword">var</span> second = $(<span class="string">'#second'</span>);</div><div class="line"><span class="keyword">var</span> value = $first.val();</div><div class="line"><span class="comment">// 建议 - 在jQuery对象前加$前缀</span></div><div class="line"><span class="keyword">var</span> $first = $(<span class="string">'#first'</span>);</div><div class="line"><span class="keyword">var</span> $second = $(<span class="string">'#second'</span>),</div><div class="line"><span class="keyword">var</span> value = $first.val();</div></pre></td></tr></table></figure></p>
<h3 id="4-3、使用-Var-链（单-Var-模式）"><a href="#4-3、使用-Var-链（单-Var-模式）" class="headerlink" title="4.3、使用 Var 链（单 Var 模式）"></a>4.3、使用 Var 链（单 Var 模式）</h3><p>将多条var语句合并为一条语句，我建议将未赋值的变量放到后面。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $first = $(<span class="string">'#first'</span>),</div><div class="line">      $second = $(<span class="string">'#second'</span>),</div><div class="line">      value = $first.val(),</div><div class="line">      k = <span class="number">3</span>,</div><div class="line">      cookiestring = <span class="string">'SOMECOOKIESPLEASE'</span>,</div><div class="line">      i,</div><div class="line">      j,</div><div class="line">      myArray = &#123;&#125;;</div></pre></td></tr></table></figure></p>
<h1 id="5、正确使用事件委托"><a href="#5、正确使用事件委托" class="headerlink" title="5、正确使用事件委托"></a>5、正确使用事件委托</h1><p>在新版jQuery中，更短的 <code>on(“click”)</code> 用来取代类似 click() 这样的函数。在之前的版本中 <code>on()</code> 就是 <code>bind()</code>。自从jQuery 1.7版本后，on() 附加事件处理程序的首选方法。然而，出于一致性考虑，你可以简单的全部使用 <code>on()</code>方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;table id=<span class="string">"t"</span>&gt; </div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span> </span></div><div class="line">         <span class="tag">&lt;<span class="name">td</span>&gt;</span>我是单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span> </div><div class="line">   <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>  </div><div class="line">&lt;<span class="regexp">/table&gt;</span></div></pre></td></tr></table></figure></p>
<p>比如我们要在上边的单元格上绑定一个单击事件，不注意的朋友可能随手写成下边的样子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#t'</span>).find(<span class="string">'td'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </div><div class="line">     $(<span class="keyword">this</span>).css(&#123; <span class="string">'color'</span>: <span class="string">'red'</span>, <span class="string">'background'</span>: <span class="string">'yellow'</span> &#125;); </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这样会为每个td绑上事件，在为100个单元格绑定click事件的测试中，两者性能相差7倍之多，好的做法应该是下边写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#t'</span>).on(<span class="string">'click'</span>, <span class="string">'td'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </div><div class="line">    $(<span class="keyword">this</span>).css(&#123; <span class="string">'color'</span>: <span class="string">'red'</span>, <span class="string">'background'</span>: <span class="string">'yellow'</span> &#125;); </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="6、精简jQuery代码"><a href="#6、精简jQuery代码" class="headerlink" title="6、精简jQuery代码"></a>6、精简jQuery代码</h1><p>如在上述代码中我们对jQuery代码进行了适当的合并，类似的还有.attr()方法等，我们没有写成下边的方式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#t'</span>).on(<span class="string">'click'</span>, <span class="string">'td'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </div><div class="line">    $(<span class="keyword">this</span>).css(<span class="string">'color'</span>, <span class="string">'red'</span>).css(<span class="string">'background'</span>, <span class="string">'yellow'</span>); </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="6-1、合并函数"><a href="#6-1、合并函数" class="headerlink" title="6.1、合并函数"></a>6.1、合并函数</h3><p>一般来说,最好尽可能合并函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 糟糕</span></div><div class="line">$first.click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    $first.css(<span class="string">'border'</span>,<span class="string">'1px solid red'</span>);</div><div class="line">    $first.css(<span class="string">'color'</span>,<span class="string">'blue'</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 建议</span></div><div class="line">$first.on(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    $first.css(&#123;</div><div class="line">        <span class="string">'border'</span>:<span class="string">'1px solid red'</span>,</div><div class="line">        <span class="string">'color'</span>:<span class="string">'blue'</span></div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="6-2、链式操作"><a href="#6-2、链式操作" class="headerlink" title="6.2、链式操作"></a>6.2、链式操作</h3><p>jQuery实现方法的链式操作是非常容易的。下面利用这一点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 糟糕</span></div><div class="line">$second.html(value);</div><div class="line">$second.on(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">'hello everybody'</span>);</div><div class="line">&#125;);</div><div class="line">$second.fadeIn(<span class="string">'slow'</span>);</div><div class="line">$second.animate(&#123;<span class="attr">height</span>:<span class="string">'120px'</span>&#125;,<span class="number">500</span>);</div><div class="line"><span class="comment">// 建议</span></div><div class="line">$second.html(value);</div><div class="line">$second.on(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">'hello everybody'</span>);</div><div class="line">&#125;).fadeIn(<span class="string">'slow'</span>).animate(&#123;<span class="attr">height</span>:<span class="string">'120px'</span>&#125;,<span class="number">500</span>);</div></pre></td></tr></table></figure></p>
<h1 id="7、减少DOM操作"><a href="#7、减少DOM操作" class="headerlink" title="7、减少DOM操作"></a>7、减少DOM操作</h1><p>刚开始使用jQuery时可能会频繁的操作DOM，这是相当耗费性能的。如我们要在body中动态输出一个表格，一些朋友会这样写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//糟糕</span></div><div class="line"><span class="keyword">var</span> $t = $(<span class="string">'body'</span>); </div><div class="line">$t.append(<span class="string">'&lt;table&gt;'</span>); </div><div class="line">$t.append(<span class="string">'&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;'</span>); </div><div class="line">$t.append(<span class="string">'&lt;/table&gt;'</span>);</div><div class="line"><span class="comment">//建议</span></div><div class="line">$(<span class="string">'body'</span>).append(<span class="string">'&lt;table&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;'</span>);</div></pre></td></tr></table></figure></p>
<p>这样在拼接完table串后再添加到body中，对DOM的操作只需一次。群里以前有朋友就因为这个导致在IE下输出时出现问题，而关于字符串的拼接可以参考下最快创建字符串的方法。</p>
<h3 id="7-1、繁重的操作中分离元素"><a href="#7-1、繁重的操作中分离元素" class="headerlink" title="7.1、繁重的操作中分离元素"></a>7.1、繁重的操作中分离元素</h3><p>如果你打算对DOM元素做大量操作（连续设置多个属性或css样式），建议首先分离元素然后在添加。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 糟糕</span></div><div class="line"><span class="keyword">var</span></div><div class="line">    $container = $(<span class="string">"#container"</span>),</div><div class="line">    $containerLi = $(<span class="string">"#container li"</span>),</div><div class="line">    $element = <span class="literal">null</span>;</div><div class="line">$element = $containerLi.first();</div><div class="line"><span class="comment">//... 许多复杂的操作</span></div><div class="line"><span class="comment">// better</span></div><div class="line"><span class="keyword">var</span></div><div class="line">    $container = $(<span class="string">"#container"</span>),</div><div class="line">    $containerLi = $container.find(<span class="string">"li"</span>),</div><div class="line">    $element = <span class="literal">null</span>;</div><div class="line">$element = $containerLi.first().detach();</div><div class="line"><span class="comment">//... 许多复杂的操作</span></div><div class="line">$container.append($element);</div></pre></td></tr></table></figure></p>
<h3 id="7-2、最小化DOM更新"><a href="#7-2、最小化DOM更新" class="headerlink" title="7.2、最小化DOM更新"></a>7.2、最小化DOM更新</h3><p>重布局和重绘是WEB页面中最常见的也是最昂贵的两种操作。</p>
<ul>
<li>当改变样式，而不改变页面几何布局时，将会发生重绘。隐藏一个元素或者改变一个元素的背景色时都将导致一次重绘。</li>
<li>当对页面结构进行更新时，将导致页面重布局。<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//糟糕</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++)&#123;</div><div class="line">    $(<span class="string">"#main table"</span>).append(<span class="string">"&lt;tr&gt;&lt;td&gt;aaaa&lt;/td&gt;&lt;/tr&gt;"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//建议</span></div><div class="line"><span class="keyword">var</span> tablerow = <span class="string">""</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++)&#123;</div><div class="line">    tablerow  += $(<span class="string">"#main table"</span>).append(<span class="string">"&lt;tr&gt;&lt;td&gt;aaaa&lt;/td&gt;&lt;/tr&gt;"</span>);</div><div class="line">&#125;</div><div class="line">$(<span class="string">"#main table"</span>).append(tablerow);</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="8、维持代码的可读性"><a href="#8、维持代码的可读性" class="headerlink" title="8、维持代码的可读性"></a>8、维持代码的可读性</h1><p>伴随着精简代码和使用链式的同时，可能带来代码的难以阅读。添加缩紧和换行能起到很好的效果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 糟糕</span></div><div class="line">$second.html(value);</div><div class="line">$second.on(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">'hello everybody'</span>);</div><div class="line">&#125;).fadeIn(<span class="string">'slow'</span>).animate(&#123;<span class="attr">height</span>:<span class="string">'120px'</span>&#125;,<span class="number">500</span>);</div><div class="line"><span class="comment">// 建议</span></div><div class="line">$second.html(value);</div><div class="line">$second</div><div class="line">    .on(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="string">'hello everybody'</span>);&#125;)</div><div class="line">    .fadeIn(<span class="string">'slow'</span>)</div><div class="line">    .animate(&#123;<span class="attr">height</span>:<span class="string">'120px'</span>&#125;,<span class="number">500</span>);</div></pre></td></tr></table></figure></p>
<h1 id="9、选择短路求值"><a href="#9、选择短路求值" class="headerlink" title="9、选择短路求值"></a>9、选择短路求值</h1><p>短路求值是一个从左到右求值的表达式，用 &amp;&amp;（逻辑与）或 ||（逻辑或）操作符。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 糟糕</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initVar</span>(<span class="params">$myVar</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(!$myVar) &#123;</div><div class="line">        $myVar = $(<span class="string">'#selector'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 建议</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initVar</span>(<span class="params">$myVar</span>) </span>&#123;</div><div class="line">    $myVar = $myVar || $(<span class="string">'#selector'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="10、坚持最新版本"><a href="#10、坚持最新版本" class="headerlink" title="10、坚持最新版本"></a>10、坚持最新版本</h1><p>新版本通常更好：更轻量级，更高效。显然，你需要考虑你要支持的代码的兼容性。例如，2.0版本不支持ie 6/7/8。</p>
<p>摒弃弃用方法</p>
<p>关注每个新版本的废弃方法是非常重要的并尽量避免使用这些方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 糟糕 - live 已经废弃</span></div><div class="line">$(<span class="string">'#stuff'</span>).live(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'hooray'</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 建议</span></div><div class="line">$(<span class="string">'#stuff'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'hooray'</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 注：此处可能不当，应为live能实现实时绑定，delegate或许更合适</span></div></pre></td></tr></table></figure></p>
<h1 id="11、最后忠告"><a href="#11、最后忠告" class="headerlink" title="11、最后忠告"></a>11、最后忠告</h1><p>最后，我记录这篇文章的目的是提高jQuery的性能和其他一些好的建议。如果你想深入的研究对这个话题你会发现很多乐趣。记住，jQuery并非不可或缺，仅是一种选择。思考为什么要使用它。DOM操作？ajax？模版？css动画？还是选择符引擎？或许javascript微型框架或jQuery的定制版是更好的选择。</p>
<p>虽然都是陈词滥调，但是我发现还不能很好得做到上述所有，记录下来希望自己能够全部做到。</p>
<h1 id="12、不使用jQuery"><a href="#12、不使用jQuery" class="headerlink" title="12、不使用jQuery"></a>12、不使用jQuery</h1><p>原生函数总是最快的，这点不难理解，在代码书写中我们不应该忘记原生JS。<br>就先总结这几条吧，每条建议并不难理解，但总结全面的话还是要花费不少时间的。如在减少代码段中，如果需要根据条件从数组中得到新数组时，可以使用<code>$.grep()</code>方法，如果你在使用jQuery时有自己心得的话，欢迎在留言中和大家分享！</p>
<hr>
<p><strong>参考资料：</strong><br>《jQuery高级编程》[Cesar Otero,Rob Larsen]，（译）施宏斌，清华大学出版社，2013年4月第1版<br><a href="http://mp.weixin.qq.com/s?__biz=MzI5MzIyNzAyNA==&amp;mid=2247483859&amp;idx=1&amp;sn=5c9ddc0018554cf8dc164d312ec41910&amp;scene=1&amp;srcid=0527fUjiz508GaFrXiesQk3n#rd" target="_blank" rel="external">http://mp.weixin.qq.com/s?__biz=MzI5MzIyNzAyNA==&amp;mid=2247483859&amp;idx=1&amp;sn=5c9ddc0018554cf8dc164d312ec41910&amp;scene=1&amp;srcid=0527fUjiz508GaFrXiesQk3n#rd</a></p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[模拟JavaScript的Array.sort()方法]]></title>
      <url>/2016/07/07/%E6%A8%A1%E6%8B%9FJavaScript%E7%9A%84Array.sort()%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>在JavaScript中，Array对象的sort()方法是用来排序的，但是这个方法在默认情况下可能不是我们想要的，比如对于如下数组<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">7</span>,<span class="number">15</span>];</div></pre></td></tr></table></figure></p>
<p>使用sort排序会得到如下结果：<br>[10, 15, 2, 20, 5, 7]</p>
<p>在不传递参数的情况下，它是按字符的Unicode编码来排序的。</p>
<p>为了解决这个问题，可以为sort()方法传递一个参数，这个参数ECMAScript是这么定义的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">@param &#123;function&#125; [compareFn]</div><div class="line">@return &#123;Array.&lt;T&gt;&#125;</div><div class="line">*/</div><div class="line"><span class="built_in">Array</span>.prototype.sort = <span class="function"><span class="keyword">function</span>(<span class="params">compareFn</span>) </span>&#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>参数为一个function，具体叫比较函数。我们可以改写为如下形式，传递一个比较函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> a - b;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>a和b即是要比较的两个数，其返回值如下：</p>
<ul>
<li>若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。</li>
<li>若 a 等于 b，则返回 0。</li>
<li>若 a 大于 b，则返回一个大于 0 的值。 </li>
</ul>
<p>对于返回值的三种结果，我们可以直接使用“a-b”，这样就可以正确得到结果<br>[2, 5, 7, 10, 15, 20]</p>
<p>那么，接下来我们就来模拟一下这个方法和比较函数的实现。</p>
<p>首先，如果我们不用这个方法，而是自己实现排序，那么我们可以使用传统的冒泡排序方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">array</span>)</span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;array.length - <span class="number">1</span>; i++)&#123;</div><div class="line">            <span class="comment">// 假设数组已经排好序了</span></div><div class="line">            <span class="keyword">var</span> isSorted = <span class="literal">true</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;array.length - <span class="number">1</span> - i; j++)&#123;</div><div class="line">                <span class="keyword">if</span>(array[j] &gt; array[j + <span class="number">1</span>])&#123;</div><div class="line">                    <span class="keyword">var</span> temp = array[j];</div><div class="line">                    array[j] = array[j + <span class="number">1</span>];</div><div class="line">                    array[j + <span class="number">1</span>] = temp;</div><div class="line">                    <span class="comment">// 还有比较，说明排序还未结束</span></div><div class="line">                    isSorted = <span class="literal">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果排序已经完成，跳出循环</span></div><div class="line">            <span class="keyword">if</span>(isSorted)&#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这是一个循环次数最少的排序方法，但是，这个排序的适应性不强，对于字符串数组就不行了，假设有如下字符串数组，要求按字符串个数排序该如何实现？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arry = [<span class="string">"aaa"</span>,<span class="string">"aa"</span>,<span class="string">"c"</span>,<span class="string">"bb"</span>.<span class="string">"xxxxxxxx"</span>];</div></pre></td></tr></table></figure></p>
<p>这样的数组我们不得不重新写一个方法来对字符串数组进行排序，需要改动上面冒泡排序的第6行的判断条件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(array[j].length &gt; array[j+<span class="number">1</span>].length)&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>那么，既然只需要改动这一句，我们可以把这一句作为参数传递，以后想怎么排就传什么样的参数，这个参数就是一个函数，回调函数。下面重新改写上面的冒泡排序，传递一个回调函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 模拟sort()</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">array,fn</span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;array.length - <span class="number">1</span>; i++)&#123;</div><div class="line">        <span class="keyword">var</span> isSorted = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;array.length - <span class="number">1</span> - i; j++)&#123;</div><div class="line">            <span class="keyword">if</span>(fn(array[j], array[j + <span class="number">1</span>]) &gt; <span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">var</span> temp = array[j];</div><div class="line">                array[j] = array[j + <span class="number">1</span>];</div><div class="line">                array[j + <span class="number">1</span>] = temp;</div><div class="line">                    isSorted = <span class="literal">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(isSorted)&#123;</div><div class="line">           <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意第2行和第6行，给sort传递了一个fn参数，这是一个函数，然后在第6行调用，array[j]和array[j+1]分别就是回调函数的a,b两个比较值。用这个改写的方法即可对数值数组排序也可以对字符串数组排序了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">"aaa"</span>,<span class="string">"a"</span>,<span class="string">"xxxxxx"</span>,<span class="string">"abcd"</span>,<span class="string">"ab"</span>];</div><div class="line">sort(arr, <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a.length - b.length;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(arr);</div></pre></td></tr></table></figure></p>
<p>输出：[“a”, “ab”, “aaa”, “abcd”, “xxxxxx”]</p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jQuery的三组基本动画与自定义动画总结]]></title>
      <url>/2016/07/04/jQuery%E7%9A%84%E4%B8%89%E7%BB%84%E5%9F%BA%E6%9C%AC%E5%8A%A8%E7%94%BB%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>jQuery提供了三组基本动画，分别是显示与隐藏、淡入与淡出、滑入与画出，这三组基本动画都是标准的、有规律的的效果，jQuery还提供了一个自定义动画。<br><a id="more"></a></p>
<h1 id="1、显示（show）与隐藏（hide）"><a href="#1、显示（show）与隐藏（hide）" class="headerlink" title="1、显示（show）与隐藏（hide）"></a>1、显示（show）与隐藏（hide）</h1><p>显示(show)与隐藏(hide)是一组动画</p>
<h3 id="1-1-show方法"><a href="#1-1-show方法" class="headerlink" title="1.1 show方法"></a>1.1 show方法</h3><p>show([speed,[easing],[callback]])</p>
<ul>
<li>参数speed，可选，动画的执行时间<ul>
<li>如果不传，就没有动画效果。</li>
<li>毫秒值(比如1000),动画在1000毫秒执行完成<strong>(推荐)</strong></li>
<li>固定字符串，slow(200)、normal(400)、fast(600)，如果传其他字符串，则默认为normal。</li>
</ul>
</li>
<li>参数callback，可选，执行完动画后执行的回调函数，每个元素执行一次。</li>
<li>参数easing，可选，这里先不讲，后面统一讲</li>
</ul>
<h3 id="1-2-hide方法"><a href="#1-2-hide方法" class="headerlink" title="1.2 hide方法"></a>1.2 hide方法</h3><p>与show方法的用法完全一致。</p>
<h3 id="1-3-原理"><a href="#1-3-原理" class="headerlink" title="1.3 原理"></a>1.3 原理</h3><p>show和hide修改的是元素的width、height、opacity。</p>
<h1 id="2、滑入（sliderDown）与隐藏（sliderUp）"><a href="#2、滑入（sliderDown）与隐藏（sliderUp）" class="headerlink" title="2、滑入（sliderDown）与隐藏（sliderUp）"></a>2、滑入（sliderDown）与隐藏（sliderUp）</h1><p>滑入(slideUp)与滑出(slideDown)是一组动画，效果与卷帘门类似</p>
<p>slideUp/slideDown,使用方法与show/hide基本一致。</p>
<h3 id="2-1-用法"><a href="#2-1-用法" class="headerlink" title="2.1 用法"></a>2.1 用法</h3><p>slideDown([speed],[easing],[callback])</p>
<ul>
<li>参数speed，可选，动画的执行时间<ul>
<li>如果不传，<strong>默认为normal，注意区分show/hide</strong></li>
<li>毫秒值(比如1000),动画在1000毫秒执行完成<strong>(推荐)</strong></li>
<li>固定字符串，slow(200)、normal(400)、fast(600)，如果传其他字符串，则默认为normal。</li>
</ul>
</li>
<li>参数callback，可选，执行完动画后执行的回调函数，每个元素执行一次。</li>
<li>参数easing，可选，这里先不讲，后面统一讲</li>
</ul>
<h3 id="2-2-滑入画出切换（slideToggle）"><a href="#2-2-滑入画出切换（slideToggle）" class="headerlink" title="2.2 滑入画出切换（slideToggle）"></a>2.2 滑入画出切换（slideToggle）</h3><p>$(selector).slideToggle(speed,callback);<br>如果是隐藏状态，那么执行slideDown操作，如果是显示状态，那么执行slideUp操作。</p>
<h3 id="2-3-原理"><a href="#2-3-原理" class="headerlink" title="2.3 原理"></a>2.3 原理</h3><p>slideDown和slideUp修改的是元素的height，通过高度变化（向下、向上增大）来动态地显示所有匹配的元素。</p>
<h1 id="3、淡入（fadeIn）与淡出（fadeOut）"><a href="#3、淡入（fadeIn）与淡出（fadeOut）" class="headerlink" title="3、淡入（fadeIn）与淡出（fadeOut）"></a>3、淡入（fadeIn）与淡出（fadeOut）</h1><p>fadeIn/fadeOut使用方法与show/hide、slideDown/slideUp一致。</p>
<h3 id="3-1-用法"><a href="#3-1-用法" class="headerlink" title="3.1  用法"></a>3.1  用法</h3><p>fadeIn([speed],[easing],[callback])</p>
<ul>
<li>参数speed，可选，动画的执行时间<ul>
<li>如果不传，<strong>默认为normal</strong></li>
<li>毫秒值(比如1000),动画在1000毫秒执行完成<strong>(推荐)</strong></li>
<li>固定字符串，slow(200)、normal(400)、fast(600)，如果传其他字符串，则默认为normal。</li>
</ul>
</li>
<li>参数callback，可选，执行完动画后执行的回调函数，每个元素执行一次。</li>
<li>参数easing，可选，这里先不讲，后面统一讲</li>
</ul>
<h3 id="3-2-淡入淡出切换（fadeToggle）"><a href="#3-2-淡入淡出切换（fadeToggle）" class="headerlink" title="3.2  淡入淡出切换（fadeToggle）"></a>3.2  淡入淡出切换（fadeToggle）</h3><p>fadeToggle([speed,[easing],[callback]])<br>如果当前元素处于隐藏状态，那么执行fadeIn操作，如果处于显示状态，那么执行fadeOut操作。</p>
<h3 id="3-3-淡入淡出到某个值（fadeTo）"><a href="#3-3-淡入淡出到某个值（fadeTo）" class="headerlink" title="3.3 淡入淡出到某个值（fadeTo）"></a>3.3 淡入淡出到某个值（fadeTo）</h3><p>fadeTo(speed,opacity,[easing],[callback]])<br>把所有匹配元素的不透明度以渐进方式调整到指定的不透明度</p>
<ul>
<li>参数speed，必须</li>
<li>参数opacity，0-1之间的数值(比如0.4)，表示淡到某一个值。</li>
<li>参数callback，可选，执行完动画后执行的回调函数，每个元素执行一次。</li>
</ul>
<p><strong>与淡入淡出的区别：</strong>淡入淡出只能控制元素的不透明度从 完全不透明 到完全透明；而fadeTo可以指定元素不透明度的具体值。并且时间参数是必需的！</p>
<p>fade系列方法：修改的是元素的opacity。</p>
<h1 id="4、三组基本动画总结"><a href="#4、三组基本动画总结" class="headerlink" title="4、三组基本动画总结"></a>4、三组基本动画总结</h1><p>a. Query给我们提供了三组动画，show/hide、slideUp/slideDown、fadeIn/fadeOut。<br>b. 动画切换方法：slideToggle、fadeToggle，注意：show和hide没有切换的方法。<br>c. 淡入淡出到某个值：fadeTo方法。<br>d. show/slideDown/fadeIn三个是显示效果、hide/slideUp/fadeOut三个是隐藏效果。<br>e. show/hide修改的是元素的height,width,opacity。slide系列方法修改的是元素的height。fade系列方法修改的是元素的opacity。这三种方法修改的这些值，都是带数字的，<strong>因为带了数字才能做渐变</strong>。</p>
<h1 id="5、自定义动画（animate）"><a href="#5、自定义动画（animate）" class="headerlink" title="5、自定义动画（animate）"></a>5、自定义动画（animate）</h1><p>animate(params,[speed],[easing],[callback])</p>
<ul>
<li>参数params，必须，要执行动画的CSS属性，带数字</li>
<li>参数speed，可选，执行动画时长</li>
<li>参数easing，可选，这里先不讲，后面统一讲</li>
<li>参数callback，可选，执行完动画后执行的回调函数，每个元素执行一次。</li>
</ul>
<h1 id="6、easing参数"><a href="#6、easing参数" class="headerlink" title="6、easing参数"></a>6、easing参数</h1><p>现在来说说easing参数的作用，这个参数是控制动画的速度样式，这个参数只有两个取值：</p>
<ul>
<li>swing：摆钟运动，在开头和结尾移动慢，在中间移动速度快。</li>
<li>linear：匀速移动。</li>
</ul>
<p>在不指定easing参数时，jQuery动画默认值是swing。</p>
<h1 id="7、动画队列"><a href="#7、动画队列" class="headerlink" title="7、动画队列"></a>7、动画队列</h1><p>在同一个元素上执行多个动画，那么对于这个动画来说，后面的动画会被放到动画队列中，等前面的动画执行完成了才会执行（联想：地铁进站）。</p>
<h1 id="8、停止动画"><a href="#8、停止动画" class="headerlink" title="8、停止动画"></a>8、停止动画</h1><p>要停止动画，可以使用stop()方法。stop(clearQueue, jumpToEnd)。</p>
<h3 id="8-1、stop"><a href="#8-1、stop" class="headerlink" title="8.1、stop()"></a>8.1、stop()</h3><p>stop方法接受两个参数，这个两个参数都是可选的，为Boolean值：</p>
<ul>
<li>clearQueue，是否清除动画队列；</li>
<li>jumpToEnd，是否跳转到动画的最终效果。</li>
</ul>
<p>当然了，一般我们不需要传递参数，直接使用stop()。如果直接使用stop()方法，则会理解停止当前正在执行的动画，如果接下来还有动画等待进行，则以当前状态开始接下来的动画。</p>
<h3 id="8-2、判断元素是否处于动画状态"><a href="#8-2、判断元素是否处于动画状态" class="headerlink" title="8.2、判断元素是否处于动画状态"></a>8.2、判断元素是否处于动画状态</h3><p><strong>动画积累</strong>：在使用animate()方法的时候，要避免动画积累而导致的动画与用户的行为不一致。当用户快速在某个元素上执行animate动画时，就会出现动画积累。</p>
<p>解决方法是判断元素是否处于动画状态，如果元素不处于动画状态，才为元素添加新的动画，否则不添加。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>( ! $(element).is(<span class="string">":animate"</span>) )&#123;    <span class="comment">//判断元素是否正处于动画状态</span></div><div class="line">    <span class="comment">//如果当前没有进行动画，则添加新的动画</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript的“&&”与“||”操作符总结]]></title>
      <url>/2016/06/15/JavaScript%E7%9A%84%E2%80%9C&amp;&%E2%80%9D%E4%B8%8E%E2%80%9C%7C%7C%E2%80%9D%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p><code>&amp;&amp;</code>和<code>||</code>操作符链接的两个值最后取哪个值的问题，有点模糊和不好理解，比如下面的表达式输出什么？如果你能答对说明你对这个问题就掌握了没什么问题。<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> val1 = <span class="number">123</span> &amp;&amp; <span class="number">234</span>; </div><div class="line"><span class="keyword">var</span> val2 = <span class="number">0</span> &amp;&amp; <span class="number">1</span>; </div><div class="line"><span class="keyword">var</span> val3 = <span class="number">1</span> &amp;&amp; <span class="number">0</span>; </div><div class="line"><span class="keyword">var</span> val4 = <span class="number">1</span> &amp;&amp; <span class="string">""</span>; </div><div class="line"><span class="keyword">var</span> val5 = <span class="string">""</span> &amp;&amp; <span class="number">1</span>; </div><div class="line"><span class="keyword">var</span> val6 = <span class="string">""</span> &amp;&amp; <span class="number">0</span>; </div><div class="line"><span class="keyword">var</span> val7 = <span class="number">0</span> &amp;&amp; <span class="string">""</span>;</div></pre></td></tr></table></figure></p>
<p><code>&amp;&amp;</code>和<code>||</code>操作符两边不是布尔类型时，系统会转换成布尔类型值再计算(空字符串、null、0都会被转成false)，结果本身不变。上述表达式的结果为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> val1 = <span class="number">123</span> &amp;&amp; <span class="number">234</span>;    <span class="comment">//234</span></div><div class="line"><span class="keyword">var</span> val2 = <span class="number">0</span> &amp;&amp; <span class="number">1</span>;    <span class="comment">//0</span></div><div class="line"><span class="keyword">var</span> val3 = <span class="number">1</span> &amp;&amp; <span class="number">0</span>;    <span class="comment">//0</span></div><div class="line"><span class="keyword">var</span> val4 = <span class="number">1</span> &amp;&amp; <span class="string">""</span>;    <span class="comment">//""</span></div><div class="line"><span class="keyword">var</span> val5 = <span class="string">""</span> &amp;&amp; <span class="number">1</span>;    <span class="comment">//""</span></div><div class="line"><span class="keyword">var</span> val6 = <span class="string">""</span> &amp;&amp; <span class="number">0</span>;    <span class="comment">//""</span></div><div class="line"><span class="keyword">var</span> val7 = <span class="number">0</span> &amp;&amp; <span class="string">""</span>;    <span class="comment">//0</span></div></pre></td></tr></table></figure></p>
<p>你都答对了吗？</p>
<p><strong>&amp;&amp;操作符总结：只要一个false就取false的值，都是true取后面，都是false取前面。</strong></p>
<p><strong>助记：一F即F取F，都F取前。</strong></p>
<p><code>||</code>操作符跟&amp;&amp;操作符相反，那么如下表示式 的结果是什么？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> val1 = <span class="number">1</span> || <span class="number">2</span>;    <span class="comment">//1</span></div><div class="line"><span class="keyword">var</span> val2 = <span class="number">0</span> || <span class="number">1</span>;    <span class="comment">//1</span></div><div class="line"><span class="keyword">var</span> val3 = <span class="number">1</span> || <span class="number">0</span>;    <span class="comment">//1</span></div><div class="line"><span class="keyword">var</span> val4 = <span class="number">1</span> || <span class="string">""</span>;    <span class="comment">//1</span></div><div class="line"><span class="keyword">var</span> val5 = <span class="number">0</span> || <span class="string">""</span>;    <span class="comment">//""</span></div><div class="line"><span class="keyword">var</span> val6 = <span class="string">""</span> || <span class="number">0</span>;    <span class="comment">//0</span></div><div class="line"><span class="keyword">var</span> val7 = <span class="number">0</span> || <span class="string">""</span>;    <span class="comment">//""</span></div></pre></td></tr></table></figure>
<p><strong>||操作符总结：只要一个是true就取true的值，都是true取前面，都是false取后面。</strong></p>
<p>这个两个操作符需要注意的是，只有一边是false和true的情况，和都是false或true的情况。</p>
<p>这个连个操作符在DOM编程中经常使用，比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj  =  <span class="built_in">document</span>.body.scrollTop  ||  <span class="built_in">document</span>.documentElement.scrollTop;</div></pre></td></tr></table></figure></p>
<p>只需要记住其中一个操作符的特点即可。</p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机的三大原则与计算机的进化]]></title>
      <url>/2016/06/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E4%B8%89%E5%A4%A7%E5%8E%9F%E5%88%99%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%9B%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>本文将从宏观上对计算机做一个介绍，不讨论硬件底层细节，请放心，完全看得懂。并且简单介绍一下计算机的进化<br><a id="more"></a></p>
<h1 id="原则一：输入、运算、输出是硬件的基础"><a href="#原则一：输入、运算、输出是硬件的基础" class="headerlink" title="原则一：输入、运算、输出是硬件的基础"></a>原则一：输入、运算、输出是硬件的基础</h1><p>从硬件上来讲，可以说计算机是执行输入、运算、输出三种操作的机器。计算机的硬件由大量的IC（集成电路）组成，每块IC上都有大量的引脚，这些引脚有些用于输入，有些用于输出。IC会在其内部对外部输入的信息进行运算，并把运算结果输出到外部。运算这个词听起来也许有些难以理解，但实际上就是计算的意思。举例来说，1+2=3，计算机所做的事就是“输入”数据1和2，然后对它们进行加法“运算”，最后“输出”计算结果3。<br><img src="http://upload-images.jianshu.io/upload_images/68937-9f4e93dfc009c820.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" IC的引脚中有些用于输入，有些用于输出"></p>
<p>其实计算机就是一台简单的机器，它也只能做这三件事。输入、运算、输出必须成套出现，缺一不可。</p>
<ul>
<li>第一，现在的计算机还没有发展到能通过自发的思考创造出信息的地步，因此不输入信息就算计就不能工作。如果</li>
<li>第二，计算机不能不执行任何运算，如果只是使输入的信息绕过运算环节直接输出，那么这就是电线而不是计算机了，如果不进行运算，计算机也就没有什么存在的意义了。</li>
<li>第三，如果不输出结果，那么这也不是计算机而只是堆积信息的垃圾箱了，所以输出也必不可少。</li>
</ul>
<h1 id="原则二：软件是指令和数据的集合"><a href="#原则二：软件是指令和数据的集合" class="headerlink" title="原则二：软件是指令和数据的集合"></a>原则二：软件是指令和数据的集合</h1><p>什么是程序？所谓程序，其实非常简单，只不过是指令和数据的集合。无论程序多么高深多么复杂，其内容也都是指令和数据。</p>
<p>那什么是指令？所谓指令，就是控制计算进行输入、运算、输出的命令。</p>
<p>程序中的数据分为两类，一类是作为指令执行对象的输入数据， 一类是从指令的执行结果得到的输出数据。一般在编写程序的过程中，都要先编译再执行，所谓编译就是把用编译型语言如C、Java、C#等编写的源文件转换成字节码文件，也可以说是机器语言或原生代码。因为计算机只认识二进制，只认识0和1，由一大堆的二进制代码组成的程序就叫机器码、机器语言。</p>
<h1 id="原则三：计算的处理方式有时与人们的思维习惯不同"><a href="#原则三：计算的处理方式有时与人们的思维习惯不同" class="headerlink" title="原则三：计算的处理方式有时与人们的思维习惯不同"></a>原则三：计算的处理方式有时与人们的思维习惯不同</h1><p>计算机有计算机的处理方法，这是三大原则中的最后一点。计算机本身只不过是为我们处理特定工作的机器。如果计算机能自己干活的话，那么我们的生活太美好了，我一定买很多台。不过遗憾的是目前还没有这样的计算机，现在的计算机终究是受人支配的工具。</p>
<p>对计算机来说什么都是数字。用数字表示所有信息，这就是一个很具代表性的计算机式的处理方式，这一点正是和人类的思维习惯不一样的地方。例如，人们会用”蓝色“”红色“之类的词语描述有关的颜色信息。可是换做计算机的话，就不得不用数字表示颜色信息。例如：用”0,0,255“表示蓝色，用”255,0,0“表示红色，用”255,0,255“表示由蓝色和红色混合而成的紫色。不光是颜色，计算机对文字的处理也是如此。计算机内部会先把文字转换成相应的数字再做处理，这样的数字叫做”字符编码“。总之，计算机会什么都用数字来表示。</p>
<h1 id="计算机的进化"><a href="#计算机的进化" class="headerlink" title="计算机的进化"></a>计算机的进化</h1><p>计算机的进化只有一个目的——与人类更加相近。要想更加贴近人类，就必须从计算机的处理方式中摒弃不符合人类思维习惯的部分，其实按照这么一来，计算机的进化最终形态就是机器人了，与着人类一样的外表，可以使用人类的语言。说到机器人，推荐一部印度科幻电影《宝莱坞机器人之恋》，讲的就是机器人拥有了人类的思维和感情后机器人做出的疯狂行为，无论从哪个角度这都是一部非常棒的科幻电影，浓郁的印度阿三风格，看惯了好莱坞来看这部电影，会给你重新认识印度的电影水准，简直秒杀我们中国科幻电影好几条街！<br><img src="http://upload-images.jianshu.io/upload_images/68937-ede216fe6dc0727c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="宝莱坞机器人之恋"></p>
<p>如果与前几十年相比，我们身边的个人计算机一直在进化，在逐渐贴近人类。上个世纪80年代中期盛行的计算机操作系统是MS-DOS，它的操作方法是在全黑的画面上敲入字符，把命令传给计算机。进入90年代后，MS-DOS进化成了windows，1995年，微软发布了划时代的windows95操作系统，用户开始可以在图形界面上通过鼠标操作直观的下达命令。</p>
<p><strong>算盘</strong><br>从广义上上说，世界上第一台计算机大约是4000年前被发明的，你知道是什么吗？就是算盘！这是第一种被设计帮助人类计数和计算的机器。<br><img src="http://upload-images.jianshu.io/upload_images/68937-7a4f770fb3d8e036.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="算盘"></p>
<p>算盘勉强也符合计算机三大原则的输入、运算、输出，所以算盘也可以称为是计算机，其实更符合的叫法应该叫计算器。他是人力驱动的。</p>
<p>关于算盘是不是计算机，是不是第一台计算机是有争议的，不同的的资料可能有不同的说法，但是我们没必要去纠结这个，一点意义都没有，关键是要弄懂当人们在讨论计算机的时候到底在谈论什么。</p>
<p><strong>巴贝奇与差分机</strong><br>更加复杂的计算器有英国人查尔斯·巴贝奇与1822年制造了一台能进行8位数的数学运算的机器，叫做”差分机“。</p>
<p>关于巴贝奇这个人，他几乎是一个全才，他本身是一个数学家，他还是一个文学家、哲学家、天文学家以及经济学家，不过他赖以成名的是因为发明差分机和分析机。</p>
<p>差分机的”差分“是什么意思呢？所谓”差分”的含义，是指把函数表的复杂算式转化为差分运算，用简单的加法代替平方运算。1834年设计了更强大的分析机，不是仅仅能够制表的差分机，而是一种通用的数学计算机。但是它的制造要求有非常高的机械工程技术，第二台差分机大约有25000个零件，主要零件的误差不得超过每英寸千分之一，即使用现在的加工设备和技术，要想造出这种高精度的机械也绝非易事。以至于后来它的分析机根本就没法造出来，从来没有真正的使用过分析机。<br><img src="http://upload-images.jianshu.io/upload_images/68937-ebea0293c44f3da3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" 巴贝奇与他的差分机"></p>
<p>不管是是差分机还是分析机，主要都是由机器齿轮来驱动运转，以蒸汽机来提供动力，那时候电发现没多久，还没有用电力来驱动机器的方法。</p>
<p>算盘跟这种大型机器比的话简直low的不行，但是算盘也是一个非常精妙的东西。</p>
<p><strong>ABC机</strong><br>那么世界上真正第一台电子计算机是什么呢，注意，是”电子“计算机。我姑且把之前的那些什么算盘、巴贝奇差分机叫做齿轮计算机吧，这是我个人的说法。大家以为ENIAC是世界第一台电子计算机吗？其实不是的，世界上第一台电子计算机叫”阿塔纳索夫-贝瑞计算机“，也简称ABC机，它是1937年设计的不可编程，仅仅设计用于求解线性方程组的计算机。<br><img src="http://upload-images.jianshu.io/upload_images/68937-1039e89cfd657643.jpg" alt=" ABC机"></p>
<p>它的特点：<br>第一，采用电能与电子元件，在当时就是电子真空管；<br>第二，采用二进位制，而非通常的十进位制；<br>第三，采用电容器作为存储器，可再生而且避免错误；<br>第四，进行直接的逻辑运算，而非通常的数字算术。</p>
<p>从ABC开始，人类的计算从模拟向数字挺进。</p>
<p><strong>ENIAC</strong><br>那么接下来说的这个计算机就是世界上第一台”通用电子计算机“，它于1946年在美国宾夕法尼亚大学诞生，它的诞生是为了战争而生的，专门为了计算弹道和射击特性表面而研制的。没错他就是ENIAC。它是图灵完全的电子计算机，能够重新编程，解决各种计算问题。注意“通用”“图灵完全”“重新编程”这三个词语，这是它的特点。</p>
<p>这台计算机主要元器件采用的是电子管 。</p>
<p><strong>冯·诺依曼与冯·诺依曼计算机</strong><br>提到计算机，就不能不提到冯诺依曼这个人，被称为计算机之父。它提出程序存储的思想，明确规定用二进制替代十进制运算，并将计算机分成五大组件（运算器、控制器、存储器和输入输出设备），计算机应该按照程序顺序执行。人们把冯诺依曼的这个理论称为冯诺依曼体系结构，根据这些原理制造的计算机被称为冯·诺依曼结构计算机，从EDVAC到当前最先进的计算机都采用的是冯诺依曼体系结构。世界上第一台冯·诺依曼式计算机是1949年研制的EDVAC，也是为美国陆军弹道研究实验室研制。</p>
<p>上面提到了好多个世界第一，第一台计算机是算盘，第一台电子计算是ABC机，第一台通用电子计算机是ENIAC，第一台冯诺依曼计算机是EDVAC。</p>
<p><strong>阿兰·图灵与图灵机</strong><br>除了冯诺依曼，提到计算机还要提到另一个神仙，它就是阿兰·图灵。图灵是一个英国数学家和逻辑学，注意，是数学家，数学家，数学家，重要的事情说三遍，前面说的巴贝奇也是数学家，在计算机研究这个行当里，一定程度上就是数学研究，玩计算机就是玩数学，很多情况下，计算机的重大突破都是由某些数学理论的成功应用，特别是算法，TMD的就是数学，所以搞计算的数学要好，对于我们非英语国家来说，还要加上英语好，我们真的很苦逼….他居然还是逻辑学家，简直牛逼的不要不要的，更看不懂的是他后来一直在搞数理生物学方面的研究，正因为这么牛逼上帝也看上了他，于是1954在他41岁的时候上帝终于把他弄天上去了，上天了……。逻辑学在计算机中也是很重要的应用，特别是硬件底层，硬件里面其实就是一堆开关，一堆继电器，一堆逻辑门，一堆true和false，一堆0和1.<br><img src="http://upload-images.jianshu.io/upload_images/68937-496b5a7e4e1b7216.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="阿兰·图灵"></p>
<p>阿兰·图灵在二战的时候是为英国搞密码破译的，专门破译德国密码，做出过很多重大贡献，一定程度上左右了英国当时的战争局势，关于图灵还有很多秘密，现在有一本书叫《图灵的秘密》，由图灵教育公司出版的，专门介绍他的生平、思想及论文解读，大家有兴趣可以买来看看。<br><img src="http://upload-images.jianshu.io/upload_images/68937-be48011de0c1a1f9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" 图灵的秘密"></p>
<p>好了，上面扯了一堆题外话，那么，图灵在计算机上到底有什么贡献呢？他有很多理论，比如可计算性、判定问题，这个说起来就复杂了，我就不细讲了，其实我根本就搞不懂，太烧闹了。简而言之，图灵的基本思想是用机器来模拟人们用纸笔进行数学运算的过程，他是一种抽象的计算模型，符合这个模型的就叫图灵机。他还人工智能方面有一个有意思的东西，叫图灵测试。图灵测试就是说，如果一台机器能够与人类展开对话（通过电传设备）而不能被辨别出其机器身份，那么称这台机器具有智能。举例说比如你隔壁老王家有一台能说话的计算机，而且声音跟老王一样，那么你跟他隔墙喊话，你问一句他回答一句，你如果不能区分这次喊话到底是老王本人在回答，还是他的电脑在回答，那么就说这个电脑通过了图灵测试，具有智能。<br><img src="http://upload-images.jianshu.io/upload_images/68937-88cffc33cd03f002.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图灵测试示意图"></p>
<h3 id="计算机的代际"><a href="#计算机的代际" class="headerlink" title="计算机的代际"></a>计算机的代际</h3><p>最后再说一下计算机的代际。</p>
<p>第一代计算机被称为电子管计算机，为什么要叫电子管计算机呢？因为这一阶段计算机的主要特征是采用电子管元件作基本器件，代表计算机是ENIAC和ABC机。</p>
<p>第二代计算机被称为晶体管计算机，晶体管的出现使计算机生产技术得到了根本性的发展，同时程序语言也相应的出现了，如Fortran ，Cobol ，Algo160等计算机高级语言。</p>
<p>第三代计算机成为中小规模集成电路计算机，随着半导体工艺的发展，中小规模集成电路成为计算机的主要部件，使计算机的体积更小，大大降低了计算机计算时的功耗。在软件方面，有了标准化的程序设计语言和人机会话式的Basic 语言，其应用领域也进一步扩大。</p>
<p>第四代计算机成为大规模和超大规模集成电路计算机，这一带计算机的体积进一步缩小，性能进一步提高。发展了并行技术和多机系统，出现了精简指令集计算机 （RISC），软件系统工程化、理论化，程序设计自动化。我们现在就是处于第四代计算机向第五代过度的阶段。</p>
<p>第五代计算机，指具有人工智能的新一代计算机，它具有推理、联想、判断、决策、学习等功能。</p>
<p><strong>参考资料：</strong></p>
<hr>
<p>《计算机是怎么跑起来的》[日]矢泽久雄，人民邮电出版社，2015.5<br><a href="http://baike.baidu.com/view/11592253.htm" target="_blank" rel="external">http://baike.baidu.com/view/11592253.htm</a><br><a href="http://baike.baidu.com/view/3240731.htm" target="_blank" rel="external">http://baike.baidu.com/view/3240731.htm</a><br><a href="http://www.baike.com/wiki/计算机发展史" target="_blank" rel="external">http://www.baike.com/wiki/计算机发展史</a><br><a href="http://baike.baidu.com/view/593829.htm" target="_blank" rel="external">http://baike.baidu.com/view/593829.htm</a><br><a href="http://baike.baidu.com/view/22486.htm" target="_blank" rel="external">http://baike.baidu.com/view/22486.htm</a><br><a href="http://baike.baidu.com/view/94296.htm" target="_blank" rel="external">http://baike.baidu.com/view/94296.htm</a></p>
]]></content>
      
        <categories>
            
            <category> 随笔扯谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[如何在Sublime Text中添加代码片段]]></title>
      <url>/2016/05/26/%E5%A6%82%E4%BD%95%E5%9C%A8Sublime-Text%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</url>
      <content type="html"><![CDATA[<p>我们在编写代码的时候，总会遇到一些需要反复使用的代码片段。这时候就需要反复的复制和黏贴，大大影响效率。我们利用Sublime Text的snippet（代码片段）功能，就能很好的解决这一问题。通俗的讲，就是把我们常用的代码分别保存起啦，然后通过插件的形式来反复调用。<br><a id="more"></a><br>创建方法：Tools （工具）&gt; New Snippet（新片段）</p>
<p>此时，会出现如下代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">snippet</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">content</span>&gt;</span>&lt;![CDATA[</div><div class="line">Hello, $&#123;1:this&#125; is a $&#123;2:snippet&#125;.</div><div class="line">]]&gt;<span class="tag">&lt;/<span class="name">content</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt;</span></div><div class="line">	<span class="comment">&lt;!-- &lt;tabTrigger&gt;hello&lt;/tabTrigger&gt; --&gt;</span></div><div class="line">	<span class="comment">&lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt;</span></div><div class="line">	<span class="comment">&lt;!-- &lt;scope&gt;source.python&lt;/scope&gt; --&gt;</span></div><div class="line">	<span class="comment">&lt;!-- &lt;description&gt;description&lt;/description&gt; --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">snippet</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>其中，content中由CDATA包裹起来的部分是我们要插入的代码片段，可选。</p>
<p>tabTrigger是我们tab键触发的自动补全代码功能的一个名字，可选。</p>
<p>scope，可选，使用范围，不填写代表对所有文件有效。附：source.css和test.html分别对应不同文件。</p>
<p>description，可选，在snippet菜单中的显示说明（支持中文）。如果不定义，菜单则显示当前文件的文件名。</p>
<p>${1:this}表示代码插入后，光标所停留的位置，可同时插入多个。其中:this为自定义参数（可选）。<br>${2}表示代码插入后，按Tab键，光标会根据顺序跳转到相应位置（以此类推）。</p>
<p>现在，你应该有了个大致的了解。那我们就开始自己动手编写一个实例。我们都知道，再Sublime中，输入！或者html:5再按tab键，可以自动补全HTML结构，但是这个结果相对很简单，我自己扩展了它的结果内容，新增了几个mate标签，增加了页面描述。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">snippet</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">content</span>&gt;</span>&lt;![CDATA[</div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang="en"&gt;</div><div class="line">&lt;head&gt;</div><div class="line">	&lt;meta charset="UTF-8"&gt;</div><div class="line">	&lt;title&gt;Document&lt;/title&gt;</div><div class="line">	&lt;meta name="Generator" content="Sublime Text3"&gt;</div><div class="line">	&lt;meta name="Author" content="dunizb"&gt;</div><div class="line">    &lt;meta name="website" content="http://www.mybry.com"&gt;</div><div class="line">    &lt;meta name="Description" content="读你，这世间唯有梦想和好姑娘不可辜负~~"&gt;</div><div class="line">    &lt;link type="image/x-icon" rel="shortcut icon" href="image/favicon.ico" /&gt;</div><div class="line">	&lt;script type="text/javascript"&gt;</div><div class="line">		$&#123;1:&#125;</div><div class="line">	&lt;/script&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    $&#123;2:这是html内容&#125;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line">]]&gt;<span class="tag">&lt;/<span class="name">content</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">tabTrigger</span>&gt;</span>hjs<span class="tag">&lt;/<span class="name">tabTrigger</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt;</span></div><div class="line">	<span class="comment">&lt;!-- &lt;scope&gt;source.python&lt;/scope&gt; --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">description</span>&gt;</span>custom-html<span class="tag">&lt;/<span class="name">description</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">snippet</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>然后保存代码片段，保存到Sublime Text3\Data\Packages\User下面，取个名字</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-dfcf978a7b66ff78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>就这样，在HTML页面中输入hjs+tab，就可以自动补全这一系列代码了。</p>
]]></content>
      
        <categories>
            
            <category> 开发工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SublimeText </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS行高(line-height)及文本垂直居中原理]]></title>
      <url>/2016/05/14/CSS%E8%A1%8C%E9%AB%98(line-height)%E5%8F%8A%E6%96%87%E6%9C%AC%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>在CSS中，line-height 属性设置两段段文本之间的距离，也就是行高，如果我们把一段文本的line-height设置为父容器的高度就可以实现文本垂直居中了，比如下面的例子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">       <span class="selector-tag">div</span> &#123;</div><div class="line">           <span class="attribute">width</span>: <span class="number">300px</span>;</div><div class="line">           <span class="attribute">height</span>: <span class="number">200px</span>;</div><div class="line">           <span class="attribute">border</span>: <span class="number">1px</span> solid red;</div><div class="line">       &#125;</div><div class="line">       <span class="selector-tag">span</span> &#123;</div><div class="line">           <span class="attribute">line-height</span>: <span class="number">200px</span>;</div><div class="line">       &#125;</div><div class="line">      <span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">span</span>&gt;</span>文本垂直居中原理<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这样，span标签中的文字就相对于div垂直方向居中了，想要文本水平居中设置text-align：center即可。<br><img src="http://upload-images.jianshu.io/upload_images/68937-a07e7b8f4ad6ac46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"><br>那么，它怎么就垂直居中了？为了弄清楚它，下面我们先来看几个概念。</p>
<h2 id="1-行框"><a href="#1-行框" class="headerlink" title="1. 行框"></a>1. 行框</h2><p>在浏览器中，会将给每一段文本生成一个<strong>行框</strong>，行框的高度就是行高。行框由上间距、文本高度、下间距组成，上间距的距离与下间距的距离是相等的。<br><img src="http://upload-images.jianshu.io/upload_images/68937-a287041aba8e8217.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"><br>默认情况下一行文本的行高分为：上间距，文本的高度，下间距，并且上间距是等于下间距的，所以文字默认在这一行中是垂直居中的。</p>
<h2 id="2-文本中的几条线"><a href="#2-文本中的几条线" class="headerlink" title="2. 文本中的几条线"></a>2. 文本中的几条线</h2><p><img src="http://upload-images.jianshu.io/upload_images/68937-31f6657bf046e8a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"><br>几条线与行高的关系图解：<br><img src="http://upload-images.jianshu.io/upload_images/68937-c6cf627c0fb2f809.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"><br>文本的行高也可以看成是基线到基线的距离。<br><img src="http://upload-images.jianshu.io/upload_images/68937-99eddf2299822240.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.png"><br>如果一段文本的高度为16px，如果给他设置line-height的高度为200，那么相当于，文本的上下间距的高度增加了，但是文本本身的高度依然是16是不变的，并且一直默认在行框中垂直居中，而上间距和下间距平分了200px的高度并且减去文本本身的高度。所以，容器被这一行文本占满，而本身文字在自己的一行中是垂直居中的，所以看起来就像是在容器中垂直居中。</p>
<h2 id="3-Chrome浏览器的默认值"><a href="#3-Chrome浏览器的默认值" class="headerlink" title="3. Chrome浏览器的默认值"></a>3. Chrome浏览器的默认值</h2><p>谷歌浏览器字体的默认大小是：16px，字体的最小值为：12px，默认行高为：18px；默认情况下如果没有给div设置高度，那么这个div的高度会比其中文本的大小大一点（这个大多少现在没有办法确定）</p>
<h2 id="4-行高的单位"><a href="#4-行高的单位" class="headerlink" title="4. 行高的单位"></a>4. 行高的单位</h2><p><strong>px(像素)</strong><br>设置起来是最直接的，同时也最方便的。</p>
<p><strong>%(百分号)</strong><br>如果line-height单位设置为%，那么将来在计算的时候，基数是当前标签中的文本的字体的大小。<br>如果是%,%之前的数据一定是整数 ：150% ，200%</p>
<p><strong>em</strong><br>效果跟%是一样一样的。<br>注意：一行em的大小相当于是当前标签中的font-size的大小。<br>如果是em,em之前的数据一定是：1.2em ,1.5em ,2em</p>
<p><strong>不带单位</strong><br>如果不涉及到继承，那么带不带单位（em）都是一样的效果，但是如果涉及到继承的话，那么就有很大的区别了：</p>
<ul>
<li>如果单位是em，那么将来在继承的时候，我们的浏览器会先将行高对应的具体的数值计算出来以后再继承。</li>
<li>如果没有单位，那么将来在继承的时候，我们的浏览器会先将line-height这个属性继承给子元素，再在子元素的font-size来计算。line-height: 1.5。</li>
</ul>
<h2 id="5-行高可以被继承"><a href="#5-行高可以被继承" class="headerlink" title="5.行高可以被继承"></a>5.行高可以被继承</h2><p>我们知道，CSS的三大特性是继承、层叠、优先级。line-height也是可以被继承的，如下面的示例：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">	<span class="selector-class">.father</span> &#123;</div><div class="line">    	<span class="comment">/*line-height: 20px;*/</span></div><div class="line">	&#125;</div><div class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"father"</span>&gt;</span></div><div class="line">    	  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"children"</span>&gt;</span>丰趣海淘<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>在不给.father设置行高的情况下，.children的文字行高默认为18<br><img src="http://upload-images.jianshu.io/upload_images/68937-4332babc588af34c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=".children的文字行高默认为18"><br>接着我们给div设置一个行高等于20px<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.father</span> &#123;</div><div class="line">    <span class="attribute">line-height</span>: <span class="number">20px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们再来看看.children标签的的变化，.children标签的文字行高变成20px了<br><img src="http://upload-images.jianshu.io/upload_images/68937-f0b6c800786190db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=".children标签的文字行高变成20px了"><br>而且，不管我们给行高设置什么单位（px、%、em、不带单位）都可以被继承。</p>
<h2 id="6-行高计算的基数"><a href="#6-行高计算的基数" class="headerlink" title="6. 行高计算的基数"></a>6. 行高计算的基数</h2><p>如果行高的单位不是px，那么将来行高要进行计算：这个计算需要一个基数，这个基数是当前标签的字体大小，而不是浏览器默认字体大小。以上面的例子为例，我们并没有设置任何字体大小，此时我们把line-height设置为150%，那么文字的行高将变为24px（16px*1.5=24）。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span> &#123;</div><div class="line">    <span class="attribute">line-height</span>: <span class="number">150%</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>效果如下<br><img src="http://upload-images.jianshu.io/upload_images/68937-d67694bb8ccd7396.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.png"><br>此时我们在给div设置一个font-size等于20px：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span> &#123;</div><div class="line">   <span class="attribute">line-height</span>: <span class="number">150%</span>;</div><div class="line">   <span class="attribute">font-size</span>:<span class="number">20px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么文字行高将会变成30px，20px*1.5=30px;<br><img src="http://upload-images.jianshu.io/upload_images/68937-fbf1797892333859.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9.png"></p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[windows自带画板工具使用技巧]]></title>
      <url>/2016/05/13/windows%E8%87%AA%E5%B8%A6%E7%94%BB%E6%9D%BF%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<p>windows自带画板工具是一个非常不错的简单的画图和处理图片的工具，虽然功能不是很多，但是对我来说应付日常简单的需求还是够了。因为我不会PS等专业软件，有时候需要处理下图片只能去用windows自带的画图工具了，也一直用习惯了，发现很多功能的使用很多人并不清楚，很多人舍近求远的装第三方软件，比如PS、截图工具等，虽然他们的功能够强大够专业，但是对于不需要特殊的需求，有时候windows自带画板工具也就足够了。<br><a id="more"></a><br>下面我分享一下我的使用经验吧。</p>
<h1 id="截图的使用"><a href="#截图的使用" class="headerlink" title="截图的使用"></a>截图的使用</h1><p>对于使用屏幕截图想必大家第一时间肯定想到QQ了，QQ的截图确实很方便，只要登录了QQ就可以使用。但是明显的缺点就是如果在无网络环境下，QQ截图就没法使用了，这就是windows自带的截图工具登场的时候了！windows自带截图工具名称叫“SnipingTool”。</p>
<h3 id="1-在开始菜单中启动windows自带截图工具"><a href="#1-在开始菜单中启动windows自带截图工具" class="headerlink" title="1.在开始菜单中启动windows自带截图工具"></a>1.在开始菜单中启动windows自带截图工具</h3><p><img src="http://upload-images.jianshu.io/upload_images/68937-8dedabda191d025c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>打开后工具长这样：<br><img src="http://upload-images.jianshu.io/upload_images/68937-b6fea12bb0ebabfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>点击新建或者Ctrl+N就可以进行截图了，截图完成后自动粘贴到了工具中，可以立即进行简单的编辑<br><img src="http://upload-images.jianshu.io/upload_images/68937-385ee3c2fdd9b6dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="2-使用键盘截图（Prt-Sc-SysRq）"><a href="#2-使用键盘截图（Prt-Sc-SysRq）" class="headerlink" title="2.使用键盘截图（Prt Sc SysRq）"></a>2.使用键盘截图（Prt Sc SysRq）</h3><p>我们的键盘上都有一个屏幕截取键，叫“PrtSc SysRq”，根据电脑品牌不同，名称略有差异，一般在电脑（以笔记本电脑为例）键盘的右上角第三个位置，也就是在“delete”键和“Insert Num LK”键旁边。在任意界面按下它就截下了当前的电脑屏幕，只是没有任何提示而已，此时，只要打开windows自带的画板工具进行粘贴即可，就可以看到屏幕截图了。<br><img src="http://upload-images.jianshu.io/upload_images/68937-1190d9f47c69405b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h1 id="画板工具的使用"><a href="#画板工具的使用" class="headerlink" title="画板工具的使用"></a>画板工具的使用</h1><p>启动画板工具我一般直接在运行窗口输入“mspaint”即可打开。本来想在开始菜单找一下，但是我的系统是windows10的，居然一下找不到，但是我记得windows7系统上在开始菜单中是可以找到的，是作为windows附件存在的，菜单名称就叫附件。<br><img src="http://upload-images.jianshu.io/upload_images/68937-71f9f95fa8ac05d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="1-打开图片方式"><a href="#1-打开图片方式" class="headerlink" title="1.打开图片方式"></a>1.打开图片方式</h3><p>在要编辑的图片上点击右键菜单-编辑，即自动启动了windows自带画板工具打开了。或者在画板工具中点击粘贴，选择粘贴来源。<br><img src="http://upload-images.jianshu.io/upload_images/68937-386ffc3ee9be10f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="2-修改图片中的文字"><a href="#2-修改图片中的文字" class="headerlink" title="2.修改图片中的文字"></a>2.修改图片中的文字</h3><p><strong>a) 删除选中区域、抠图</strong><br>点击工具栏的选择工具，下拉可以选择形状，以矩形为例，点击后即可在页面中任意选取一块区域，可以对选中的区域进行移动，删除等<br><img src="http://upload-images.jianshu.io/upload_images/68937-c90f3727f4129f9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>选中后按下键盘delete即可删除图上的windows字样。选取后点击鼠标右键，里面可以进行剪切、复制、删除等操作。</p>
<p><strong>b) 开启网格辅助线</strong><br>查看菜单-勾选网格线<br><img src="http://upload-images.jianshu.io/upload_images/68937-0f6a0426a67bc28d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>c )去掉图片原本的文字换上新文字</strong><br>一下面的图片为例，我们去掉图片中的店字<br><img src="http://upload-images.jianshu.io/upload_images/68937-8e304b34a33095bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>首先用选取工具选中店字，然后删掉它，此时会出现一个白块，然后我们点击工具栏中的滴管，在店字的周围色块中吸取一个颜色，然后点击油漆桶，在白块中填充吸取的颜色，此时店字的白块就被和谐的填充了红色。</p>
<h3 id="3-Ctrl键技巧：复制选中的区域图片"><a href="#3-Ctrl键技巧：复制选中的区域图片" class="headerlink" title="3.Ctrl键技巧：复制选中的区域图片"></a>3.Ctrl键技巧：复制选中的区域图片</h3><p>当我们选择工具选择一块区域时，按下Ctrl键，再拖动鼠标，就可以复制前面选择的区域。比如上图中选择的店字，当我按住Ctrl键再拖动鼠标时，就可以复制一份了。<br><img src="http://upload-images.jianshu.io/upload_images/68937-643ffcb1ccc7a1c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="4-Shift键技巧：和谐延长或缩短图像"><a href="#4-Shift键技巧：和谐延长或缩短图像" class="headerlink" title="4.Shift键技巧：和谐延长或缩短图像"></a>4.Shift键技巧：和谐延长或缩短图像</h3><p>我们在画板上画一个方框如下<br><img src="http://upload-images.jianshu.io/upload_images/68937-c5659495170605c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>然后我们选择一块方框，按住Shift键，拖动鼠标往右移动，就可以延迟方框的长度，往做移动就可以缩短方框的长度，只要你水平拖动手不抖动，那么我们可以无缝的延迟方框。如果你很难做到手不抖动，那么我们 可以直接使用键盘方向键像右像素级移动</p>
<p>当然了，还有很多用法，这里只是抛砖引玉，大家可以多去尝试。</p>
]]></content>
      
        <categories>
            
            <category> 开发工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为什么你应该从现在开始使用云笔记？]]></title>
      <url>/2016/05/08/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E5%BA%94%E8%AF%A5%E4%BB%8E%E7%8E%B0%E5%9C%A8%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8%E4%BA%91%E7%AC%94%E8%AE%B0%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/68937-edbd0c914917e424.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="为知笔记.png"></p>
<p>最近看到某些新人在学习的时候还用纸和笔做笔记，一副认真的样子，我突然觉得这是什么时代了，我们处在互联网社会中，而且我们还是互联网从业者，现在还使用纸笔，这是一种低效率以及极不推荐的学习方式、记笔记方式！这就可以解释为什么有些人看起来很努力却并没有获得多大的原因。</p>
<p>至于为什么现在不推荐用纸和笔记录笔记？</p>
<ul>
<li>一是因为时代在进步，别人都在进步都在进化，而你还固守旧制，所以你+ 会跟不上别人的步伐，跟不上时代的脚步。</li>
<li>二是因为这是一种低效率的方式，速度慢，携带不便，使用限制多。</li>
<li>三是记录方式单一，只能记录文字及简笔画，存储内容也很有限。</li>
</ul>
<p>还有很多缺点…..那么就没有有点吗？有，但是，已经不那么重要了！</p>
<p>记得2010年之前，云笔记刚兴起或者还没兴起，很多人要形成自己的知识库、代码库都是用一个U盘，用文件夹分门别类，然后随身携带U盘。大概是11年，有道云笔记横空出世，于是开始使用云笔记之旅一直到现在，只用过两种云笔记，一是有道云笔记，二是为知笔记。<br><img src="http://upload-images.jianshu.io/upload_images/68937-2ff03ff4528f2b61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="有道云笔记"><br>中间也看过其他笔记，比如印象笔记、麦库等，麦库是盛大公司的，你懂的，所以不敢用→_→，不知道哪天就砍掉了，而印象笔记是老外的产品，虽然在中国独立运营，但当时收费，而且感觉老外的东西也不知道什么时候在中国就不行了，后来果不其然。还有微软的OneNote，这是非常强大的一个软件，但是OneNote的windows客户端之前不能多端同步，而UWP应用就比客户端差远了，如果用OneNote推荐使用OneNote的windows桌面客户端。Google也有笔记应用，不过相对来讲功能单一，而且需要联网，不太推荐。<br><img src="http://upload-images.jianshu.io/upload_images/68937-c0c6899bb6cfc7e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OneNote"><br>有道云笔记是网易旗有道出品的笔记软件，是我最初使用的云笔记，大概用了两年多吧，网易的很多产品都很棒，号称网易出品必属精品的说法。有道云笔记也确实是一款极优秀的笔记软件。功能还比较全面，界面也很漂亮，也有多钟分享方式还不收费，但是当时没能随意添加多级目录，最重要的是没有代码高亮功能和笔记加密，作为程序员的我经常要保存很多代码片段，没有这个功能很不友好。如果你不是程序员，那么有道云笔记应该是最好的选择。</p>
<h1 id="我与为知笔记"><a href="#我与为知笔记" class="headerlink" title="我与为知笔记"></a>我与为知笔记</h1><p>后来遇到了为知笔记，也是以前一个同事在使用，于是好奇去看了看，发现它有我最想要的代码高亮功能，虽然当时`的代码高亮功能很简陋，笔记目录可以添加多级，功能比有道云笔记丰富的多，还支持插进扩张，缺点是界面比较丑，自带的皮肤只有一款还过的去，现在分享笔记还要vip才行，有点不厚道，但为知笔记好像主打的企业级和团队，个人笔记业务并不是主打对象……。</p>
<h3 id="我的使用"><a href="#我的使用" class="headerlink" title="我的使用"></a>我的使用</h3><p>我用它来记录随笔日记、工作日志、任务列表（代办事项）、代码片段、知识库（技术栈）、网络收藏等。几年下来也沉淀了大量笔记，想要某个笔记搜索一下就出来了，不用百度或没网的时候干着急。</p>
<ul>
<li><strong> 工作日志记录</strong></li>
</ul>
<p>一直使用至今，最开始也没有什么特别的目的，工作开始就一直用它记录工作日志，倒也成了一种习惯了，每天都把要做的事列出来（todo list），然后做完一件勾上一件，方式多样，有详细的记录，也有粗略的记录，但总归要记录。<br><img src="http://upload-images.jianshu.io/upload_images/68937-bf3133362fec76ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="da5086f6-e131-42c6-b4a6-7ca6cbbccbe2.png"><br><img src="http://upload-images.jianshu.io/upload_images/68937-dede581bce7e2f6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="52181334-d4fd-448e-a38f-221f28636082.png"><br>写工作日志能直观的了解自己对工作的贡献，做过的事情，因为时间久了以前做过的事情可能就想不起来了，这时候你知道搜一下自己工作日志，就可以轻松找出自己的日志，甚至可以精确到具体某一天干了写啥（前提是你得精确的记录每一天）。</p>
<p>写工作日志只是最初的使用方式，后来我把能用云笔记做的事都放到云笔记了，有些东西在随时随地的写、编辑，多端同步。</p>
<ul>
<li><strong>搭建自己的知识库</strong></li>
</ul>
<p>这可能是使用云笔记最合适的的方式了。比如，作为一个程序员，我可以对编程语言、技术方面分类收集一些技术文章或者代码等。下面是我的一些分类目录。<br><img src="http://upload-images.jianshu.io/upload_images/68937-7ded807b4d496433.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="e3d1709f-60fc-412c-aa3d-1b5e3f0e2a93.png"></p>
<ul>
<li><strong>日记、随笔、临时性记录</strong></li>
</ul>
<p>日记、随笔等一般在手机上用、坐地铁时，或者突然来灵感、想法等时都可以方便的使用手机客户端来及时记录。当然了，我也经常在电脑上写，毕竟一天都在电脑边。<br><img src="http://upload-images.jianshu.io/upload_images/68937-599476ae50c7d7eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="acc042c4-7952-4097-b4e1-e6cdde90dd0c.png"></p>
<h1 id="使用云笔记的好处"><a href="#使用云笔记的好处" class="headerlink" title="使用云笔记的好处"></a>使用云笔记的好处</h1><ol>
<li>甩掉U盘，有了云笔记以后，我们可以将照片、文章、录音、office文件、文字数据等等一些小文件都存在云笔记里面，并命名归类。只要有网络的地方，就可以用手机或者是便携设备来查找自己需要的文件；微信、网页、任何自己觉得有用的东西都可以保留在云笔记里。</li>
<li>检索。找资料，最头疼的应该是检索，如果解决了携带的问题，那检索的问题应该是接下来最重要的了。</li>
<li>同步。一个文件自己可能做了很多的版本，一些版本在公司电脑上，一些版本在自己电脑上，工作完以后偶尔忘记复制覆盖，那么只能靠日期来分辨哪个是最新的，哪个是旧的。有了云笔记，每次编辑都会同步到云端，这样不管在哪里打开都是最新的文件。</li>
<li>记录方式多样，灵活方便。主流云笔记软件都提供浏览器插件等，网络文字和片段一键保存。</li>
<li>方便分享，云笔记软件都提供文章分享功能，可以分享文章链接、分享到微博、邮件等。</li>
<li>可以加密文章、已经多种方式导出。<br><img src="http://upload-images.jianshu.io/upload_images/68937-bd023094ff21b600.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="60cd956b-395a-471e-b003-46eeaacb531e.png"><br><img src="http://upload-images.jianshu.io/upload_images/68937-79ce4e55af8f6b7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="0198f4c4-e3fe-4405-b0f3-f774bb64d709.png"></li>
</ol>
<p><strong>从现在开始使用云笔记吧！</strong><br><strong>从现在开始使用云笔记吧！</strong><br><strong>从现在开始使用云笔记吧！</strong></p>
]]></content>
      
        <categories>
            
            <category> 随笔扯谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript的Number类型详解]]></title>
      <url>/2016/05/01/JavaScript%E7%9A%84Number%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>Number类型应该是ECMAScript中最令人关注的数据类型了，这种类型使用<a href="http://baike.baidu.com/link?url=jGdQnMf4I5CADIzPm-yqcyIzI_dvVntSYBf7eXYVaKeYpYELs-UHDNvSSnaAW4EuJTkufRBEE8FYReLLfM-D20IzVcuCXg7avjoaKeAByaq4MDHjif3SQQAIetC1ILcAJ67TfN139yI50R0nnV1Jq0AtKxkbSoR4BN3OIkU0xYe" target="_blank" rel="external">IEEE754</a>格式来表示整数和浮点数值（浮点数值在某些语言中也被称为双精度数值，比如Java）。为支持各种数值类型，<a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm" target="_blank" rel="external">ECMA-262</a>定义了不同的数值字面量格式。<br><a id="more"></a><br>最基本的数值字面量格式是十进制整数，十进制整数可以像下面这样直接在代码中输入：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> intNum = <span class="number">55</span>;    <span class="comment">// 整数</span></div></pre></td></tr></table></figure></p>
<p>除了十进制表示外，整数还可以通过八进制或十六进制的字面值来表示。其中，八进制字面值的第一位必须是0，然后八进制数字序列（0~7）。如果字面值中的数值超出了范围，那么前导0将被忽略，后面的数值将被当作十进制数值解析请看下面的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> actalNum1 = <span class="number">070</span>; <span class="comment">//八进制56</span></div><div class="line"><span class="keyword">var</span> actalNum2 = <span class="number">079</span>; <span class="comment">//无效的八进制数值——解析为79</span></div><div class="line"><span class="keyword">var</span> actalNum3 = <span class="number">08</span>; <span class="comment">//无效的八进制数值——解析为8</span></div></pre></td></tr></table></figure></p>
<p>八进制字面量在严格模式下是无效的，会导致支持该模式的JavaScript引擎抛出错误。</p>
<p>十六进制字面值的前两位必须是0x，然后跟任何十六进制数字（0~9及A~F）。其中，字母A~F可以大写，也可以小写，如下面的例子所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> hexNum1 = <span class="number">0xA</span>; <span class="comment">//十六进制的10</span></div><div class="line"><span class="keyword">var</span> hexNum2 = <span class="number">0x1f</span>; <span class="comment">//十六进制的31</span></div></pre></td></tr></table></figure></p>
<p>在进行算数计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制的数值。</p>
<h2 id="1-浮点数值"><a href="#1-浮点数值" class="headerlink" title="1. 浮点数值"></a>1. 浮点数值</h2><p>所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。虽然小数点前面可以没有整数，但我们不推荐这种写法。一下是浮点数值的几个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> floatNum1 = <span class="number">1.1</span>;</div><div class="line"><span class="keyword">var</span> floatNum2 = <span class="number">0.1</span>;</div><div class="line"><span class="keyword">var</span> floatNum3 = <span class="number">.1</span>; <span class="comment">//有效，但不推荐</span></div></pre></td></tr></table></figure></p>
<p>由于保存浮点数值需要内存空间是保存整数值的两倍，因此ECMAScript会不失时机地将浮点数值转换为整数值。显然，如果小数点后面没有任何数字，那么这个数值就可以作为整数值来保存。同样的，如果浮点数值本身表示的就是一个整数（如1.0），那么该值也会被转换为整数，如下面的例子所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> floatNum1 = <span class="number">1.</span> ; <span class="comment">//小数点后面没有数字——解析为1</span></div><div class="line"><span class="keyword">var</span> floatNum2 = <span class="number">10.0</span>; <span class="comment">//整数——解析为10</span></div></pre></td></tr></table></figure></p>
<p>对于那些极大或极小的数值，可以用e表示法（即科学计数法）表示的浮点数值表示。用e表示法表示的数值等于e前面最大的数值乘以10的指数次幂。ECMAScript中e表示法的格式也是如此，即前面是一个数值（可以是整数也可以是浮点数），中间是一个大写或小写的字母E，后面是10的幂中的指数，该幂值将用来与前面的数相乘。下面是一个使用e表示法表示数值的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> floatNum = <span class="number">3.125e7</span>; <span class="comment">//等价于31250000</span></div></pre></td></tr></table></figure></p>
<p>也可以用e表示极小的值，如0.0000000000000000003，这个值数值可以使用更简洁的3e-17表示。在默认情况下，ECMAScript会将那些小数点后面带有6个0以上的浮点数值转换为e表示法表示的数值（例如，0.0000003会被转换为3e-7）。</p>
<p>浮点数值的最高精度是17位小数，但在进行算数计算时其精度远远不如整数。例如，0.1加0.2的结果不是0.3，而是0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。</p>
<h2 id="2-NaN"><a href="#2-NaN" class="headerlink" title="2. NaN"></a>2. NaN</h2><p>NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。在ECMAScript中，任何数值除以非数值会返回NaN，因此不会影响其它代码的执行。</p>
<p>NaN本身有两个非同寻常的特点。首先，任何涉及NaN的操作（例如 NaN/10）都会返回NaN。这个特点在许多计算中可能导致问题。其次，NaN与任何值都不想等，包括NaN本身。例如下面的代码会返回false：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(<span class="literal">NaN</span> == <span class="literal">NaN</span>);    <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p>正对NaN这个特点，ECMAScript定义了一个isNaN()函数，这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”。isNaN()在接收到一个值后，会尝试将这个值转换为数值。某些不是数值的值都会直接转换为数值，例如字符串“10”或Boolean值。而任何不能被转换为数值的值都会导致这个函数返回true。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">alert(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>)); <span class="comment">//true</span></div><div class="line">alert(<span class="built_in">isNaN</span>(<span class="number">10</span>));         <span class="comment">//false（10是一个数值）</span></div><div class="line">alert(<span class="built_in">isNaN</span>(<span class="string">"10"</span>)); <span class="comment">//false（可以被转换成数值10）</span></div><div class="line">alert(<span class="built_in">isNaN</span>(<span class="string">"blue"</span>));         <span class="comment">//true（不能转换成数值）</span></div><div class="line">alert(<span class="built_in">isNaN</span>(<span class="literal">true</span>)); <span class="comment">//false（可以被转换成数值1）</span></div></pre></td></tr></table></figure></p>
<h2 id="3-数值转换"><a href="#3-数值转换" class="headerlink" title="3. 数值转换"></a>3. 数值转换</h2><p>有3个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat()。第一个函数即转型函数Number()可以用于任何数据类型，而另外两个则专门用于把字符串转换成数值。这3个函数对于同样的输入会返回不用的结果。</p>
<p>###Number()</p>
<p>Number()函数的转换规则如下：</p>
<ul>
<li>如果是Boolean值，true和false将分别转换为1和0.</li>
<li>如果是数字值，只是简单的传入和返回。</li>
<li>如果是null值，返回0。</li>
<li>如果是undefined，返回NaN。</li>
<li>如果是字符串，遵循下面的规则：<ul>
<li>如果字符串中字包含数字（包括前面带正号和负号的情况）则将弃转换为十进制数值，即“1”会变成1，“123”会变成123，而“011”会变成11；</li>
<li>如果字符串中包含有效的浮点格式，如“1.1”,则将其转换为对应的浮点数值；</li>
<li>如果字符串中包含有效的十六进制格式，例如“0xf”，则将其转换为相同大小的十进制整数值；</li>
<li>如果字符串是空的（不包含任何字符），则将其转换为0；</li>
<li>如果字符串中包含除上述格式之外的字符，则将其转换为NaN。</li>
</ul>
</li>
<li>如果是对象，则调用对象valueOf()方法，然后依照前面的规则转换返回值。如果转换的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符串值。</li>
</ul>
<p>根据这么多的规则使用Number()把各种数据类型转换为数值确实有点复杂。下面还是给出几个具体的例子吧。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="built_in">Number</span>(<span class="string">"hello world!"</span>); <span class="comment">//NaN</span></div><div class="line"><span class="keyword">var</span> num2 = <span class="built_in">Number</span>(<span class="string">""</span>); <span class="comment">//0</span></div><div class="line"><span class="keyword">var</span> num3 = <span class="built_in">Number</span>(<span class="string">"0000011"</span>); <span class="comment">//11</span></div><div class="line"><span class="keyword">var</span> num4 = <span class="built_in">Number</span>(<span class="literal">true</span>);         <span class="comment">//1</span></div></pre></td></tr></table></figure></p>
<p>###parseInt()</p>
<p>由于Number()函数在转换字符串时比较复杂而且也不够合理，因此在处理整数的时候更常用的是parseInt()函数。parseInt()函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直至找到第一个非空格字符，如果第一个字符串不是数字字符或者负号，parseInt()就会返回NaN；也就是说，用parseInt转换空字符串会返回NaN（Number()对空字符串返回0）。如果第一个字符串时数字字符，parseInt()会继续解析第一个字符串，直到解析完后续所有字符或遇到了一个非数字字符。例如“1234blue”会被转换成1234，因为“blue”会被完全忽略。类似的，<code>22.5</code>会被转换成22，因为小数点并不是有效的数字字符。</p>
<p>如果字符串中的第一个字符是数字字符，parseInt()也能够识别出各种整数格式（即前面说的十进制、八进制和十六进制数）。也就是说，如果字符串以<code>0x</code>开头且后跟数字字符，就会将其当作一个十六进制整数；如果字符串以0开头且后跟数字字符，则会将其当作一个八进制数来解析。</p>
<p>为了更好的理解parseInt()函数的转换规则，下面给出一些例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">"1234blue"</span>); <span class="comment">//1234</span></div><div class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">""</span>); <span class="comment">//NaN</span></div><div class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseInt</span>(<span class="string">"0xA"</span>); <span class="comment">//10（十六进制数）</span></div><div class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="string">"22.5"</span>); <span class="comment">//22</span></div><div class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="string">"070"</span>); <span class="comment">//56（八进制数）</span></div><div class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="string">"70"</span>); <span class="comment">//70（十进制数）</span></div><div class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="string">"0xf"</span>); <span class="comment">//15（十六进制数）</span></div></pre></td></tr></table></figure></p>
<p>在使用parseInt()解析像八进制字面量的字符串时，ECMAScript3和5存在分歧。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ECMAScript 3认为是56（八进制），ECMAScript 5认为是70（十进制）</span></div><div class="line"><span class="keyword">var</span> num = <span class="built_in">parseInt</span>(<span class="string">"070"</span>);</div></pre></td></tr></table></figure></p>
<p>为了消除在使用parseInt()函数时可能导致的上述困惑，可以为这个函数提供第二参数：转换时使用的基数（即多少进制）。如果知道要解析的值是十六进制格式的字符串，那么指定基数为16作为第二个参数，可以保证得到正确的结果，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="built_in">parseInt</span>(<span class="string">"0xAF"</span>, <span class="number">16</span>);        <span class="comment">//175</span></div></pre></td></tr></table></figure></p>
<p>实际上，如果指定了16作为第二个参数，字符串可以不带前面的“0x”，如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">"AF"</span>, <span class="number">16</span>);        <span class="comment">//175</span></div><div class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">"AF"</span>);                <span class="comment">//NaN</span></div></pre></td></tr></table></figure></p>
<p>指定基数会影响到转换的输出结果，例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">2</span>); <span class="comment">//2（按二进制解析）</span></div><div class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">8</span>); <span class="comment">//8（按八进制解析）</span></div><div class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">10</span>); <span class="comment">//10（按十进制解析）</span></div><div class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">16</span>); <span class="comment">//16（按十六进制解析）</span></div></pre></td></tr></table></figure></p>
<p>不指定基数意味着让parseInt()决定如何解析输入的字符串，因此为了避免错误的解析，我们建议无论在什么情况下都明确指定基数。</p>
<p>###parseFloat()</p>
<p>与parseInt()函数类似，parseFloat()也是从第一个字符开始解析每个字符。而且也是一直解析到字符串末尾，火鹤解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的第一个小数点是有效的，而第二个小数点时无效的了，因此，它后面的字符串将被忽略。举个例子，<code>22.34.5</code>将会被转换为<code>22.34</code>。</p>
<p>除了第一个小数点有效外，<code>parseFloat()</code>与<code>parseInt()</code>的第二个区别在于它始终都会忽略前导<code>0</code>。<code>parseFloat()</code>可以识别前面讨论过的所有浮点数值格式，也包括十进制整数格式。但十六进制格式的字符串则始终会转换成0。由于parseFloat()只解析十进制值，因此没有用第二个参数指定基数的用法。最后还要注意一点的是，如果字符串包含的是一个课解析为整数的数（没有小数点，或者小数点后面都是0），由于<code>parseFloat()</code>会返回整数。一下使用由于parseFloat()转换数值的几个典型示例。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseFloat</span>(<span class="string">"1234blue"</span>); <span class="comment">//1234</span></div><div class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseFloat</span>(<span class="string">"0xA"</span>); <span class="comment">//0</span></div><div class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseFloat</span>(<span class="string">"22.5"</span>); <span class="comment">//22.5</span></div><div class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseFloat</span>(<span class="string">"22.34.5"</span>); <span class="comment">//22.34</span></div><div class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseFloat</span>(<span class="string">"0908.5"</span>); <span class="comment">//908.5</span></div><div class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseFloat</span>(<span class="string">"3.125e7"</span>); <span class="comment">//31250000</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GitHub中Issue的使用]]></title>
      <url>/2016/04/28/GitHub%E4%B8%ADIssue%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>在软件开发过程中，开发者们为了跟踪BUG及进行软件相关讨论，进而方便管理，创建了Issue。管理Issue的系统称为BTS（Bug Tracking System，Bug跟踪系统）。当今具有代表性的BTS有<a href="http://www.redmine.org/" target="_blank" rel="external">Redmine</a>、<a href="http://trac.edgewall.org/" target="_blank" rel="external">Trac</a>、<a href="https://www.bugzilla.org/" target="_blank" rel="external">BugZilla</a>等。<br><a id="more"></a></p>
<p>GitHub自身也加入了BTS的功能。在GitHub上，可以将它作为软件开发者之间的交流工具，多多加以利用。遇到下面几种情况时，各位就可以使用这个功能。</p>
<ul>
<li>发现软件的BUG并报告</li>
<li>有事想向作者询问、探讨</li>
<li>事先列出今后准备实施的任务</li>
</ul>
<p>Issue除BUG管理之外还有许多其他用途。在软件开发者圈子中，将Issue用于多种用途的情况已经司空见惯。作为GitHub的功能之一，我们来学习Issue的一些简单用法。</p>
<h1 id="简洁且表现力丰富的描述方法"><a href="#简洁且表现力丰富的描述方法" class="headerlink" title="简洁且表现力丰富的描述方法"></a>简洁且表现力丰富的描述方法</h1><p>GitHub的Issue及评论可以使用GFM（Github Flavored Markdown）语法进行描述，从而获得丰富的表现力。比如像下图1那样描述，然后点击Preview，就可以看到图2中那种标记后的效果。<br><img src="http://upload-images.jianshu.io/upload_images/68937-489b58c766082176.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"><br>注意：“#”和后面的文字之间要有一个空格，否则无效<br><img src="http://upload-images.jianshu.io/upload_images/68937-35951cf636484f56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"><br>在文本框的下面可以找到GFM语法样式相关帮助的链接<br><img src="http://upload-images.jianshu.io/upload_images/68937-a69606d88d9b0f24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"></p>
<h3 id="1-语法高亮"><a href="#1-语法高亮" class="headerlink" title="1. 语法高亮"></a>1. 语法高亮</h3><p>假设我们像下面这样，先指定语言再描述代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> viewName = <span class="function"><span class="keyword">function</span>(<span class="params">userName</span>)</span>&#123;</div><div class="line"> alert(<span class="string">"你好，"</span> + userName +<span class="string">"，欢迎光临！"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上JavaScript代码，这样一来，代码就会自动如图3所示被添加语法高亮，变得直观易读。<br><img src="http://upload-images.jianshu.io/upload_images/68937-45eada00c19bca1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.0.png"></p>
<h3 id="2-添加图片"><a href="#2-添加图片" class="headerlink" title="2.添加图片"></a>2.添加图片</h3><p>添加图片也十分简单，只需要将图片拖拽到文本框中便可以粘贴图片。</p>
<h3 id="3-添加标签以便整理"><a href="#3-添加标签以便整理" class="headerlink" title="3.添加标签以便整理"></a>3.添加标签以便整理</h3><p>Issue可以通过添加标签（Label）来进行整理。添加标签后，Issue的标题后面就会显示标签（图4）。点击标签，还可以只显示该类标签的Issue，GitHub默认给我们设定了几个标签类型。<br><img src="http://upload-images.jianshu.io/upload_images/68937-475f9810afe1f718.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"></p>
<h3 id="4-添加里程碑以便管理"><a href="#4-添加里程碑以便管理" class="headerlink" title="4.添加里程碑以便管理"></a>4.添加里程碑以便管理</h3><p>处标签外，还可以通告添加里程碑来管理Issue。通过图5可以看出，项目距离下一个版本还有12个Issue需要实施，整体的14%已经实施完毕并Close。从这里的链接我们可以看出剩余的Issue。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-c68505fbfea9b383.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.png"></p>
<p>注意：在添加Issue时常会看到图5中这种贡献规范的链接。改仓库的根目录下添加CONTRIBUTING.md文件后该链接就会显示出来。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-76af86365c58a6d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.png"></p>
<p>规范的内容一般包括报告时Issue的描述方法、Pull Request时的规则或要求、许可证的相关信息等。为了在开源项目开发中能与其他人和谐相处，请务必在贡献之前仔细阅读这些规则。</p>
<h3 id="5-Tasklist语法"><a href="#5-Tasklist语法" class="headerlink" title="5.Tasklist语法"></a>5.Tasklist语法</h3><p>我们使用GFM的一项独有功能，那就是Tasklist(任务列表)语法。首先试着按下面的格式进行描述。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 本月要做的任务</div><div class="line">- [x] 完成部署工具的设置</div><div class="line">- [ ] 博客文章更新</div><div class="line">- [ ] 实现抽奖功能</div></pre></td></tr></table></figure></p>
<p>这样一来，这段文字就会呗标记成复选框列表的样式。这个复选框列表可以直接勾选或者取消，不必打开Issue的编辑页面重新编辑，十分方便。<br><img src="http://upload-images.jianshu.io/upload_images/68937-8aa1c37326c66970.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.png"></p>
<h1 id="通过提交信息操作Issue"><a href="#通过提交信息操作Issue" class="headerlink" title="通过提交信息操作Issue"></a>通过提交信息操作Issue</h1><p>在GitHub上，只要按照特定的格式描述提交信息，就可以像一般BTS带有的功能那样对Issue进行操作。</p>
<h3 id="Close-Issue"><a href="#Close-Issue" class="headerlink" title="Close Issue"></a>Close Issue</h3><p>如果一个处于Open状态的Issue已经处理完毕，只要在该提交中以下列任意一种格式描述提交信息，对应的Issue就会被Close。</p>
<ul>
<li>fix #24</li>
<li>fixes #24</li>
<li>fixed #24</li>
<li>close #24</li>
<li>closes #24</li>
<li>closed #24</li>
<li>resolve #24</li>
<li>resolves #24</li>
<li>resolved #24</li>
</ul>
<p>利用这个方法，每次提交并Push之后，就不必再大费周章地到GitHub的Issue中寻找相应的Issue手动Close，省去了不少麻烦。像这样，只要按照特定的格式描述提交信息，Github就会自动识别并处理，很多GitHub之外的BTS也实现了这一功能。</p>
]]></content>
      
        <categories>
            
            <category> 开发工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> github </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[小技巧！在GitHub中查看分支差别]]></title>
      <url>/2016/04/18/%E5%B0%8F%E6%8A%80%E5%B7%A7%EF%BC%81%E5%9C%A8GitHub%E4%B8%AD%E6%9F%A5%E7%9C%8B%E5%88%86%E6%94%AF%E5%B7%AE%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>在GitHub上，直接修改URL就可以让用户以多种形式查看差别。这里我以<a href="https://github.com/rails/rails" target="_blank" rel="external">Ruby on rails</a>的仓库为例，给各位介绍直接修改URL的一些技巧。<br><a id="more"></a></p>
<h1 id="查看分支之间的差别"><a href="#查看分支之间的差别" class="headerlink" title="查看分支之间的差别"></a>查看分支之间的差别</h1><p>比如我们想看1-2-stable分支与2-0-stable分支之间的差别，可以像下面这样将分支名加到URL里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/rails/rails/compare/1-2-stable...2-0-stable</div></pre></td></tr></table></figure></p>
<p>这样，就可以查看两个分支间的差别了。可以看到，有12名程序员经过1989次提交，完成了1.2版本到2.0版本的升级工作。<br><img src="http://upload-images.jianshu.io/upload_images/68937-a2d92fcb770f6b2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"></p>
<h1 id="查看与几天前的差别"><a href="#查看与几天前的差别" class="headerlink" title="查看与几天前的差别"></a>查看与几天前的差别</h1><p>加入我们想查看master分支在最近7天的差别，可以像下面这样将时间加入URL。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/rails/rails/compare/master@&#123;7.day.ago&#125;...master</div></pre></td></tr></table></figure></p>
<p>这样，就可以查看这段时间内的差别。<br><img src="http://upload-images.jianshu.io/upload_images/68937-de7ecd69d77e85fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"></p>
<ul>
<li>day</li>
<li>week</li>
<li>month</li>
<li>year</li>
</ul>
<p>指定期间可以使用以上四个时间单位。如果差别过大则不会列出所有提交，只显示最近的一部分。</p>
<h1 id="查看与指定日期之间的差别"><a href="#查看与指定日期之间的差别" class="headerlink" title="查看与指定日期之间的差别"></a>查看与指定日期之间的差别</h1><p>假如我们想看master分支2013年1月1日与现在的区别，可以将日期加入URL。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/rails/rails/compare/master@&#123;2013-01-01&#125;...master</div></pre></td></tr></table></figure></p>
<p>这样，便可以查看与指定日期之间的差别。但是如果指定日期与现在的差别过大，或者指定日期过于久远，则无法显示。<br><img src="http://upload-images.jianshu.io/upload_images/68937-d3e7bd2ae1fb09ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"></p>
]]></content>
      
        <categories>
            
            <category> 开发工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> github </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GitHub中Graphs和Settings详解]]></title>
      <url>/2016/04/14/GitHub%E4%B8%ADGraphs%E5%92%8CSettings%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="一、Graphs"><a href="#一、Graphs" class="headerlink" title="一、Graphs"></a>一、Graphs</h1><p>在GitHub中可以通过4种图标查看该仓库的相关统计信息。利用图标直观地汇总信息，可以让用户把握当前仓库的各种趋势。下面我们来了解一下每个图标所包含的信息。</p>
<h2 id="1-Contributore"><a href="#1-Contributore" class="headerlink" title="1. Contributore"></a>1. Contributore</h2><p><img src="http://upload-images.jianshu.io/upload_images/68937-513bdf608f290479.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Contributore"><br>在Contributore的4种图表中，我们可以看到每个用户在相应日期中发送提交、添加代码、删除代码的大致数量，从这里我们可以看到到该仓库的代码主要由哪些人编写。而且，还可以通过图标分析处该软件大幅修改阶段和稳定维护阶段的相应时期。</p>
<h2 id="2-commits"><a href="#2-commits" class="headerlink" title="2. commits"></a>2. commits</h2><p><img src="http://upload-images.jianshu.io/upload_images/68937-68e848112959fb93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="commits"><br>Commits Activity中显示了一年内（52周）每周收到的提交的大致数量。通过左箭头和右箭头移动，还可以查看每天的提交数量，下面的曲线相应的跟着变动。判断某个仓库是否在积极的更新时，这部分是一个重要的指标。</p>
<h2 id="3-Code-Frequency（频率）"><a href="#3-Code-Frequency（频率）" class="headerlink" title="3. Code Frequency（频率）"></a>3. Code Frequency（频率）</h2><p><img src="http://upload-images.jianshu.io/upload_images/68937-37cf30be965eb4d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Code Frequency"><br>Code Frequency中显示了该仓库中代码行数的增加量和删除量。图中基线以上绿色线条表示增加的代码数量，基线以下红色线条表示删除的代码数量。一款优秀的软件并不会一味的增加代码，在经过重构之后，代码量往往会降低，通过这张图可以直观的把握相应信息。</p>
<h2 id="4-Punch-card（穿孔卡片）"><a href="#4-Punch-card（穿孔卡片）" class="headerlink" title="4. Punch card（穿孔卡片）"></a>4. Punch card（穿孔卡片）</h2><p><img src="http://upload-images.jianshu.io/upload_images/68937-1ab8feaa97d3c061.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Punch card（穿孔卡片）"><br>从Punch card的图中可以直观地掌握一周内每天何时收到的提交最多，黑色圆圈越大鞭尸提交越频繁。仓库的关键人物通常会出现在提交频率最高的时间段，因此，用户发送的Pull Request最有可能在这段时间内被处理。大致了解时间规律，将有助于大家把握好发送Pull Request以及等待回复的时间点。另外，该软件的开发集中在早上还是晚上，从这张表中也可以一目了然，从上图中可以看出（红线），老外们都是在上午11点开始一天密集的工作，密集的提交代码，早上8、9、10点基本上是在路上和吃早餐看新闻的时间…..。</p>
<h2 id="5-Network（分支网络）"><a href="#5-Network（分支网络）" class="headerlink" title="5. Network（分支网络）"></a>5. Network（分支网络）</h2><p><img src="http://upload-images.jianshu.io/upload_images/68937-2282050cdbf31100.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Network（分支网络）"><br>以图表形式显示包括克隆仓库在内的所有分支的提交。从图上可以直观的看出每个人做了多少工作。将鼠标移到图中的点上，可以查看相应的参考内容。</p>
<h2 id="6-Members（成员）"><a href="#6-Members（成员）" class="headerlink" title="6.Members（成员）"></a>6.Members（成员）</h2><p><img src="http://upload-images.jianshu.io/upload_images/68937-335af85ea63fb142.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Members（成员）"><br>这个树型列表展示的拥有该仓库权限的、Fork并提交过代码的用户。层级关系表示的是组织下的成员。</p>
<h1 id="二、Settings"><a href="#二、Settings" class="headerlink" title="二、Settings"></a>二、Settings</h1><p>在这里可以对仓库进行任何设置。用户必须有更改权限的设置才能看到这个页面。<br><img src="http://upload-images.jianshu.io/upload_images/68937-0fea8149c1d69312.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Settings"></p>
<h2 id="1-Settings"><a href="#1-Settings" class="headerlink" title="1. Settings"></a>1. Settings</h2><p>在这里可以修改仓库名称，设置显示仓库URL时默认显示的分支。这个默认分支同时也是可以创建Pull Request时的默认值，如果各位的主分支不是master分支，建议更改这一设置。</p>
<h2 id="2-Features"><a href="#2-Features" class="headerlink" title="2.Features"></a>2.Features</h2><p>这里可以更改Wiki和Issue的相关设置。如果想关闭某些功能，只要取消勾选相应复选框即可，该功能就会从菜单中移除，无法使用。</p>
<h2 id="3-Merge-Button"><a href="#3-Merge-Button" class="headerlink" title="3. Merge Button"></a>3. Merge Button</h2><p>这里可以设置合并代码按钮的合并方式，第一个选项是是否允许合并后再提交，默认是允许的；第二个选项是指是否允许压缩、压碎提交</p>
<h2 id="4-GitHub-Pages"><a href="#4-GitHub-Pages" class="headerlink" title="4.GitHub Pages"></a>4.GitHub Pages</h2><p>GitHub有一个名为GitHub Pages的仓库，用户可以利用该仓库中资料创建WEB页面，用来发布仓库中软件的相关信息如果已经创建过Pages，则会显示相应的URL。点击Automatic Page Generator即可以自动创建GitHub Pages。</p>
<h2 id="5-Danger-Zone"><a href="#5-Danger-Zone" class="headerlink" title="5. Danger Zone"></a>5. Danger Zone</h2><p>这里是一些需要格外留意的设置，在这里用户可以将仓库改为私有或是变更仓库的所有者，甚至删除仓库本身。这些设置有可能影响到其他人，在变更时一定要谨慎。</p>
]]></content>
      
        <categories>
            
            <category> 开发工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> github </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GitHub中的Pull Request和Pulse详解]]></title>
      <url>/2016/04/12/GitHub%E4%B8%AD%E7%9A%84Pull-Request%E5%92%8CPulse%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="Pull-Request"><a href="#Pull-Request" class="headerlink" title="Pull Request"></a>Pull Request</h1><p>Pull Request是用户修改代码后向对方仓库发送采纳的请求功能，也是GitHub的核心功能，正式因为有了这个功能，才会让众多开发者轻松地加入到开源开发的队伍中来。<br><img src="http://upload-images.jianshu.io/upload_images/68937-876512a17856d823.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"></p>
<p>在Pull Request界面能查看当前处于Open状态的Pull Request。通过点击列表上方的页面特定的Pull Request就会进入详细页面选项可以重新筛选和排列。点击列表中特定Pull Request就会进入详细页面。<br><img src="http://upload-images.jianshu.io/upload_images/68937-60a7667c6eb5a999.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"></p>
<p>页面上方（红框）显示着这次时从谁的哪个分支向谁的哪个分支发送Pull Request。我们接着看每一个标签页的功能。</p>
<h3 id="Conversation（谈话、会话）"><a href="#Conversation（谈话、会话）" class="headerlink" title="Conversation（谈话、会话）"></a>Conversation（谈话、会话）</h3><p>在Conversation标签页中，可以查看与当前Pull Request相关的所有评论以及提交的历史记录。人们在这里添加评论互相探讨，发送提交落实讨论内容的整个过程会按时间顺序排列，提交日志的右侧会有该提交的哈希值（HashCode）,点击链接即可进入该提交的详细信息。</p>
<p><strong>小技巧：R键引用评论</strong><br>在Conversation中人们通过添加评论进行对话，这里有一个简单的方法可以帮助你引用一个人的评论。选中想引用的评论文字后按R键，杯选择的部分就会自动以评论语法写入评论文本框。该技巧在Issue中同样适用。<br><img src="http://upload-images.jianshu.io/upload_images/68937-b0bca40fd65fb80b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"></p>
<h3 id="Commits（提交）"><a href="#Commits（提交）" class="headerlink" title="Commits（提交）"></a>Commits（提交）</h3><p>在Commits标签页中，按时间顺序列表显示了与当前Pull Request相关的提交。标签上的数字为提交次数。每个提交右侧的哈希值可以连接到该提交的代码。<br><img src="http://upload-images.jianshu.io/upload_images/68937-f2a0814a7292bd75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"></p>
<p><strong>小技巧：在评论中添加表情</strong><br>GitHub的文化中有使用表情的习惯，不止中国人喜欢在QQ上用表情，老外其实更早更习惯用表情。表情种类繁多，要一次全记下来是否困难。这时候我们可以利用表情的自动补全功能了。</p>
<p>在评论中输入“:”（冒号）便会开启表情自动补全功能，只要输入几个与该表情相关的字母，系统就会为你筛选自动补全的对象。<br><img src="http://upload-images.jianshu.io/upload_images/68937-3e36c0ea0b5e1bf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.png"></p>
<h3 id="Files-Changed（文件变化）"><a href="#Files-Changed（文件变化）" class="headerlink" title="Files Changed（文件变化）"></a>Files Changed（文件变化）</h3><p>Files Changed表情页中可以产看当前Pull Request更改的文件内容以及前后差别。标签上的数字表示新建及被更改的文件数。</p>
<p>默认情况下系统会将空格不同也高亮显示，所以在空格有改动的情况下会难以阅读。这时候只需要在URL的末尾添加“?w=1”就可以不显示空格的差别。</p>
<p>将鼠标指针放到被更改行号的左侧，我们会看到一个加号。点击这个加号可以在代码中插入评论，这样，评论时针对哪一行代码就一目了然了。<br><img src="http://upload-images.jianshu.io/upload_images/68937-5da02eedd20c8ddb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.png"></p>
<h1 id="Pulse（活跃度）"><a href="#Pulse（活跃度）" class="headerlink" title="Pulse（活跃度）"></a>Pulse（活跃度）</h1><p>Pulse是体现该仓库软件开发活跃度的功能。近期该仓库创建了多少个Pull Request或Issue，有多少人参与了这个仓库的开发等，都可以在这里一目了然。</p>
<p>根据这个页面，用户可以判断目前这个软件是否正在被积极开发，或者有仓库修改权限的人是否在认真地进行BUG修正等维护工作。在GitHub选软件时，它可以作为一个重要的衡量标准。<br><img src="http://upload-images.jianshu.io/upload_images/68937-1d5782ac781aa249.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.png"></p>
<h3 id="active-pull-request"><a href="#active-pull-request" class="headerlink" title="active pull request"></a>active pull request</h3><p>在页面中Overview的左边部分显示了特定期间内活动过的Pull Request数。上图中有6个Pull Request，其中2个被采纳，其余4个仍然保持Open状态，剩余的这4个Pull Request将来要么会被采纳要么会被Close。</p>
<p>如果想查看清单的详细内容，只要点击对应项目即可。Pull Request的概要及链接按照合并的先后顺序排列。下图是以合并的Pull Request的概要及链接。<br><img src="http://upload-images.jianshu.io/upload_images/68937-33f0aff4a95a5c1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.png"></p>
<h3 id="active-issue"><a href="#active-issue" class="headerlink" title="active issue"></a>active issue</h3><p>在页面中Overview的右边部分显示了特定时期内活动过的Issue数。上图中有35个Issue，其中26个被Close，其余9个为Open状态。</p>
<p>如果想查看清单详细内容，只要点击对应项即可。Issue的概要及链接按照Close的先后顺序排列。</p>
<p>点击new issue则可以按创建的先后顺序查看Issue的概要及链接。<br>通过观察Issue的整体动向，用户能够知道这个软件是否有人在积极地维护与支持。对方仓库是否活跃，用户发送的BUG报告和相关探讨越可能收到回应。</p>
<h3 id="commits"><a href="#commits" class="headerlink" title="commits"></a>commits</h3><p>Overview下方显示的是与提交相关信息。左侧部分包含了如下几类信息，以上图为例：<br>编写过代码的人数（3个）<br>提交的次数（18次）<br>default branch 中修改过的文件数（3个）<br>default branch 中添加的行数（139）<br>default branch 中删除的行数（230）  </p>
<p>通过这些信息，用户可以大致把握该仓库中活跃开发者的人数。另外，右侧图标显示了这些开发者具体发送的提交数。</p>
<h3 id="Unresolved-Conversation"><a href="#Unresolved-Conversation" class="headerlink" title="Unresolved Conversation"></a>Unresolved Conversation</h3><p><img src="http://upload-images.jianshu.io/upload_images/68937-043fbcd9935a23d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9.png"><br>这个部分，列出的Issue和Pull Request都创建于Period指定的时间之前，它们都尚未Close并且仍有人参与评论。一般情况下，仓库中软件的重大事项讨论都会持续很长时间，所以这些讨论大多放在这里。其中会有不少关于该软件今后的发展方向的讨论。</p>
]]></content>
      
        <categories>
            
            <category> 开发工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> github </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[《如何阅读一本书》之公正的评断一本书]]></title>
      <url>/2016/04/02/%E3%80%8A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B%E4%B9%8B%E5%85%AC%E6%AD%A3%E7%9A%84%E8%AF%84%E6%96%AD%E4%B8%80%E6%9C%AC%E4%B9%A6/</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/68937-e0f1802b8afbda30.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="如何阅读一本书"></p>
<h2 id="一、像沟通知识一样地评论"><a href="#一、像沟通知识一样地评论" class="headerlink" title="一、像沟通知识一样地评论"></a>一、像沟通知识一样地评论</h2><p><strong>1. 阅读一本书是一种对话</strong><br>或许你不这么认为，因为作者一路说个不停，你却无法可说。如果你是这么想，你就是并不了解作为一个读者的义务——你也并没有掌握住自己的机会。事实上，读者才是最后一个说话的人。作者要说的已经说完 ，现在该读者开口了。一本书的作者与读者之间的对话，就跟平常的对话每两样。</p>
<p><strong>2. 遵守思维的礼节</strong><br>在一般的交谈中，必须双方都很有礼貌才能进行的很好。我们所说的礼貌却并不是一般社交礼仪上的礼貌。真正重要的是遵守思维的礼节，如果没有这样的礼节，谈话回变成争吵，而不是有益的沟通。</p>
<p>善意的对话最大的益处就是你能学到些什么。读者有义务也有机会回答。机会很明显，没有任何事能阻挡一个读者发表自己的评论。无论如何，在读者与书本之间的关系的本质中，有更深一层的义务关系。</p>
<p>一本好书值得主动地阅读。主动的阅读不会为了已经了解一本书在说些什么而停顿下来，<strong>必须能评论，提出批评，才算真正完成了这件事</strong>。</p>
<p>受教的美德——这是一种长期以来一直受到误解的美德。受教通常与卑躬屈漆混为一谈。一个人如果被动又顺从，可能就会被误解为他人是受教的人。相反的，受教或是能学习是一种极为主动的美德。一个人如果不能自动自发地运用独立的判断力，他根本就不能学习到任何东西。或许他可以受训练，却不能受教。因此，最能学习的读者，也就是最能批评的读者。这样的读者在最后终于能对一本书提出回应，对于作者所讨论的问题，会努力整理出自己的想法。</p>
<p><strong>3. 在没有完全了解一本书之前不要急着开始批评</strong><br>如果一本书会启发读者，就表示作者高于读者，除非读者完全了解这本书，否则不该批评的。但是等他们能这么做时，表示他们已经自我提升到与作者同样的水平了。现在他们拥有新的地位，可以运用他们的特权。如果他们现在不运用自己批评的才能，对作者来说就是不公平的事。作者已经完成他的工作——让读者与他齐头并进，这时候读者就应该表现的就像是他的同辈，可以与他对话或回复。</p>
<p><strong>在你说出“我同意”，“我不同意”，或“我暂缓评论”之前，你一定要肯定的说：“我了解了。”</strong>上述三种意见代表了所有的评论立场。我们希望你不要弄错了，以为所谓评论就是要不同意对方的说法。这是非常普片的误解。同意对方说法，与不同意对方说法都一样要花心力来做判断的。毫无理解便同意只是愚蠢，还不清楚便不同意也是无礼。</p>
<p>这么多年来教学生阅读的经验中，我们发现遵守规则的人少，违反规则的人多。学生经常完全不知道作者在说些什么就毫无犹豫的批评的批评起作者来。他们不但对自己不懂的东西表示反对意见，更糟糕的是，就算他们同意作者的观点，也无法用自己的话说出个道理来。</p>
<p>如果你在读一本好书，在你说出“我懂了”之前，最好迟疑一下，在你诚实又自信地说出这句话之前，你有一堆工作要做呢！当然，说出“我不懂”也是个很重要的评断，但这只是你尽过最大的努力之后，因为书而不是你自己的理由才能说这样的话。如果你已经尽力却任然无法理解，可能是这本书真的不能理解。对于一本书，尤其是一本好书来说，这样的假设是有利的。</p>
<p><strong>4. 不要争强好辩或盲目反对</strong><br>当你不同意作者的观点时，要理性的表达自己的意见，不要无礼的辩驳和争论。如果你知道或怀疑自己是错的，就没必要去赢得那场争辩。事实上，你赢的争辩可能真的会在世界上名噪一时，但长期来说，诚实那才是更好的策略。</p>
<p>把谈话当做是战争的人，要赢得战争就得为反对而反对，不论自己对错，都要反对成功，抱着这种态度阅读的人，只是想在书中找出反对的地方而已。这些好辨的人专门在鸡蛋里挑骨头，对自己的心态是否偏差则完全置之不顾。</p>
<p><strong>5. 在说出评论之前，你要能证明自己区别得出真正的知识与个人的观点的不同</strong><br>将知识上的不同意见看做是大致上可以解决的问题。读者要就真正的知识与他的个人观点之不同之处，做出区分。因此，除了表达赞成或反对的意见外，读者还要作出更多你的努力，他必须为自己的观点找出理由来。当然，如果他赞成作者的观点，就是他与作者分享同样的理论。但是如果他不赞成，他一定要有这么做的理论基础。否则他就是把知识当做个人观点来看待了。因此，我们说，尊重知识与个人观点的不同，在做任何评断之前，都要找出理论基础。</p>
<h2 id="二、批评观点的特别标准"><a href="#二、批评观点的特别标准" class="headerlink" title="二、批评观点的特别标准"></a>二、批评观点的特别标准</h2><ol>
<li>证明作者的知识不足</li>
<li>证明作者的知识错误</li>
<li>证明作者不符合逻辑</li>
<li>证明作者的分析与理由是不完整的</li>
</ol>
<hr>
<p>《如何阅读一本书》札记之四</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[《如何阅读一本书》之主题阅读精华摘要]]></title>
      <url>/2016/03/31/%E3%80%8A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B%E4%B9%8B%E4%B8%BB%E9%A2%98%E9%98%85%E8%AF%BB%E7%B2%BE%E5%8D%8E%E6%91%98%E8%A6%81/</url>
      <content type="html"><![CDATA[<p>在讨论某个特定的主题时，牵涉到的往往不只是一本书，我们也一再非正式的提醒过，甚至其他领域中相关的作者与书籍，都与这个特定的主题有关。在做主题阅读时，第一个要求就是知道对于特定的问题来说，所牵涉到的绝对不是一本书而已。第二个要求则是要知道就总的来说，应该读的是哪些书？第二个要求比第一个要求还难做到。<br><a id="more"></a><br>在主题阅读中有两个阶段，一个是准备阶段，另一个是主题阅读本身，让我们概括下这些不同的步骤：<br><strong>一、观察研究范围：主题阅读的准备阶段</strong></p>
<ol>
<li><p>针对你要研究读完主题，设计一份实验性的书目。你可以参考图书馆目录、专家的建议与书中的书目索引。</p>
</li>
<li><p>浏览这份书目上的所有书，确定哪些是与你主题相关，并就你的主题建立起清楚的概念。</p>
</li>
</ol>
<p><strong>二、主题阅读：阅读所有第一阶段收集到的书籍</strong></p>
<ol>
<li><p>浏览所有第一阶段被认定是与你主题相关的书，找出最相关的章节。</p>
</li>
<li><p>根据主题创造出一套中立的词汇，带引作者与你达成共识——无论作者是否实际用到这些词汇，所有的作者，或至少绝大部分的作者都可以用这套词汇来诠释。</p>
</li>
<li><p>建立一个中立的主旨，列出一连串的问题——无论作者是否明白谈过这些问题，所有的作者，或者至少绝大多数的作者都要能解读为针对这些问题提供了他们的回答。</p>
</li>
<li><p>界定主要及次要的议题。然后将作者针对各个问题的不同意见整理陈列在I各个议题之胖娃。你要记住，各个作者之间或之中，不见得一定存在着某个议题。有时候，你需要针对一些不是作者主要关心范围的事情，把他们读完观点解读，才能构建出这种议题。</p>
</li>
<li><p>分析这些讨论。这得把问题和议题按顺序排列，以求突显主题。比较有共通性的议题，要放在比较没共通性的议题之前。各个议题之间的关系也要清楚地界定出来。</p>
</li>
</ol>
<p>注意：理想上，要一直保持对话式的疏离与客观。要做到这一点，每当你要解读某个作家对一个议题的观点时，必须从他自己的文章中引出一段话来并列。</p>
<hr>
<p>《如何阅读一本书》札记之三</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[《如何阅读一本书》之如何透视一本书]]></title>
      <url>/2016/03/28/%E3%80%8A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B%E4%B9%8B%E5%A6%82%E4%BD%95%E9%80%8F%E8%A7%86%E4%B8%80%E6%9C%AC%E4%B9%A6/</url>
      <content type="html"><![CDATA[<p>上一篇<a href="/2016/03/26/《如何阅读一本书》之阅读一本书的四个层次/">《阅读一本书的四个层次》</a>已经提到，而且比较细致的说明了该如何检视阅读，这篇文章其实是第三个层次分析阅读的详细说明。<br><a id="more"></a><br><img src="http://upload-images.jianshu.io/upload_images/68937-891b746a874839dc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="如何透视一本书"></p>
<p>每一本书的封面之下都有一套自己的骨架。作为分析阅读的读者，你的责任就是要找出这个骨架。</p>
<p>当然根据书的不同，这些规则在应用时会各有不同，次序也不同。一本小说和一本政治论述的书，整体结构不同，组成的篇章不同，次序也不同。但是，任何值得阅读的一本书，都会有一个整体性与组织架构。否则这本书会显得乱七八糟根本没法读，而烂书就是如此。</p>
<h2 id="分析阅读的第一个规则是：依照书本的种类与主题作分类"><a href="#分析阅读的第一个规则是：依照书本的种类与主题作分类" class="headerlink" title="分析阅读的第一个规则是：依照书本的种类与主题作分类"></a>分析阅读的第一个规则是：依照书本的种类与主题作分类</h2><p>这个规则虽然适合所有的书籍，却特别适合用来阅读非小说，论说性的书。</p>
<p>之前我们已经建议过，一开始，你要先检视这本书——用检视阅读先浏览一遍。你读书名、副标题、目录，然后最少要看看作者序言、摘要介绍及索引。如果这本书有书衣，要看看出版者的宣传文案。这些都是作者在向你传达讯号，让你知道风朝哪个方向吹。如果你不肯停、看、听，那也不是他的错。</p>
<p>对于实用性和理论性的作品。要让知识变成实用，就要有操作的规则。我们一定要超越“<strong>知道这是怎么回事</strong>”进而明白“<strong>如果我们想做些什么，应该怎么利用它</strong>”。概括来说，也就是知与行的区别。理论性的作品是在教你这是什么，实用性的书在教你如何去做你想要做读完事情。</p>
<h2 id="分析阅读的第二个规则是：用最简短的句子说出整本书在谈些什么"><a href="#分析阅读的第二个规则是：用最简短的句子说出整本书在谈些什么" class="headerlink" title="分析阅读的第二个规则是：用最简短的句子说出整本书在谈些什么"></a>分析阅读的第二个规则是：用最简短的句子说出整本书在谈些什么</h2><p>对于“整体内容”这件事，光是一个模糊的认知是不够的，你必须要确切清楚的了解才行。只有一个方法能知道你是否成功了。你必须用几句话，告诉你自己，或别人这整本书在说什么（如果你说的话太多，表示你还没有将整本书的内容看清楚，而只是看到了多样的内容）不要满足于“感觉上的整体”，自己却说不出口。如果一个阅读者说：“我知道这本书在谈什么，但是我说不出来。”应该是连自己也骗不过的。</p>
<h2 id="分析阅读的第三个规则是：按照顺序与关系列出全书的重要部分。将全书的纲要拟出来之后，再将各个部分的纲要也要一一列出"><a href="#分析阅读的第三个规则是：按照顺序与关系列出全书的重要部分。将全书的纲要拟出来之后，再将各个部分的纲要也要一一列出" class="headerlink" title="分析阅读的第三个规则是：按照顺序与关系列出全书的重要部分。将全书的纲要拟出来之后，再将各个部分的纲要也要一一列出"></a>分析阅读的第三个规则是：按照顺序与关系列出全书的重要部分。将全书的纲要拟出来之后，再将各个部分的纲要也要一一列出</h2><p>一本书就好像一栋房子，每个部分都要很有序的排列组合在一起，每个重要部分都要有一定的独立性。就像我们看到的，每个单一部分有自己的室内架构，装潢的方式也可能跟其他部分不同。但却一定要跟其他部分连接起来——这是与功能相关——否则这个部分便无法对整体的智能架构做出任何贡献了。最好的书都有最睿智的架构，虽然他们通常比一些差一点的书要复杂一些，但他们的复杂也是一种单纯，因为他们各部分都组织的更完善也更统一。这也是为什么最好的书的也是可读性最高的书的理由之一。</p>
<h2 id="驾驭复杂的内容的技巧：为一本书拟大纲"><a href="#驾驭复杂的内容的技巧：为一本书拟大纲" class="headerlink" title="驾驭复杂的内容的技巧：为一本书拟大纲"></a>驾驭复杂的内容的技巧：为一本书拟大纲</h2><p>为什么要弄这么几个规则而不是一个？主要是为了方便。用两个步骤来掌握一个复杂又未划分的架构，要比一个步骤容易的多。第二个规则在指导你注意一本书的整体性，第三个规则在强调一本书的复杂度，当你掌握一本书的整体性时便会立刻抓住一些重要部分，但是这每个部分的本身通常很复杂，各有各的内在结构而需要你去透视。</p>
<p>根据第三个规则，可以有一套运用的公式，这个公式可以通用的。根据第二个规则，我们可以说出这本书的内容是如此这般。做完这件事后，我们可以依照第三个规则，将内容大纲排列如下：</p>
<ol>
<li>作者将全书分为五个部分，第一个部分谈什么，第二个部分谈什么，第三个部分谈的是别的事，第四部分则是另外的观点，第五部分又是另一些事。</li>
<li>第一个主要部分又分成三个段落，第一个段落为X，第二个段落为Y，第三个段落为Z。</li>
<li>在第一部分的第一阶段，作者有四个重点，第一个重点是A，第二个重点是B，第三个重点是C，第四个重点是D等等。</li>
</ol>
<p>因为没有一本书是完美的，所以也不值得为任何一本书写出一个完美的刚要。你只要尽力而为就行了。毕竟，这个规则并没有要求你将作者没有放进去的东西加在里面。你的大纲是关于作品本身的纲要，而不是这本书要谈的主题的纲要，或许某个主题的纲要可以无限延伸，但那却不是你要为这本书写的纲要——你所写的纲要对这个主题多少有点规范。</p>
<p>一本书的重点摘要可以用一两个句子，或是几段话就说明清楚了，但是对一本又长又难读的书，要写出仔细又适当的纲要，将个各部分以及个部分中不同的段落，各段落中不同的小节，一路细分到最小的结构单位都写清楚，可是要花好几页纸才能完成的工作。理论上来说，这份大纲可以比原著还要长，中世纪有些对亚里士多德的作品的注释都比原著还长。</p>
<p>本文及上一篇<a href="http://www.jianshu.com/p/3509ba947882" target="_blank" rel="external">《阅读一本书的四个层次》</a>也可以算作是一份大纲，是对《如何阅读一本书》繁多内容的归纳和整理。</p>
<h2 id="分析阅读的第四个规则：找出作者要问的问题，发现作者的意图"><a href="#分析阅读的第四个规则：找出作者要问的问题，发现作者的意图" class="headerlink" title="分析阅读的第四个规则：找出作者要问的问题，发现作者的意图"></a>分析阅读的第四个规则：找出作者要问的问题，发现作者的意图</h2><p>如果你已经在运用规则二和规则三了的话，那这一个规则就不过是换一种说法而已，你可以看出这个规则是在重复一些事情，这些事情在你掌握一本书的整体精神和重要部分的时候已经做过了，但是重复说明这个规则很有帮助，你可以用另一个角度来了解全书与各个重要部分，和能让你遵守前两条规则产生前呼后应的效果。</p>
<p>作者可能会，也可能不会告诉你他的问题是什么或答案是什么，不论他会不会做——尤其在不会的情况下——身为读者，你都有责任尽可能的精确找出这些问题来。</p>
<hr>
<p>——《如何阅读一本书》札记之二</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[《如何阅读一本书》之阅读一本书的四个层次]]></title>
      <url>/2016/03/26/%E3%80%8A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B%E4%B9%8B%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%B1%82%E6%AC%A1/</url>
      <content type="html"><![CDATA[<h2 id="第一层次，基础阅读（初级阅读、基本阅读或初步阅读）"><a href="#第一层次，基础阅读（初级阅读、基本阅读或初步阅读）" class="headerlink" title="第一层次，基础阅读（初级阅读、基本阅读或初步阅读）"></a>第一层次，基础阅读（初级阅读、基本阅读或初步阅读）</h2><p>不管哪一种名称，都指出一个人只要熟练这个层次的阅读，就摆脱了文盲状态，至少一开始认字了。在熟练这个层次的过程中，一个人可以学习到阅读的基本艺术，接受基础阅读训练，活的初步的阅读技巧，这个层次通常在小学时完成的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-93d4654b7fe97343.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="如何阅读一本书"></p>
<p>这一层次阅读你所要问得问题是：“这个句子在说什么？”</p>
<h2 id="第二层次，检视阅读"><a href="#第二层次，检视阅读" class="headerlink" title="第二层次，检视阅读"></a>第二层次，检视阅读</h2><p>特点在强调时间，在这个阅读层次，学生必须在规定的时间内完成一项阅读的功课。也可以用另外一种方式来形容这个层次的阅读，就是在一定时间内抓住一本书的重点——通常是很短的，而且总是（就其定义上说）过短，很难掌握一本书所有重点。这个层次的阅读也可以用其他称呼，譬如略读或预读，我们并不是说略读就是随意或随便浏览一本书。检视阅读是系统化略读的一门艺术。</p>
<p>用检视阅读完一本书后，无论你用了多长时间，你都该回答得出这样的问题：“这本书在谈什么？这是哪一类的书？这本书包含哪些部分？”</p>
<h3 id="检视阅读一：有系统的略读或粗读。"><a href="#检视阅读一：有系统的略读或粗读。" class="headerlink" title="检视阅读一：有系统的略读或粗读。"></a>检视阅读一：有系统的略读或粗读。</h3><ol>
<li>先看书名页，然后如果有序言就先看序。</li>
<li>研究目录页。对这本书的基础架构做概括性的理解。</li>
<li>如果书中附有索引，也要检阅一下——大多数论说类的书籍都有索引。</li>
<li>读一下出版者的介绍。</li>
<li>开始挑几个看来跟主题息息相关的篇章来看。</li>
<li>最后一步，把书打开来，东翻翻西翻翻，念一个片段，有时候连续读几页，但不要太多。</li>
</ol>
<h3 id="检视阅读二：粗浅的阅读。"><a href="#检视阅读二：粗浅的阅读。" class="headerlink" title="检视阅读二：粗浅的阅读。"></a>检视阅读二：粗浅的阅读。</h3><p>这个规则很简单：头一次面对一本难读的书的时候，从头到尾读完一遍，碰到不懂得地方不要停下来查询或思索。只注意您能理解的部分，不要为一些没法立即了解的东西而停顿，不要被一个看不懂的章节、注解、评论或参考资料阻扰或泄气。</p>
<ul>
<li><strong>阅读的速度</strong></li>
</ul>
<p>许多书其实连略读都不值得的，另外一写书只需要快速读过就行了，有少数书需要用某种速度，通常是相当慢的速度，才能完全理解。所谓阅读速度，理想上来说，不只是要能读的快，还要能用不同的速度来阅读，要知道什么时候用什么样的速度是恰当的。</p>
<p>李笑来在他的《新生，七年就是一辈子》中说道：“阅读速度”是个没用的概念，在我眼里，只有“理解速度”，理解速度快，才能有效提高阅读量。遇到好书，我会抽时间朗读完，一本二十万字左右的书朗读完，也不过十几个小时，中间断断续续，也能一个星期内搞定。更多的时候，时间花在那些需要停下来认真思考的部分，需要停下来心平气和地开开脑洞的部分，需要反复搜索寻找更多资料与关联的部分……反正，眼球快速移动本身，没有任何意义。</p>
<ul>
<li><strong>逗留与倒退</strong></li>
</ul>
<p>要矫正眼睛逗留与一点的工具有很多种，有些很复杂又很昂贵。无论如何，任何复杂的工具其实都比不上你的一双手来得有用，你可以利用双手训练自己的眼睛，跟着章节段落移动得越来越快。</p>
<ul>
<li><strong>理解的问题</strong></li>
</ul>
<p>无论速度如何，理解是最重要的。</p>
<h2 id="第三层次，分析阅读"><a href="#第三层次，分析阅读" class="headerlink" title="第三层次，分析阅读"></a>第三层次，分析阅读</h2><p>比起前两种这种阅读要更复杂，更系统化。分析阅读就是全盘阅读、完整阅读，或是说优质阅读——你能做到的最好的阅读方式。如果说检视阅读是在有限的时间内最好也最完整的阅读，那么分析阅读就是在无线的时间里，最好也最完整的阅读。</p>
<p>分析阅读是一种专注的活动，在这个层次的阅读中，读者要读到这本书成为他自己为止，分析阅读就是咀嚼与消化一本书。</p>
<h2 id="第四层次，主题阅读"><a href="#第四层次，主题阅读" class="headerlink" title="第四层次，主题阅读"></a>第四层次，主题阅读</h2><p>这是最高层次的阅读，也是阅读中最复杂也最系统化的阅读。也可以用另外的名称来形容这样的阅读，如比较阅读。</p>
<p>在做主题阅读时阅读者通常会读很多书而不是一本书，并列举出这些书之间的相关之处，提出一个所有的书都谈到的主题。借助他所阅读的书籍，主题阅读者要能够架构出一个可能在哪一本书里都没有提到过的主题阅读分析。因此，很显然的，主题阅读是最主动、也是最话力气的一种阅读。</p>
<hr>
<p>本文是《如何阅读一本书》的札记之一</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[主动选择与方法论]]></title>
      <url>/2016/03/24/%E4%B8%BB%E5%8A%A8%E9%80%89%E6%8B%A9%E4%B8%8E%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
      <content type="html"><![CDATA[<p>可能你很早就听说过这么一句话：选择比努力更重要！<br><a id="more"></a></p>
<blockquote>
<p>衡量一个人是否真正活着的根本方法，就是看他是否有意愿、有能力做出主动的选择。</p>
<p>一生随波逐流，一生逆来顺受，算不上活着，甚至生不如死。在一个关键的节点上，人必须做出主动的选择。只有这样，活着才有意义。</p>
</blockquote>
<p>李笑来在《新生——七年就是一辈子》中提出，主动选择，是重生的关键。</p>
<p>人分为两种，一种是固守型的，一种是进取型的。这两种人的主要区别在于，他们做事的时候，关注的焦点不一样：</p>
<ol>
<li>固守型的人更关注自己当时的表现，更在意外界对那表现的看法；</li>
<li>进取型的人更关注自己当时有无进步，并不在意对外界的看法；</li>
</ol>
<p>第一种人过分在意自己当时当刻的表现，直接带来的结果就是，如果“感觉有可能做不好”，就直接不做了 —— 省的丢人。第二种人常常并不在意外界的看法，他们知道自己有可能做得并不好，但这并不妨碍他们进步，只要下一次比这一次更好，就是他们想要的结果。他们更习惯于接受挑战，处理压力，更懂得积累的好处。</p>
<p>显而易见，第二种人的成长空间更大 —— 他们会变得越来越聪明。第一种人与第二种人不同的地方在于，更底层有很多根深蒂固的概念不同：</p>
<ul>
<li>固守型的人更倾向于相信智商是固定的；</li>
<li>固守型的人更倾向于认为与努力相比天份更重要；</li>
<li>固守型的人更倾向于认为命运多少是已经安排好的……</li>
</ul>
<p>进取型的人也更容易主动做出选择，去改变固有的思维定势和模式。</p>
<p>当我看到这些理论时，我陷入深思，我的经历，一半属于进取型，一半属于固守型，或者说，某段时期我是进取型，某段时期我是固守型。</p>
<p>进取型时期的我，不甘落后，不甘命运的捉弄，决心坚定，心向远方，敢于突破外界及内心固有的成见，和家人、自己、朋友的感受与看法，做自己想去做，想去改变的事情。也许是困难总会激发人们的进取心吧，压力产生动力。</p>
<p>高中学习一直不太好（很不好），无奈我长得一副好学生模样，也这样骗了很多人，包括家人、亲戚朋友，更多的是给我造成了很多压力，所有人都以为你是个学霸是个好学生的时候，其实自己都在默默的诉苦，你们走近我就知道我是什么货色，在学习上我是个学渣，不过那只是读书方面，我本人还是个好孩子的（哈哈~~）。</p>
<p>没考上大学这就是很自然的事情了，大专我也没去读，志愿被我放弃，漫长的暑假，然后被查出身患重病，不得不在家呆着，对于未来一片迷茫和死一般的黑暗，继而情绪低落，茶饭不思，为什么自己这么蠢，为什么这么渣，现在想想读书时真的一点方法论都没有，方法真的很重要。然而为什么学校从来不教我们方法论呢，都要靠自己摸索，高手都有很好的方法论，我深信（除了天才）。</p>
<p>这是我第一次的大挫折，我陷入无比的痛苦。</p>
<p>关于方法论，在《新生——七年就是一辈子》中李笑来老师也提过她母亲小时候教给他的学习方法。</p>
<blockquote>
<p>在这一点上，我非常幸运 —— 有个在图书馆工作的母亲。刚上初一的时候，母亲花了几分钟教我如何阅读教科书：<br>你看，这么厚厚一本书，其实就那么几个概念；讲一个概念就要花费一个章节的篇幅，从结构上来看，其实讲的都一样，无非是一个接一个的概念，要说清楚它是什么，它不是什么，它和别的概念有什么异同；然后就是与它相关的方法论，比如，使用的时候需要注意什么，怎样使用是正确的，怎样使用是错误的，容易发生错误的地方是什么…… 这些都弄明白了，一个概念就算是学透了，这些概念都弄明白了，这本书算是看懂了，就这么简单。</p>
<p>这其实是学习任何概念的方法论啊！我就这样“开窍”了 —— 我母亲只不过用了几分钟而已。我小时候学习成绩很好，绝对源自这几分钟的教育 —— 那一瞬间，我升级了：</p>
<ul>
<li>我懂得了概念的重要性；</li>
<li>我了解了教科书的结构…… </li>
</ul>
<p>剩下的就很自然了，我自然而然地发展出了一整套方法论：<br>新学期开始的时候，领回来教材，第一件事儿不是去“包书皮”，而是把每一章的重要概念都抄一遍，随后直接死记硬背到脑子里……</p>
<p>是否完全理解并不重要。那些将要通过学习、理解、应用、练习等手段消化吸收的概念早已经一个字不差地记在脑子里，所以我可以随时调用，没有死记硬背过的人却不一定能随时调用 —— 他们不去翻一下书断然想不起来完整具体的定义。</p>
</blockquote>
<p>不得不得感叹每个牛人背后都有高人指点啊，从上层设计上就跟普通小伙伴不一样，李笑来老师是个不折不扣的牛人，牛人之所以成为牛人都是有理论基础在背后支撑的。</p>
<p>我回想我的学习生涯，基本上没有什么方法论，也不知道方法论，教育的本质应该是授人以渔而不是授人以鱼，知识本身并不是要教给我们的重点，没有教不好的学生只有不会教的老师，这是很有道理的，只强调个人要努力刻苦学习是一种逃避思想，认为你只要比别人刻苦比别人努力就能获得比别人多的成功，我只能说，这只是必要条件而不是充分条件，这只是一方面而不是全部。</p>
<p>后来我还是不得不面对未来，我要做什么，我适合做什么已经不是我能想的清楚的事情了，事实上在当时无脑的瞎想可能永远也不会想明白自己是个什么样的人。当时也没有什么已经安排好的可以让我被动选择的事情，我只好主动去选择，于是一开始我选择了自考方式，我的另一个哥们当时和我情况差不多，他最终去了更好的武汉大学读广告学了，我由于凑不齐那么多钱，退而求其次选择了去湖南农业大学读园艺园林专业了，当年参加了成人高考。</p>
<p>在第一学期，我便深深的失望了，这不是我能承受得起的几年学业，我几乎整天泡在图书馆，对上课毫无兴趣，因为第一学都在备考成人高考，专业课还处于思想政治教育阶段，第一学期结束的寒假，我在家想了好久，终于鼓起勇气跟父母坦白，我不想去读了，当时也是我坚持去的，现在我坚持不读了，第二学期开学我直接卷铺盖回家了，什么手续都没办，剩下的学费也没交了，毅然而然的离开，跟老师和学校招呼也没打，那只当是一场梦，一场无头无尾的梦。</p>
<p>这是我的第二次大挫折，短短的半年，几乎耗尽我全部的耐心和意志。</p>
<p>强迫自己休整了一段时间，不得不从新面对，这种事逃避更加痛苦，因为你始终要面对，要面对父母，面对家人，面对别人对你的期盼。在偶然的情况下，我遇到了某IT培训机构，此后我便走上了程序员之路，一直到现在，这是我以前根本没想过的事情，因为在脑子里一直存在着某些固有的思维，认为那不是我能做到的，虽然我现在做的不够好，但如不是这样，我真的不敢想象自己现在会在干嘛，会是在东莞某个小工厂吗？可是我这小身板也是不适合进厂。</p>
<p>人生便是一念之差。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[《我们怎样读书》之为什么要学，怎么学]]></title>
      <url>/2016/03/24/%E3%80%8A%E6%88%91%E4%BB%AC%E6%80%8E%E6%A0%B7%E8%AF%BB%E4%B9%A6%E3%80%8B%E4%B9%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AD%A6/</url>
      <content type="html"><![CDATA[<blockquote>
<p>《为什么要学，怎样学》陈东原</p>
</blockquote>
<h2 id="1，学之意义"><a href="#1，学之意义" class="headerlink" title="1，学之意义"></a>1，学之意义</h2><p>学之一事，与生俱来；生即须学，学即为生。人类没有学，人类不可以生存；人类没有学，人类也无须乎生存！——一个永不进化的，荒榛单调的世界，生存在其上有什么乐趣？所以我说：“生即须学，学即为生！”</p>
<h2 id="2，自学教育与他学教育"><a href="#2，自学教育与他学教育" class="headerlink" title="2，自学教育与他学教育"></a>2，自学教育与他学教育</h2><p>每人都有两种教育：一种是得之于自己的教育，一种是受诸他人的教育。为便利起见，我们称前一种为“自学”（Self-education），那末后一种可称之为“他学”了（这不过是根据相对之理而杜撰的名词，不关紧要）。</p>
<p>自学教育比他学教育更为重要，没有谁于学问有所深到，或为科学名家，是仅由一位教师训练教诱而成的。比如我们晓得有许许多多的名人，当他们初入学校时，不是一个好学生，而到后来却会有好的结果。如威灵吞、拿破仑、牛顿、林肯都是这一类人，这不是他们自学的功能吗？</p>
<p>在事实上，有件很显明的事，就是我们用自己脑力去噙来的学问，比用耳去听来的不易忘记。所以我们倘对于学问不自己去真下一番苦功，纵说是有了结果，那果子也不是成熟的。所以这自学教育，是我们做学问的人，最应注意而最应实行的。</p>
<h2 id="3，专心与物外"><a href="#3，专心与物外" class="headerlink" title="3，专心与物外"></a>3，专心与物外</h2><p>然自学尚有一根本的基础，就是专心。不能专心的，绝得不着自学的效果。作者在讨论什么是物外的时侯举例批评了五四运动和及以后学生都以服务社会为本分，但也说，社会服务固然应当，但过度了，却是外务，足为读书之障碍。</p>
<p>在阐述各种职业的关注重心之后，得出结论，凡精神之重心力，倘离其专门事业而移到无论什么事上去了，那些事都是外务！</p>
<h2 id="4，读书的习惯与研究方法"><a href="#4，读书的习惯与研究方法" class="headerlink" title="4，读书的习惯与研究方法"></a>4，读书的习惯与研究方法</h2><p>专心不过是平日修养之一法。大概人的精神，终不免有所黏着，既能专心为学，其习惯自可养成了。但养成读书的习惯，第一，要领略着了书中的兴趣，既然领略着兴趣了，自然日日离不了它。</p>
<p>对于书籍，要有一种求得的兴趣，固然是了；但更要有一种研究的方法，研究的方法，我以为可分作五步：<br>第一步预备。当我们未去翻读那一本书之先，应有一种预备。将那本书中所要讲的，想像一过，不论所想像的与书中对不对，经过一层想像，便容易发生映像。这就与画图画的先打轮廓一样。</p>
<p>第二步吸收。预备既好，翻看书本从事吸收。这时要将所论的大体概括起来，一齐吸收到眼底。所用的精神，要像蜜蜂在花蕊上吸蜜一样；并且还要注意规则与条理。</p>
<p>第三步疑辨。既吸收了，对于所得要设疑辨难。辨清楚重要不重要，正确不正确，那重要而正确的便将他记录下来。</p>
<p>第四步记录。记录（Take Notes）不一定记录在纸上，有只须印证在脑子里的。然记录原所以帮助记忆，故很有益。不过那一种受用的学问，不但徒望其记得，还以能完全领会而实行为是。朱晦庵说得好：看书不可仅过目而止，必时复玩味，庶几忽然感悟，得到义理与践履处融会，乃为自得。 即指受用的学问说。</p>
<p>第五步运用。学得之后，当求所以运用。运用就是一种复证。或以其所学为朋友谈说，或用文字系统地写出，这都是运用之妙法。待运用之后，所学才真是他的了。</p>
<h2 id="5，集中注意力"><a href="#5，集中注意力" class="headerlink" title="5，集中注意力"></a>5，集中注意力</h2><h2 id="6，休息与运动"><a href="#6，休息与运动" class="headerlink" title="6，休息与运动"></a>6，休息与运动</h2><p>读书用心要有适量的休息，休息时又应完全将所事忘却。</p>
<p>有一种变换脑力之休息，那是极可施行的了，譬如上一点钟读英文，下一点钟习数学，因为对象不同，所用之脑的部位遂不同，此一部运用，那一部便可休息了。这个我突然想起读书的时候很讨厌一门课连着上，特别那种烧脑的课，比如数学……</p>
<h2 id="7，学问与经验"><a href="#7，学问与经验" class="headerlink" title="7，学问与经验"></a>7，学问与经验</h2><p>经验虽重要，我们不能举人世间的事一一去尝试，以获得我们经验。故弗兰格林说：经验是一个宝贵的学校，但愚人除此外无他学。倘件件事都必待我们尝试，才为经验，那我们的损失，一定不少了。而且世变无常，我们即经验一生，也经验不了呀！所以我们要思，所以我们在学的时候，贵学得运用智慧的门径。</p>
<h2 id="8，目标与兴趣"><a href="#8，目标与兴趣" class="headerlink" title="8，目标与兴趣"></a>8，目标与兴趣</h2><p>目的是无论做什么事所不可少的，尤其是读书。没有目的地读书，我们不免是盲从，若是盲从，那“惰性撒旦”就要来了。因为我们站立在浩渺无边的海洋之前，没有固定的方针，我们是不敢渡涉的呀！</p>
<p>求学的目的，当然以人生为主。所谓人生，断不是仅就低能的物质之便利。倘青年为学，一是以物质生活为目的，则那些艰苦的发明家，又何自而来呢？这样，非特学术界不得进步，即学者自身，也没丝毫价值了。</p>
<p>你看那些艰苦的发明家，虽然没有诗歌的颂扬，虽然没有金石的传载甚至于他们的名姓都湮没不闻了，但他们的事业和精神，实永存于世间而不朽。他们也未尝为此不朽的精神而发明，他们不过有爱真理的心促之使然罢了。</p>
<p>故当时虽然没有什么利益，于后世他晓得是有利益的，于自己虽没有什么利益，于世界他晓得是很有利益的；这就是他发明家目的所在，兴趣所在。我们为学之最高的目的与兴趣，也就是如此了。</p>
<p>唉，想想这世道，有几个人能纯粹的求学问呢？</p>
<hr>
<p>本书为《绝版的民国小书馆》丛书之一的《我们怎样读书》一书中《为什么要学，怎样学》的札记。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[《我们怎样读书》之为学与做人]]></title>
      <url>/2016/03/18/%E3%80%8A%E6%88%91%E4%BB%AC%E6%80%8E%E6%A0%B7%E8%AF%BB%E4%B9%A6%E3%80%8B%E4%B9%8B%E4%B8%BA%E5%AD%A6%E4%B8%8E%E5%81%9A%E4%BA%BA/</url>
      <content type="html"><![CDATA[<blockquote>
<p>为学与做人（梁启超）</p>
</blockquote>
<p>本书为《绝版的民国小书馆》丛书之一的《我们怎样读书》一书的第一章第一篇文章的札记。是在iPad mini微信读书上看的，然后记录在自带的备忘录中，遗憾的是微信读书上这本书的排版不是很好。</p>
<p>梁启超一开始便问：为什么要进学校？再问：为什么要求学问？你想学些什么？梁启超的答案是：为的是学做人！进而提出做人其实是知、情、意三部分，这三部分圆满发达的状态，我们先哲名之为“三达德”。</p>
<p>这三部分的完成状态怎么样呢？孔子说：“知者不惑，仁者不忧，勇者不惧”，所以教育应分为知育、情育、意育三方面。现在讲的智育、德育、体育，不对；德育范围太笼统，体育太狭隘。知育要教到人不惑，情育要教到人不忧，意育要教到人不惧；教育家教学生，应该以这三件为究竟，我们自动的自己教育自己，也应该以这三件为究竟。学校教育最好是能达到知情意三层，然而，梁启超也在后面说到现在的学校做不到前两层，连第三层也做得不好，学校就是个贩卖知识的杂货铺！</p>
<p><strong>1，怎样才能不惑</strong><br>最要紧是养成我们的判断力。想要养成判断力，第一步，最少须有相当的常识；进一步，对我自己要做的事须有专门知识；再进一步，还要有遇事能断的智慧。假如一个人连常识都没有，听见打雷，说是雷公发威；看见月蚀，说是虾蟆贪嘴；那么，一定闹到什么事都没有主意，碰着一点疑难问题，就靠求神问卜看相算命去解决，真所谓“大惑不解”，成了最可怜的人了。 说的也就是我们要学会独立思考。</p>
<p><strong>2，怎么样才能不忧</strong><br>梁启超花了很多篇幅阐述仁，什么是仁，仁者为什么会不忧？大凡忧之所从来，不外两端：一曰忧成败，二曰忧得失。</p>
<p>所以老子说：“生而不有，为而不恃，”“既以为人己愈有，既以与人己愈多。”你想，有这种人生观的人，还有什么得失可忧呢？总而言之，有了这种人生观，自然会觉得“天地与我并生，而万物与我为一”，自然会“无入而不自得”。他的生活，纯然是趣味化、艺术化，这是最高的情感教育，目的教人做到仁者不忧。</p>
<p><strong>3，怎样才能不惧</strong><br>第一，需要心地光明。孟子说：“浩然之气，至大至刚，行有不慊于心，则馁矣。”又说：“自反而不缩，虽褐宽博，吾不遄焉，自反而缩，虽千万人吾往矣。”俗语说得好：“生平不作亏心事，夜半敲门也不惊。<br>第二，不要为劣等欲望所牵制。被物质上无聊的嗜欲东拉西扯，那么，百炼钢也会变为绕指柔了。总之一个人的意志，由刚强变为薄弱极易，由薄弱返到刚强极难。</p>
<p>诸君啊！你千万别要以为得些断片的知识就算是有学问呀！我老实不客气告诉你罢，你如果做成一个人，知识自然是越多越好；你如果做不成一个人，知识却是越多越坏。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-28ddac18b757d05f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="我们怎样读书.jpg"></p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Sublime Text3插件安装图文教程]]></title>
      <url>/2016/02/20/Sublime-Text3%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p><strong>直接安装</strong><br>安装Sublime text 3插件很方便，可以直接下载安装包解压缩到Packages目录（菜单-&gt;preferences-&gt;packages）。<br><a id="more"></a><br><strong>使用Package Control组件安装</strong><br>也可以安装package control组件，然后直接在线安装</p>
<ul>
<li>打开package control组件网站<br><a href="https://packagecontrol.io/" target="_blank" rel="external">package control组件网站</a>，找到右侧菜单的Installation连接<br><img src="http://upload-images.jianshu.io/upload_images/68937-97e39771ea231d33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="package control组件网站"></li>
<li>复制安装代码<br>复制如下区域的代码：<br><img src="http://upload-images.jianshu.io/upload_images/68937-6ef5b9392ea5229d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="复制安装代码"></li>
<li>执行安装代码<br>按Ctrl+`调出console（Tab键上方的那个），粘贴代码到底部命令行并回车<br><img src="http://upload-images.jianshu.io/upload_images/68937-212d0c008aad8234.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="执行安装代码"><br>安装成功后会弹出重启提示框，点击OK，重启SublimeText：<br><img src="http://upload-images.jianshu.io/upload_images/68937-570e23fd7e495c34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="重启提示框"></li>
<li>重启Sublime Text 3。</li>
<li>如果在Perferences-&gt;package settings中看到package control这一项，则安装成功。<br><img src="http://upload-images.jianshu.io/upload_images/68937-5b52281b52868ca3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="安装成功"></li>
</ul>
<p><strong>用Package Control安装插件</strong></p>
<ul>
<li>按下Ctrl+Shift+P调出命令面板，输入Install命令，选择第一项回车<br><img src="http://upload-images.jianshu.io/upload_images/68937-0dde2af3c4d209d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>然后在列表中选中要安装的插件。<br><img src="http://upload-images.jianshu.io/upload_images/68937-aaa8d3946eba5503.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
</ul>
<p>选择后回车即可。</p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 工具使用 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LESS CSS使用及语法入门]]></title>
      <url>/2016/01/31/LESS-CSS%E4%BD%BF%E7%94%A8%E5%8F%8A%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h2 id="1、Less是什么？"><a href="#1、Less是什么？" class="headerlink" title="1、Less是什么？"></a>1、Less是什么？</h2><p>Less类似于jQuery</p>
<ul>
<li>LESCSS使用这个动态样式语言，属于CSS预处理语言的一种，它使用类似CSS的语法，为CSS赋予了动态语言的特性，如变量、继承、运算、函数等，更方便CSS的编写和维护。</li>
<li>LESSCSS可以在多种语言、环境中使用，包括浏览器端、桌面客户端、服务端。</li>
</ul>
<h2 id="2、编译工具"><a href="#2、编译工具" class="headerlink" title="2、编译工具"></a>2、编译工具</h2><ul>
<li>Koala编译<ul>
<li>国人开发的LESS\SASS编译工具</li>
<li>下载地址：<a href="http://koala-app.com/index-zh.html" target="_blank" rel="external">http://koala-app.com/index-zh.html</a></li>
</ul>
</li>
<li>Node.js库</li>
<li>浏览器端使用</li>
</ul>
<h2 id="3、Koala的使用"><a href="#3、Koala的使用" class="headerlink" title="3、Koala的使用"></a>3、Koala的使用</h2><ol>
<li>下载安装后，打开设置，更换语言为简体中文，然后重启。</li>
<li>新建Less项目目录如下：</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-3572e075e8a47002.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Less项目目录"></p>
<ol>
<li>在style文件夹下新建main.less文件，推荐使用用Sublime Text，打开main.less</li>
<li>把Less目录拖到Koala中，点击右键设置输出目录：</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-d4aab08fa84339b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设置输出目录"></p>
<p>输出到style/main.css中：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-36e40d198400589f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>实际上是通Koala把main.less编译成css然后写入到mian.css文件中。</p>
<ol>
<li>编译less<br>点击文件展示功能选择，选择自动编译，然后点击执行编译按钮，如果成功会提示Success。</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-9afcb494ff8b121d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="提示Success"></p>
<p>输出方式的compress是压缩后的代码，我们开发、学习阶段可以使用默认的normal方式。</p>
<ol>
<li>在HTML文件中引用css<br>打开index.html，link引用</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-78b9974e2beafb00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="link引用"></p>
<ol>
<li>测试<br>我们在main.less中写less代码，保存后就自动编译到了main.css文件中。</li>
</ol>
<h2 id="4-LEES语法"><a href="#4-LEES语法" class="headerlink" title="4.LEES语法"></a>4.LEES语法</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li>可以使用CSS中的注释 （<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">+ 也可以使用```//我不会被编译```注释。这个注释在编译时自动过滤掉</div><div class="line"></div><div class="line">### 变量</div><div class="line"></div><div class="line">Less中声明变量一定要用@开头，比如：@变量名:值</div><div class="line">```css</div><div class="line">//1.声明变量</div><div class="line">@test_width:300px;</div><div class="line">.box&#123;</div><div class="line">   //2.使用变量</div><div class="line">   width: @test_width;</div><div class="line">   height: @test_width;</div><div class="line">   border: 1px solid white;</div><div class="line">   background-color: yellow;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ul>
<p>它编译后的css文件中@test_width就直接替换为300px;了。</p>
<h3 id="混合-（Mixin）"><a href="#混合-（Mixin）" class="headerlink" title="混合 - （Mixin）"></a>混合 - （Mixin）</h3><ul>
<li>混合（mixin）变量<ul>
<li>例如：.border{border:solid 10px red;}</li>
</ul>
</li>
<li>带参数的混合<ul>
<li>.border-radius(@radius){css代码}</li>
<li>可设定默认值</li>
<li>border-radius(@radius:5px){css代码}</li>
</ul>
</li>
</ul>
<p>Less：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@test_width:300px;</div><div class="line">.box&#123;</div><div class="line">     //2.使用变量</div><div class="line">     width: @test_width;</div><div class="line">     height: @test_width;</div><div class="line">     background-color: yellow;</div><div class="line"></div><div class="line">     .border;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//混合</div><div class="line">.border&#123;</div><div class="line"> border: 5px solid pink;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.box2&#123;</div><div class="line">     .box;</div><div class="line">     margin-left: 100px;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>生成后的CSS：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">     <span class="attribute">width</span>: <span class="number">300px</span>;</div><div class="line">     <span class="attribute">height</span>: <span class="number">300px</span>;</div><div class="line">     <span class="attribute">background-color</span>: yellow;</div><div class="line">     <span class="attribute">border</span>: <span class="number">5px</span> solid pink;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.border</span> &#123;</div><div class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid pink;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.box2</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</div><div class="line">    <span class="attribute">background-color</span>: yellow;</div><div class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid pink;</div><div class="line">    <span class="attribute">margin-left</span>: <span class="number">100px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>带参数的混合，Less：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//混合 - 可带参数的</div><div class="line">.border_02(@border_width)&#123;</div><div class="line">     border: solid yellow @border_width;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.test_hunhe&#123;</div><div class="line">     .border_02(30px);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>带默认值参数的混合，Less：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.border_03(@border_width:10px)&#123;</div><div class="line">     border: solid green @border_width;</div><div class="line">&#125;</div><div class="line">.text_hunhe_03&#123;</div><div class="line">     .border_03();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在引用.border_03的时候没有传递至，那么默认的值就是10px。</p>
<h3 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h3><ul>
<li>相当于JS中的if，但不完全是</li>
<li>满足条件后才能匹配</li>
</ul>
<p>我们来看一个画三角的例子，如果你知道怎么画更好：<br>HTML：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sanjiao"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>Less：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.sanjiao</span>&#123;</div><div class="line">     <span class="attribute">width</span>: <span class="number">0</span>;</div><div class="line">     <span class="attribute">height</span>: <span class="number">0</span>;</div><div class="line">     <span class="attribute">overflow</span>: hidden;</div><div class="line">     <span class="attribute">border-width</span>: <span class="number">10px</span>;</div><div class="line">     <span class="attribute">border-color</span>: transparent transparent red transparent;</div><div class="line">     <span class="attribute">border-style</span>: dashed dashed solid dashed;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是画一个向上的三角，如果我们要改变三角的朝向，我们得改变border-color，我们得写几遍大部分都一样的代码，而用来模式匹配之后：<br>Less：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//模式匹配</div><div class="line">.triangle(top,@width:5px,@color:#ccc)&#123;</div><div class="line">     border-width: @width;</div><div class="line">     border-color: transparent transparent @color transparent;</div><div class="line">     border-style: dashed dashed solid dashed;</div><div class="line">&#125;</div><div class="line">.triangle(bottom,@width:5px,@color:#ccc)&#123;</div><div class="line">     border-width: @width;</div><div class="line">     border-color: @color transparent transparent transparent;</div><div class="line">     border-style: dashed dashed solid dashed;</div><div class="line">&#125;</div><div class="line">.triangle(left,@width:5px,@color:#ccc)&#123;</div><div class="line">     border-width: @width;</div><div class="line">     border-color: transparent @color transparent transparent;</div><div class="line">     border-style: dashed solid dashed dashed;</div><div class="line">&#125;</div><div class="line">.triangle(right,@width:5px,@color:#ccc)&#123;</div><div class="line">     border-width: @width;</div><div class="line">     border-color: transparent transparent transparent @color;</div><div class="line">     border-style: dashed dashed dashed solid;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后我们需要什么方向调用的时候就传什么方向：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.sanjiao&#123;</div><div class="line">     width: 0;</div><div class="line">     height: 0;</div><div class="line">     overflow: hidden;</div><div class="line">     .triangle(right,100px);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是，里面的width、heiht又要重写一遍，而Less给我们提供了一个东西，它不管你如何选择什么三角方向，它总会带上那个东西，有点像Java里面的finally块，无论你try块里做了什么，Java始终会执行finally块里的代码，好了，我们来看下Less班的finally如何写：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.triangle(@_,@width:5px,@color:#ccc)&#123;</div><div class="line">     width: 0;</div><div class="line">     height: 0;</div><div class="line">     overflow: hidden;</div><div class="line">&#125;</div><div class="line">.sanjiao&#123;</div><div class="line">     .triangle(right,100px);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>发现了没？就是一个“@<em>”参数！无论你选择top是right方向，带@</em>参数的triangle都会被带上，调用的时候就没必要再写width，height等。</p>
<p>如果你觉得上面比较复杂了一点，OK，我们来一个简单的例子，div定位的例子<br>HTML：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"pipei"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>写三个定位，相对定位、绝对定位和固定定位<br>Less：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//匹配模式 - 定位</div><div class="line">.post(r)&#123;</div><div class="line">     position: relative;</div><div class="line">&#125;</div><div class="line">.post(a)&#123;</div><div class="line">     position: absolute;</div><div class="line">&#125;</div><div class="line">.post(f)&#123;</div><div class="line">     position: fixed;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.pipei&#123;</div><div class="line">     width: 200px;</div><div class="line">     height: 200px;</div><div class="line">     background-color: green;</div><div class="line">     .post(r);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样，这个div就是相对定位了。</p>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>在Less中，任何数组、颜色或者变量都可以参与运算，运算应该被包裹在括号中。例如：<code>+ - * /</code></p>
<p>给宽度增加20px然后在乘以5个像素，Less：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@test_01:300px;</div><div class="line"></div><div class="line">.box_02&#123;</div><div class="line"> width: (@test_01 + 20) * 5;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="嵌套规则"><a href="#嵌套规则" class="headerlink" title="嵌套规则"></a>嵌套规则</h3><p>Less中的嵌套是最有意思的小东西了、我们创建这个一个列表：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Less的嵌套用法<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Less的嵌套用法<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Less的嵌套用法<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Less的嵌套用法<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Less的嵌套用法<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>Less：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">.list&#123;</div><div class="line">   width: 600px;</div><div class="line">   margin: 30px auto;</div><div class="line">   padding: 0;</div><div class="line">   list-style: none;</div><div class="line"> </div><div class="line">   li&#123;</div><div class="line">       height: 30px;</div><div class="line">       line-height: 30px;</div><div class="line">       background-color: pink;</div><div class="line">       margin-bottom: 5px;</div><div class="line">       padding: 0 10px;</div><div class="line">   &#125;</div><div class="line">   a&#123;</div><div class="line">       float: left;</div><div class="line">       //&amp; 代表它的上一层选择器</div><div class="line">       &amp;:hover&#123;</div><div class="line">             color: red;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   span&#123;</div><div class="line">         float: right;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它编译后生成的CSS就是这样的：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.list</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">30px</span> auto;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">list-style</span>: none;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.list</span> <span class="selector-tag">li</span> &#123;</div><div class="line">    <span class="attribute">height</span>: <span class="number">30px</span>;</div><div class="line">    <span class="attribute">line-height</span>: <span class="number">30px</span>;</div><div class="line">    <span class="attribute">background-color</span>: pink;</div><div class="line">    <span class="attribute">margin-bottom</span>: <span class="number">5px</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">10px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.list</span> <span class="selector-tag">a</span> &#123;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.list</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line">    <span class="attribute">color</span>: red;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.list</span> <span class="selector-tag">span</span> &#123;</div><div class="line">    <span class="attribute">float</span>: right;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="arguments变量"><a href="#arguments变量" class="headerlink" title="@arguments变量"></a>@arguments变量</h3><p>@arguments包含了所有传递进来的参数。如果你不想单独处理每一个参数的话就可以像这样写：<br>Less：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.border_arg(@w:30px,@c:red,@xx:solid)&#123;</div><div class="line">   border: @arguments;</div><div class="line">&#125;</div><div class="line">.test_arguments&#123;</div><div class="line">   .border_arg();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样@arguments就自动帮我们注入了所有的参数，省了那么一丢丢的代码。</p>
<h3 id="避免编译、-important以及总结"><a href="#避免编译、-important以及总结" class="headerlink" title="避免编译、!important以及总结"></a>避免编译、!important以及总结</h3><p><strong>避免编译</strong></p>
<ul>
<li>有时候我们不需要输出一些不正确的CSS语法或使用一些Less不认识的专有语法。</li>
<li>要输出这样的值，我们可以在字符串前加一个~，例如：width:~’clac(100% - 35)’</li>
</ul>
<p>Less：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.test_03</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="built_in">calc</span>(200px - 30px);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样的话，编译后的CSS就自动帮你计算了<br>CSS：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.test_03</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="built_in">calc</span>(170px);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但我们并不想它在编译时被计算，而是想让浏览器去计算，这时候我们就需要添加~符号了：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.test_03</span>&#123;</div><div class="line">     <span class="attribute">width</span>: ~<span class="string">'calc(200px - 30px)'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样，就可以避免编译，输出的CSS就是这样（原样输出）<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.test_03</span> &#123;</div><div class="line">      <span class="attribute">width</span>: <span class="built_in">calc</span>(200px - 30px);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>!important关键字</strong><br>会为所有混合所带来的样式，添加!important</p>
<p>更多语法和文档请访问LESS中文网站：</p>
<ul>
<li><a href="http://www.bootcss.com/p/lesscss/" target="_blank" rel="external">http://www.bootcss.com/p/lesscss/</a></li>
<li><a href="http://www.1024i.com/demo/less/index.html" target="_blank" rel="external">http://www.1024i.com/demo/less/index.html</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> less </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Review of 2015 年度回顾]]></title>
      <url>/2016/01/31/Review-of-2015-%E5%B9%B4%E5%BA%A6%E5%9B%9E%E9%A1%BE/</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/68937-8a804ecbd2b522ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Review of 2015 年度回顾"></p>
<p>突然，各个社交圈都在狂晒年度Review，或者Plan，所以我被激到了。</p>
<p>写Review和总结是一个挣扎的过程，尤其是在公开的地方写，鉴于一些事情，种种原因，并不适合掏心掏肺一一直白，那么，只说我想说的，屏蔽我不想让你知道的。</p>
<p>好像是第一次写年度Review，年度Plan倒是写过，比如某年在空间写了年度阅读Plan，呵呵，青葱岁月，稚嫩，其实没做到，没有读懂这个世界，过着唯心主义生活，而，这个世界是唯物的。</p>
<blockquote>
<p>风平浪不静</p>
</blockquote>
<p>这个单词，是我开始写这篇Reivew的时候最先冒出到脑海的词，即是我的恐惧，也是我的变化。</p>
<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>2014年10月11月偷偷面试，11月提出离职，11月25日到新东家报道，26日到了顺丰上海的一个项目组，做了2个月后项目陆续关闭，作为一个传统行业企业，没有互联网基因，政策多变，关闭也不奇怪了，殊不知最先做的顺丰优选也被后起之秀嘿客合并，呵呵，2016年元旦，到顺丰另一个海淘项目组，一直到到现在，项目组已经脱离顺丰独立运营，现在叫<a href="http://www.fengqu.com" target="_blank" rel="external">丰趣海淘</a>，不过，还是有深深的顺丰烙印。</p>
<p>2015年工作上算是很平静，一直安静的呆在这个公司，风平浪静，也没有发生多大的风波，有点尴尬的是，我应该是唯一一个被研发总监问过三次早上来的有点晚的人，多亏老大帮我顶着，说谎我说上下班要4个小时（我也是佩服老大）</p>
<p>公司此前在上海的漕河泾开发区，离我住的地方很近，地铁15分钟就到了，2016年1月公司搬到了上海普陀区的长丰公园，据说挑这地是请风水大师看的，我也醉了！~~~~这都算了，这一下子上下班就很远了。</p>
<h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>额额~~这个也是没什么好说的，平平淡淡，每天两点一线。对了，偶尔团建一下，出去小嗨皮一下。</p>
<h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>大部分是都是工作上的，这个公司让我长了见识，用的技术都还挺潮的，版本控制与代码管理是Git和GitLab、开发工具都是用IntelliJ IDEA，这个工具以前在学校接触过，但一直没用它写过代码，用了一年IDEA感觉Eclipse都好古老的感觉，虽然Eclipse超级面熟。代码发布是jenkins，这个我之前压根没听过；知识管理是 Confluence，</p>
<p>写了服务端、也写了小二后台、与产品、测试、运营等不同人员配合完成项目。这样的开发方式是我以前没经历过的，也知道了关于项目测试、发布流程，需求的提出、评审到开发这个流程。</p>
<p>服务端是用Java写的，运营后台是Java与Groovy混合使用，Groovy以前也没听过，刚开始还很担心，还好它如此简单，差不多就是Java的简写版吧，UI是EasyUI，这个倒是很熟了，前一个公司我就在用，还自定义了一套<a href="http://www.mybry.com/products/easyUI-themes/index.html" target="_blank" rel="external">仿window8风格的主题</a>|<a href="https://github.com/dunizb/JQEasyUI-SolidMetroBlue-Themes" target="_blank" rel="external">GitHub</a>。</p>
<p>公司还有一个互联网公司都有的各部门，产品、研发、运营、运维、测试等，我以前的那些小公司都没有这些，回想起来真的很蛋疼！除了研发和运营，其他工种和部门我还是头一次遇见，之前不知道运维到底是干嘛的，都做些什么，对测试的理解也很片面，现在想起来以前的我都是兼任这些工种啊，自己脑补设计、自己撸代码、自己点一点测一测，自己运维、、、那都是些什么破公司！感觉好牛逼的样子…..。</p>
<p>公司技术基本上是出自阿里系，创业团队都是从阿里出来的，核心员工也是各大互联网公司挖角的，什么唯品会、一号店、大智慧之类的，我不在此列…….</p>
<p>实话说，我本来是个Java程序员，但我发现更多的偏前端了，Java离我感觉渐行渐远了，也好，我也对JavaEE失去了兴趣，2016年正式转战WEB前端开发！公司也有团队做大数据、推荐、搜索，都很高大上的东西。</p>
<p>学习了Bootstrap，年末还发现家里好多书，这对于搬家很不不利啊，于是索性用刚学到的知识写了个卖书的页面挂在博客上，叫<a href="[http://www.mybry.com/products/store/list.html">旧物商店</a>，后来在听罗辑思维的节目，发现他们在用有赞，于是我也搞了个<a href="https://shop15634529.koudaitong.com/v2/showcase/homepage?alias=ya7nfhf7&amp;type=share_shop&amp;share=wxd_ext&amp;mtd=sh_ext_wxd" target="_blank" rel="external">微信商城</a>主要的目的是出售旧书了，不过这东西除了发朋友圈和微博外，不知道怎么推广，几乎就是弄着好玩罢了。</p>
<p>学习了LESS CSS这个动态样式语言，但没有用它写过项目</p>
<h3 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h3><p>自从工作后再也没怎么看过书了，不管技术书还是其他书，不是没有书，而是摆在那里也没看，稀稀拉拉的看完一些书，桌子上书有很多，但总是不想看，一是技术书一般需要慢慢的看，大部分很厚，所以想用零碎时间看也不好弄；而是大部分时候下班回家什么也不想做，不想动，用手机看看新闻什么的就算过去了，周末呢？好吧，其实这个再找接口就不合适了……</p>
<p>谈谈电子书吧。以前，我很讨厌电子书，觉得很糟糕，我绝对不会看电子书，除非一些快餐类的书，但是现在，我要给自己打脸了，我倾向于电子书了，只要有电子版，我会极度谨慎的考虑要不要买纸质书了，因为，作为一个打工仔，我们是租房子住的，你懂得，如果是自己家，完全无须顾虑，买买买！</p>
<p>自从有了多看，我对电子书的反抗越来越低，相反，越来越喜欢，现在也经常看一些需要深度阅读的书了，也看技术书，多看的电子书真的很精美，多看上显示我读过215本（包括杂志），读完100本，阅读总时长227小时，大部分时间都是上下班和零碎时间看的，手机居多，现在有了ipad后，看一些书更爽。电子书查找笔记、书签、章节真的很方便。</p>
<p>回忆一下看过的纸书：</p>
<ul>
<li><a href="http://www.mybry.com/products/store/list.html" target="_blank" rel="external">《毛泽东选集第一卷》</a></li>
<li><a href="http://www.mybry.com/products/store/list.html" target="_blank" rel="external">《编写高质量代码：WEB前端开发修炼之道》</a></li>
<li><a href="http://detail.koudaitong.com/show/goods?alias=3nu3x9vlbwzq1&amp;reft=1454320764825&amp;spm=h14598865" target="_blank" rel="external">《程序员的数学》</a></li>
<li><a href="http://detail.koudaitong.com/show/goods?alias=2xlc890z5tgux&amp;reft=1454320681808&amp;spm=h14598865" target="_blank" rel="external">《浪潮之巅全三册》</a></li>
<li><a href="http://detail.koudaitong.com/show/goods?alias=2xcph3otu3dxl&amp;reft=1454320738353&amp;spm=h14598865" target="_blank" rel="external">《数学之美》</a>- 《图解HTTP》</li>
<li>《JavaScript语言精粹》</li>
<li>《经济学原理微观分册》</li>
<li><a href="http://detail.koudaitong.com/show/goods?alias=365aad01zfh61&amp;reft=1454320627038&amp;spm=h14598865" target="_blank" rel="external">《暗时间》</a>- - 《揭秘跨境电商》</li>
</ul>
<p>回一下看过的多看电子书：</p>
<ul>
<li>《知乎周刊》</li>
<li>《JavaScript基础教程》</li>
<li>《HTML5秘籍》</li>
<li>《明朝的那些事儿》</li>
<li>《MacTalk-人生元编程》</li>
<li>《我是一只IT小小鸟》</li>
<li>《重说中国近现代史》</li>
<li>《战争就是这么回事儿》</li>
<li>《太平天国十四年》</li>
<li>《各种杂志》若干等等……</li>
</ul>
<h3 id="玩耍"><a href="#玩耍" class="headerlink" title="玩耍"></a>玩耍</h3><p>这些都集中在上半年。</p>
<p>4还是5月份，记不清了，公司组织了一次户外拓展，在腾格里沙漠，这个算是2015年最有意思的一次了，想来以后很少有机会跑去内蒙古，跑去沙漠里，深入沙漠，有文记录：<a href="http://www.mybry.com/?p=111" target="_blank" rel="external">《屌爆了 | 公司拓展去沙漠是怎样一种体验？》</a>。</p>
<p>清明节的时候去了江西婺源，这个地方进年人气很高，唉，清明节还真不适合出去，多雨，而且地处江南，尼玛下了两天整的雨啊，油菜花都被雨打没了，我看到的全是绿油油的一篇，一点黄的都没有，</p>
<p>后来去了成都，也是第一次飞到西部地区，由于时间有限，只在成都市转了转，主要去了大熊猫繁育基地，结果那天天气高温，人也超多，一只外出活动的阿宝都没看到，50块钱门票就相当于看了下公园。</p>
<p>此后下半年再也没出去过了。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>2014年低终于开通了自己的这个博客，WordPress博客系统，托管在新浪SAE上，域名买自阿里云万网，今年开通了使用百度云加速，图片存在UPYUN和新浪云Storage，目前一切正常。</p>
<p>2015年底我的GitHub也终于活了（以前开通后就没用过了，相当于从待回收状态重新变为激活状态）。把那个自定义的EasyUI仿windows8放了上去，还改了一个别人的wordpress插件，这个插件是用来在每篇文章下生成微信打赏的功能，具体见<a href="https://github.com/dunizb/wechat-reward/tree/yellowThemes" target="_blank" rel="external">GitHub</a>吧。</p>
<p>好像没什么了，没什么写的了，就这样吧。</p>
<p>2016年4月中旬我会离职（这里老板应该看不到）…………….</p>
]]></content>
      
        <categories>
            
            <category> 随笔扯谈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS检测图片的宽高和Image对象]]></title>
      <url>/2016/01/04/JS%E6%A3%80%E6%B5%8B%E5%9B%BE%E7%89%87%E7%9A%84%E5%AE%BD%E9%AB%98%E5%92%8CImage%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<p>在一些页面中我们需要限制图片的规格，也就是宽、高。我们可有用JS来实现，关键是得到图片的绝对地址src,还有JavaScript的Image()对象，给这个对象指定src属性即可获取这个图片的width、height，我们以下面这个图片为例（<a href="http://www.mybry.com" target="_blank" rel="external">本博客</a>LOGO图标）<br><img src="http://upload-images.jianshu.io/upload_images/68937-44928949b2c7ef00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>它的宽度为36，高度为39，代码如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS检测上传图片的规格<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> image = <span class="keyword">new</span> Image();</div><div class="line">    <span class="keyword">var</span> imgSrc = <span class="string">"http://2.duni.sinaapp.com/logo.png"</span>;</div><div class="line">    image.src = imgSrc;</div><div class="line">    image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> width = image.width;</div><div class="line">        <span class="keyword">var</span> height = image.height;</div><div class="line">        <span class="built_in">console</span>.info(<span class="string">"width："</span>+width+<span class="string">"，height："</span>+height);</div><div class="line">    &#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-2890b2ccba550f2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h3 id="HTML-DOM-Image对象"><a href="#HTML-DOM-Image对象" class="headerlink" title="HTML DOM Image对象**"></a>HTML DOM Image对象**</h3><p>Image 对象代表嵌入的图像。 标签每出现一次，一个 Image 对象就会被创建。</p>
<h3 id="Image-对象的属性"><a href="#Image-对象的属性" class="headerlink" title="Image 对象的属性**"></a>Image 对象的属性**</h3><p>除了id、name、src、alt、width、height、border、className、title等标准属性外，下面列出Image对象的其他重要属性：</p>
<p><strong>align</strong><br>设置或返回与内联内容的对齐方式。可选值：left|right|top|middle|bottom</p>
<p><strong>complete</strong><br>返回浏览器是否已完成对图像的加载。如果加载完成，则返回 true，否则返回 fasle。</p>
<p><strong>hspace</strong><br>设置或返回图像左侧和右侧的空白。hspace 属性可设置或返回图像的左边缘和右边缘的空白。hspace 和 vspace 属性可与 align 一同使用，来设置图像与周围文本的距</p>
<p><strong>isMap</strong><br>返回图像是否是服务器端的图像映射。</p>
<p><strong>longDesc</strong><br>设置或返回指向包含图像描述的文档的 URL。</p>
<p><strong>lowsrc</strong><br>设置或返回指向图像的低分辨率版本的 URL。</p>
<p><strong>useMap</strong><br>设置或返回客户端图像映射的 usemap 属性的值。</p>
<p><strong>vspace</strong><br>设置或返回图像的顶部和底部的空白。</p>
<h3 id="Image-对象的事件句柄"><a href="#Image-对象的事件句柄" class="headerlink" title="Image 对象的事件句柄"></a>Image 对象的事件句柄</h3><p><strong>onerror</strong><br>在装载图像的过程中发生错误时调用的事件句柄。</p>
<p><strong>onabort</strong><br>当用户放弃图像的装载时调用的事件句柄。</p>
<p><strong>onload</strong><br>当图像装载完毕时调用的事件句柄。</p>
<h3 id="onLoad-事件处理器"><a href="#onLoad-事件处理器" class="headerlink" title="onLoad() 事件处理器"></a>onLoad() 事件处理器</h3><p>像很多 JavaScript 的其它对象一样，Image() 对象也有一些事件处理器。其中最有用的一个肯定是 onLoad() 处理器，它在图像完全载入之后调用。这个事件处理器可以与一个自定义函数联系起来，以在图像完全载入之后执行一些特定的任务。下面的例子说明了这一点，在这个例子中，首先在图像载入时显示一个“please wait”屏幕，然后在载入完成时将浏览器转到一个新的 URL。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">"JavaScript"</span>&gt;</span><span class="javascript"> </span></div><div class="line"><span class="comment">// 创建一个Image对象</span></div><div class="line"><span class="keyword">var</span> objImage =  <span class="keyword">new</span>  Image(); </div><div class="line"><span class="comment">// 图像加载完成就会调用 objImage.onLoad=imagesLoaded(); </span></div><div class="line"><span class="comment">// 预加载图像文件</span></div><div class="line">objImage.src=<span class="string">"http://img0.sfht.com/cmsres/20151030/4704a64f-8d6d-4a82-ab11-62d914531a44.jpeg"</span>;</div><div class="line"><span class="comment">// 图像加载完的函数调用</span></div><div class="line">objImage.onLoad = imagesLoaded();</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">imagesLoaded</span>(<span class="params"></span>) </span>&#123; </div><div class="line">      <span class="built_in">document</span>.location.href=<span class="string">"http://www.mybry.com/"</span>; </div><div class="line">&#125; </div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </div><div class="line">        请等待，正在加载图片.... </div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript面向对象程序设计基础]]></title>
      <url>/2015/09/02/JavaScript-Object-Oriented-Programming-Basics/</url>
      <content type="html"><![CDATA[<h2 id="一、对象"><a href="#一、对象" class="headerlink" title="一、对象"></a>一、对象</h2><p>JavaScript的简单数据类型包括数字、字符串、布尔值、null值和undefined值。其他所有的值都是对象。数字、字符串和布尔值“貌似”对象，因为它们拥有方法，但它们是不可变的。JavaScript中的对象是可变的键控集合（Keyed collections）。在JavaScript中，数组时对象，函数是对象，正在表达式是对象，当然，对象自然也是对象。</p>
<p>对象是属性的集合，每一个属性具有一个名称和一个值。数学的名字可以是包括空字符串在内的任意字符串。属性值可以是除undefined值之外的任何值。</p>
<p>JavaScript里的对象是无类型的（class-free）。它对新属性的名字和值是没有限制的。对象适合用于汇集和管理数据。对象可以保护其他对象，所以它们可以很容易的表示成树状或图形结构。</p>
<h3 id="1、创建（Create）"><a href="#1、创建（Create）" class="headerlink" title="1、创建（Create）"></a>1、创建（Create）</h3><p>可以采用两种方法来实例化对象。</p>
<p><strong>第一种方法是使用new关键字</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myObject = <span class="keyword">new</span> <span class="built_in">Object</span>();</div></pre></td></tr></table></figure></p>
<p>new 关键字调用构造函数，或者更通用的说法是构造器。构造器将初始化新创建的对象。下面的代码演示了一个名为Zombie（僵尸）对象的构造器，构造器初始化该对象的name属性，然后使用new关键字实例化一个Zombie对象。this关键字用于引用当前对象，不能对它进行赋值，但可以将this关键字的值赋给另外一个变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Zombie</span>(<span class="params"> name </span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> smallZombie = <span class="keyword">new</span> Zombie( <span class="string">"Booger"</span>);</div></pre></td></tr></table></figure></p>
<p><strong>使用对象字面量创建对象</strong><br>另外一种实例化新对象的方法更加方便：使用对象字面量，这种方式创建的对象更像其他语言中的散列（hash）或关联数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myObject = &#123; &#125;;</div><div class="line"><span class="keyword">var</span> webSite= &#123;</div><div class="line">    <span class="string">"url"</span>: <span class="string">"www.mybry.com"</span>,</div><div class="line">    <span class="string">"siteName"</span>: <span class="string">"读你"</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在属性列表的最后一项值的末尾，请不要使用结尾逗号。不同的浏览器对此的解析并不一致。</p>
<h3 id="2、检索（Retrieval）"><a href="#2、检索（Retrieval）" class="headerlink" title="2、检索（Retrieval）"></a>2、检索（Retrieval）</h3><p>既可以使用方括号来访问对象的属性，也可以使用点操作符来访问。下面的代码示例了者两种方式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">webSite[<span class="string">'url'</span>];</div><div class="line"><span class="string">"www.mybry.com"</span></div><div class="line">webSite.siteName;</div><div class="line"></div><div class="line"><span class="string">"读你"</span></div></pre></td></tr></table></figure></p>
<p>采用方括号方式访问属性时，可以使用JavaScript的关键字作为属性名，但不推荐这样做，使用点操作符方式访问属性时则不能使用。使用点操作符方式，代码更加简短。JSLint鼓励开发人员使用点操作符方式。因为属性也可以是对象，可以在任意层次上嵌套对象。 </p>
<p>下面假设有一个父亲father对象，他有自己的名字name和年龄age，他有两个儿子childrenOne和childrenTwo，两个孩子当然也是对象，也有名字name个年龄age，然后我们访问孩子childrenOne的名字：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> father = &#123;</div><div class="line">  <span class="string">'name'</span>: <span class="string">'zhangsan'</span>,</div><div class="line">  <span class="string">'age'</span>: <span class="number">50</span>,</div><div class="line">  <span class="string">'childrenOne'</span>: &#123;</div><div class="line">    <span class="string">'name'</span>: <span class="string">'zhangsi'</span>,</div><div class="line">    <span class="string">'age'</span>: <span class="number">22</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">'childrenTwo'</span>: &#123;</div><div class="line">    <span class="string">'name'</span>: <span class="string">'zhangwu'</span>,</div><div class="line">    <span class="string">'age'</span>: <span class="number">12</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(father.childrenOne.name);</div><div class="line"><span class="comment">//输出：zhangsi</span></div></pre></td></tr></table></figure></p>
<p>JavaScript是一种动态的语言，因此更新一个属性只需要重新对属性赋值即可。要从对象中移除一个属性，只需要使用delete操作符。删除一个不存在的属性并不会造成任何危险。要遍历对象的所有属性，可以使用for…in循环，比如下面的代码块：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">  <span class="string">'properties1'</span>: <span class="number">1</span>,</div><div class="line">  <span class="string">'properties2'</span>: <span class="number">2</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> i;</div><div class="line"><span class="keyword">for</span>( i <span class="keyword">in</span> obj1 )&#123;</div><div class="line">  <span class="built_in">console</span>.log( i );</div><div class="line">&#125;</div><div class="line"></div><div class="line">properties1</div><div class="line">properties2</div></pre></td></tr></table></figure></p>
<h3 id="3、原型（Prototype）"><a href="#3、原型（Prototype）" class="headerlink" title="3、原型（Prototype）"></a>3、原型（Prototype）</h3><p>JavaScript使用原型继承（prototype inheritance），对象直接从其他对象继承，从而创建新的对象。简而言之，对象继承了另外一个对象的属性。JavaScript中没有类，这是与Java和C#等语言相比一个较大的差别。原型就是其他对象的模型（model）。</p>
<p>每个对象都连接到一个原型对象，并且它可以从中继承属性。所有通过对象字面量创建的对象都连接到Object.prototypr，它是JavaScript中的标配对象。</p>
<p>当你创建一个新对象时，你可以选择某个对象作为它的原型。JavaScript提供的实现机制杂乱而复杂，但其实可以被明显地简化。我们将给Object对象增加一个create方法。这个方法创建一个使用原型对象作为其原型的新对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.beget !== <span class="string">'function'</span>) &#123;</div><div class="line">  <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</div><div class="line">    F.prototype = o;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> another = <span class="built_in">Object</span>.create( webSite );</div><div class="line"><span class="built_in">console</span>.log(another);</div><div class="line"><span class="string">``</span><span class="string">`    </span></div><div class="line">在firebug中输出如下结果，正是一个对象。</div><div class="line"></div><div class="line">原型连接在更新时是不起作用的。当我们对某个对象做出改变时，不会触及该对象的原型，原型连接只有在检索值的时候才会被用到。如果我们尝试去获取对象的某个属性值，但该对象没有此属性名，那么JavaScript会试着从原型对象中获取属性值。如果那个原型对象也没有该属性，那么再从他的原型中寻找，以此类推，直到该过程最后到达终点Object.prototype。如果想要的属性完全不存在与原型链中，那么结果就是undefined值。这个过程称为委托。</div><div class="line"></div><div class="line">原型关系是一种动态关系。如果我们添加一个新的属性到原型中，该属性会立即对所有基于该原型创建的对象可见。（更多关于原型链的内容后续文章将会介绍）</div><div class="line"></div><div class="line">### 4、引用（Reference）</div><div class="line">引用是一个指向对象实例位置的指针。Object是引用类型，由于所有对象都是通过引用传递的，，它们永远不会被复制：</div><div class="line">`<span class="string">``</span>js</div><div class="line"><span class="keyword">var</span> x = myObject;</div><div class="line">x.nickname = <span class="string">'这世间唯有梦想和好姑娘不可辜负~~~'</span>;</div><div class="line"><span class="keyword">var</span> nick = myObject.nickname;</div><div class="line"><span class="comment">//因为x和stooge是指向同一个对象的引用，所以nick为‘zhangsan’</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(nick); <span class="comment">//这世间唯有梦想和好姑娘不可辜负~~~</span></div><div class="line"></div><div class="line"><span class="comment">//因为a、b和c每个都引用一个不同的空对象</span></div><div class="line"><span class="keyword">var</span> a = &#123; &#125;, b = &#123; &#125;, c = &#123; &#125;;</div><div class="line"><span class="comment">//a、b和c都引用同一个空对象</span></div><div class="line">a = b = c = &#123; &#125;;</div></pre></td></tr></table></figure></p>
<p>修改绑定于一个原型的属性，将修改基于该原型的所有其他对对象的原型。</p>
<p>对象是自知的，或者说对象知道自己的属性。要检查某个属性是否存在，可以使用hasOwnProperty()方法，该方法将返回一个布尔值。</p>
<h3 id="5、减少全局变量污染"><a href="#5、减少全局变量污染" class="headerlink" title="5、减少全局变量污染"></a>5、减少全局变量污染</h3><p>很多程序员认为，应该避免使用全局变量。有一些办法可以避免扰乱全局名称空间，一种办法是使用单个全局变量作为顶层对象，包含程序或框架中的所有方法和属性。按照惯例，名称空间的字母全部大写，但值得注意的是常量通常也大写格式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ZOMBIE_GENERATOR = &#123;&#125;;</div><div class="line">ZOMBIE_GENERATOR.Zombies = &#123;</div><div class="line">    <span class="attr">smallZombie</span> : <span class="string">'Booger'</span>,</div><div class="line"></div><div class="line">    <span class="attr">largeZombie</span> : <span class="string">'Bruce'</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>采用上面的代码定义名称空间之后，Zombies就不会与全局名称空间中的任何其他变量冲突。另外一种减少冲突的方式是使用闭包。</p>
<h3 id="6、反射（Reflection）"><a href="#6、反射（Reflection）" class="headerlink" title="6、反射（Reflection）"></a>6、反射（Reflection）</h3><p>检查对象并确定对象有什么属性时很容易的事情，只要试着去检索该属性并验证取得值。typeof操作符对确定属性的类型很有帮助：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> father.name;                      <span class="comment">// 'string'</span></div><div class="line"><span class="keyword">typeof</span> father.age;                         <span class="comment">// 'number'</span></div><div class="line"><span class="keyword">typeof</span> father.childrenOne;         <span class="comment">// 'object'</span></div><div class="line"><span class="keyword">typeof</span> father.xxx;                         <span class="comment">// 'undefined'</span></div></pre></td></tr></table></figure></p>
<p>请注意原型链中任何属性都会产生值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> father.toString;            <span class="comment">// 'function'</span></div><div class="line"><span class="keyword">typeof</span> father.constructor;      <span class="comment">// 'function'</span></div></pre></td></tr></table></figure></p>
<p>有两种方法去处理掉这些不需要的属性。第一个是让你的程序做检查并丢弃掉值为函数的属性。一般来说，当你想让对象在运行时动态获取自身信息时，你关注更多的时数据，而你应该意识到一些值可能是函数。</p>
<p>另一个方法时使用hasOwnProperty方法，如果对象拥有独有的属性，它会返回true。hasOwnProperty方法不会检查原型链。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">father.hasOwnProperty(<span class="string">'name'</span>);                <span class="comment">// true</span></div><div class="line">father.hasOwnProperty(<span class="string">'constructor'</span>);     <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<h3 id="7、枚举（Enumeraton）"><a href="#7、枚举（Enumeraton）" class="headerlink" title="7、枚举（Enumeraton）"></a>7、枚举（Enumeraton）</h3><p><code>for...in</code>语句可以用来遍历一个对象中的所有属性名。该枚举过程将会列出所有的属性——包括函数和你可能不关心的原型中的属性——所以有必要过滤那些你不想要的值。最为常用的过滤时hasOwnPropery方法，一级使用typeof来排除函数。</p>
<p>属性名出现的顺序是不确定的，因此要对任何可能出现的顺序有所准备。如果你想要确保属性以特定的顺序出现，最好的办法就是完全避免使用for in语句，而是创建一个数组，在其中以正确的顺序包含属性名：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> properties = [</div><div class="line">  <span class="string">'first-name'</span>,</div><div class="line">  <span class="string">'middle-name'</span>,</div><div class="line">  <span class="string">'last-name'</span>,</div><div class="line">  <span class="string">'profession'</span></div><div class="line">];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; properties.length; i++)&#123;</div><div class="line">  <span class="built_in">console</span>.info(properties[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过使用for而不是for in，可以得到我们想要的属性，而不必担心可能发掘出的原型链中的属性，并且我们按正确的顺序取得了它们的值。</p>
<h2 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h2><p>函数是一个代码块，它封装了一系列的JavaScript语句。函数可以接受参数，也可以返回值。如果一个函数没有返回一个特定的值，则它返回一个undefined值。下面的代码示例定义了一个没有返回值的函数。该函数依然执行了函数体中的操作，将变了x的值乘以2，但由于没有使用return语句返回值，因此在控制台中输出函数的返回值时，返回值为undefined。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">calc</span>(<span class="params"> </span>)</span>&#123;</div><div class="line">  x = x * <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log( calc() );<span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<p>这正是函数有趣的地方，与Java不同，JavaScript中的函数时第一类对象。这意味着可以像处理其他JavaScript对象一样处理JavaScript函数。可以将函数赋予给一个变量，或者保存在另外一个数据结构中（比如一个数组或对象）；可以将函数作为参数传递给其他函数；可以将函数作为另一个函数的返回值；函数还可以采用匿名函数的形式：即根本没有绑定于函数名标识符的函数。下面代码定义了一个函数表达式，并将其赋值给一个变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> calc = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> x * <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">calc(<span class="number">5</span>);</div><div class="line"><span class="comment">// 10</span></div></pre></td></tr></table></figure></p>
<p>给函数名使用圆括号，将执行该函数并返回函数的返回值，而不是返回对函数的引用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> calc = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> x * <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> calcValue = calc( <span class="number">5</span> );</div><div class="line"><span class="built_in">console</span>.log( calcValue );</div><div class="line"></div><div class="line"><span class="comment">// 10</span></div></pre></td></tr></table></figure></p>
<p>第一类函数的另外两个特性时非常重要的。第一个特性就是将函数作为参数传递给其他函数。第二个特性就是匿名函数。下面代码演示了JavaScript中函数的重要特性。reporter函数接收一个函数作为参数，并输出执行该参数函数的返回值。另外两个例子则演示了匿名函数。第一个函数是一个根本不包含任何语句的匿名函数，但根据前面的介绍，该函数将返回一个undefined。第二个函数时一个返回字符串的匿名函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reporter</span>(<span class="params"> fn </span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="string">"这个返回值是你传递过来的函数："</span> + fn() );</div><div class="line">&#125;</div><div class="line">reporter( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;); </div><div class="line"><span class="comment">//这个返回值是你传递过来的函数：undefined</span></div><div class="line">reporter( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">"这是一个简单的字符串"</span> &#125;);</div><div class="line"><span class="comment">//这个返回值是你传递过来的函数：这是一个简单的字符串</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">calc</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="number">2</span> * <span class="number">4</span>;</div><div class="line">&#125;</div><div class="line">reporter( calc );</div><div class="line"><span class="comment">// 这个返回值是你传递过来的函数：8</span></div></pre></td></tr></table></figure></p>
<p>这是你会看到控制台还输出了一个undefined值，这是reporter函数本身的返回值，也就是说执行任何函数本身，它都会返回一个undefined值。</p>
<p>关于匿名函数，一个特别重要的变体就是立即调用的函数表达式，或称为自执行匿名函数。无论称为“立即调用的函数表达式”还是“自执行匿名函数”，这一模式的本质就是将一个函数表达式包装在一对圆括号中，然后立即调用该函数。这一技巧非常简单，将函数表达式包装在一对圆括号中，将迫使JavaScript引擎将function(){}块识别为一个函数表达式，而不是一个函数语句的开始。下面的代码示例描述了这一模式，在这个简单的例子中，函数表达式接受两个值并简单地将二者相加。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> x,y </span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( x+y );</div><div class="line">&#125;)( <span class="number">5</span>,<span class="number">6</span>);</div><div class="line"><span class="comment">// 11</span></div></pre></td></tr></table></figure></p>
<p>由于这样的函数表达式将被立即调用，因此该模式用于确保代码块的执行上下文按照预期的效果执行，这是这种模式最重要的用于之一。通过将参数传入函数，在执行时就可以捕获函数所创建闭包中的变量。闭包就是这样的一个函数：它处在一个函数体中，并引用了函数体当前执行上下文中的变量。闭包是一个极为强大的功能，下面的代码描述了闭包的基本应用。在下面的例子中还引入了JavaScript函数另外一个有趣的特性，即在函数中可以将另外一个函数作为返回值返回。</p>
<p>在下面的例子中，将自执行匿名函数赋给一个变量message。message返回另外一个函数，该函数只是简单的输出变量x的值。有趣的是，当我们把变量x的初始值作为参数传入函数时，可以在函数执行时所创建的闭包中捕获变量x的值。无论在外部作用域中的x的值发生了什么变化，闭包将记住函数执行时变量x的值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">42</span>;</div><div class="line"><span class="built_in">console</span>.log(x);    <span class="comment">// 42</span></div><div class="line"><span class="keyword">var</span> message = (<span class="function"><span class="keyword">function</span> (<span class="params"> x </span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log( <span class="string">"x is "</span> + x);</div><div class="line">  &#125;</div><div class="line">&#125;)( x );</div><div class="line">message(); <span class="comment">//x is 42</span></div><div class="line">x = <span class="number">12</span>;</div><div class="line"><span class="built_in">console</span>.log( x ); <span class="comment">// 12</span></div><div class="line">message(); <span class="comment">//x is 42</span></div></pre></td></tr></table></figure></p>
<p>即使只介绍了这个简单的例子，也应该看到JavaScript函数的强大功能。</p>
<h2 id="三、作用域和闭包"><a href="#三、作用域和闭包" class="headerlink" title="三、作用域和闭包"></a>三、作用域和闭包</h2><p>当讨论作用域时，考虑定义变量的位置和变量的生存期时非常重要的。作用域指的是在什么地方可以访问该变量。在JavaScript中，作用域维持在函数级别，而并非块级别。因此，参数以及使用var关键字定义的变量，仅在当前函数中可见。</p>
<p>除了不能访问this关键字和参数之外，嵌套函数可以访问外部函数中定义的变量。这一机制时通过闭包来实现的，它是指：即使在外部函数结束执行之后，内部嵌套的函数继续保持它对外部函数的引用。闭包还有助于减少名称空间的冲突。</p>
<p>每次调用一个包裹的函数时，虽然函数的代码并没有改变，但是JavaScript将为每一次调用创建一个新的作用域。下面的代码说明了这一行为。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFunction</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = getFunction(),</div><div class="line">    b = getFunction(),</div><div class="line">    c = getFunction();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a(<span class="number">0</span>)); <span class="comment">// 0</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(b(<span class="number">1</span>)); <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(c(<span class="number">2</span>)); <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(a === b); <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>当定义一个独立函数时（即不绑定于任何对象）时，this关键字绑定雨全局名称空间。作为一个最直接的结果，<strong>当在一个方法内创建一个内部函数时，内部函数的this关键字将绑定于全局名称空间，而不是绑定于该方法</strong>。为了解决这一问题，可以将包裹方法的this关键字简单的赋值给一个名为that的中间变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">obj = &#123;&#125;;</div><div class="line">obj.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">this</span>.counter = <span class="number">0</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">var</span> count = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    that.counter += <span class="number">1</span>;</div><div class="line">    <span class="built_in">console</span>.log(that.counter);</div><div class="line">  &#125;</div><div class="line">  count();</div><div class="line">  count();</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.counter);</div><div class="line">&#125;</div><div class="line">obj.method();</div><div class="line"><span class="comment">// 输出：</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure></p>
<h2 id="四、访问级别"><a href="#四、访问级别" class="headerlink" title="四、访问级别"></a>四、访问级别</h2><p>在JavaScript中并没有官方的访问级别语法，JavaScript没有类似于Java语言中的private或protected这样的访问级别关键字。默认情况下，对象中所有的成员都是公开和可访问的。但在JavaScript中可以实现与私有或专有属性类似的访问级别效果。要实现私有方法或属性，请使用闭包。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">TimeMachine</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//私有成员</span></div><div class="line">  <span class="keyword">var</span> destination = <span class="string">'ShangHai CAOHEJING'</span>;</div><div class="line">  <span class="comment">//公有成员</span></div><div class="line">  <span class="keyword">this</span>.getDestination = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> destination;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> zhangsan = <span class="keyword">new</span> TimeMachine();</div><div class="line"><span class="built_in">console</span>.log(zhangsan.getDestination());</div><div class="line"><span class="comment">// ShangHai CAOHEJING</span></div><div class="line"><span class="built_in">console</span>.log(zhangsan.destination);</div><div class="line"><span class="comment">//undefined</span></div></pre></td></tr></table></figure></p>
<p>getDestination方法是一个专有方法，它可以访问TimeMachine（时间机器）中的私有成员。另外，变量destination 是“私有”的，它只能通过专有方法getDestination进行访问。</p>
<h2 id="五、模块"><a href="#五、模块" class="headerlink" title="五、模块"></a>五、模块</h2><p>于私有和专有访问级别类似，JavaScript没有内置的包语法。模块模式是一种简单而流行的方式，用于创建自包含的、模块化的代码。要创建一个模块，只需要声明一个名称空间、将有关函数绑定在该名称空间，并定义私有成员和专有成员即可，下面将使用模块重写TimeMachine对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建名称空间对象</span></div><div class="line">TIMEMACCHINE = &#123;&#125;;</div><div class="line">TIMEMACCHINE.createZhangsan = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//私有成员</span></div><div class="line">  <span class="keyword">var</span> destination = <span class="string">''</span>;</div><div class="line">  <span class="keyword">var</span> model = <span class="string">''</span>;</div><div class="line">  <span class="keyword">var</span> fuel = <span class="string">''</span>;</div><div class="line">  </div><div class="line">  <span class="comment">//公有访问方法</span></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="comment">//设置器</span></div><div class="line">    setDestination: <span class="function"><span class="keyword">function</span>(<span class="params">dest</span>)</span>&#123;</div><div class="line">      <span class="keyword">this</span>.destination = dest;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">setModel</span>: <span class="function"><span class="keyword">function</span>(<span class="params">model</span>)</span>&#123;</div><div class="line">      <span class="keyword">this</span>.model = model;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">setFuel</span>: <span class="function"><span class="keyword">function</span>(<span class="params">fuel</span>)</span>&#123;</div><div class="line">      <span class="keyword">this</span>.fuel = fuel;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//访问器</span></div><div class="line">    getDestination: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.destination;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">getModel</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.model;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">getFuel</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.fuel;</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">//其他成员</span></div><div class="line">    toString : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.getModel() + <span class="string">' - Fuel Type：'</span> +</div><div class="line">                 <span class="keyword">this</span>.getFuel() + <span class="string">' - Headed：'</span> + <span class="keyword">this</span>.getDestination());</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="keyword">var</span> myTimeMachine = TIMEMACCHINE.createZhangsan;</div><div class="line">myTimeMachine.setModel(<span class="string">'顺丰号'</span>);</div><div class="line">myTimeMachine.setFuel(<span class="string">'钚'</span>);</div><div class="line">myTimeMachine.setDestination(<span class="string">'漕河泾'</span>);</div><div class="line"></div><div class="line">myTimeMachine.toString();</div><div class="line"><span class="comment">// 顺丰号 - Fuel Type：钚 - Headed：漕河泾</span></div></pre></td></tr></table></figure></p>
<p>该模块具有一个工厂函数，它返回一个带有public/privateAPI的对象。</p>
<h2 id="六、数组"><a href="#六、数组" class="headerlink" title="六、数组"></a>六、数组</h2><p>数组是一种特殊类型的对象，他作为一个有序的值的集合，这些值称为数组元素。在一个数组内，每一个元素都具有一个索引，或称为一个数字位置。在一个数组中可以存储相同类型或不同类型的元素。不要求数组元素全都具有相同的数据类型。于对象和函数类似，数组也可以任意嵌套。</p>
<p>与普通对象一样，可以采用两种方式来创建数组。第一种方法就是使用Array()构造函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> array1 = <span class="keyword">new</span> <span class="built_in">Array</span>();    <span class="comment">//空数组</span></div><div class="line">array1[<span class="number">0</span>] = <span class="number">1</span>;                        <span class="comment">//在索引为0 的位置添加一个数组元素</span></div><div class="line">array1[<span class="number">1</span>] = <span class="string">'a string'</span>;           <span class="comment">//在索引为1的位置添加一个字符串</span></div></pre></td></tr></table></figure></p>
<p>更常用的是第二种方式，即使用一个数组字面量来创建数组，它由一对方括号括起来，其中包含了0个或多个一逗号分隔的值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> niceArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,];</div></pre></td></tr></table></figure></p>
<p>在数组字面量中混合使用对象字面量，可以提供非常强大的结构，他是JavaScript对象表示法JSON的基础。JSON是一种流行的数据交换格式，它可以用于多种语言而不仅仅时JavaScript语言。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myData = &#123;</div><div class="line">    <span class="string">'root'</span> : &#123;</div><div class="line">         <span class="string">'numbers'</span> : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</div><div class="line">             <span class="string">'letters'</span> : [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>],</div><div class="line">             <span class="string">'mirepoix'</span> : [<span class="string">'tomatoes'</span>, <span class="string">'carrots'</span>, <span class="string">'potatoes'</span>]   </div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>数组具有一个length属性，它的值总是等于数组中元素的个数减11。在数组中添加新元素将改变数组length属性。要从数组中移除元素，请使用delete操作符。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="string">'2'</span>, <span class="string">'blah'</span>, &#123;&#125;];</div><div class="line"><span class="keyword">delete</span> list[<span class="number">0</span>];</div><div class="line"><span class="built_in">console</span>.log(list);</div><div class="line"><span class="comment">// [undefined, "2", "blah", Object &#123;&#125;]</span></div><div class="line"><span class="built_in">console</span>.log(list.length);</div><div class="line"><span class="comment">// 4</span></div></pre></td></tr></table></figure></p>
<p>删除一个元素并不会改变数组的长度，只是在数组中留下一个undefined值的元素（空元素）。</p>
<h2 id="七、扩展类型"><a href="#七、扩展类型" class="headerlink" title="七、扩展类型"></a>七、扩展类型</h2><p>JavaScript支持将方法和其他属性绑定到内置类型。比如字符串、数值和数组类型。于其他任何对象类似，String对象也具有prototype属性。开放人员可以为String对象扩充一些便利的方法。例如，String没有将字符串false或true转换为布尔值的方法。开放人员可以使用下面的代码<br>为String对象添加该功能：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.prototype.boolean = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"true"</span> == <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> t = <span class="string">'true'</span>.boolean();</div><div class="line"><span class="keyword">var</span> f = <span class="string">'false'</span>.boolean();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.info(t);    <span class="comment">//true</span></div><div class="line"><span class="built_in">console</span>.info(f);    <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p>显然，每次想为制定类型添加方法时反复输入prototype显得有点累赘》以下提供一段简洁的代码，他使用一个名为method的方法扩充了Function.prototype。下面就是该方法的代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params">name,func</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.prototype[name] = func;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来就可以重写String的boolean方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.method(<span class="string">'boolean'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"true"</span> == <span class="keyword">this</span>;</div><div class="line">&#125;);</div><div class="line"><span class="string">"true"</span>.boolean();</div></pre></td></tr></table></figure></p>
<p>对于编写工具方法库并将其包含在项目中，这一技术非常有用。</p>
<h2 id="八、JavaScript最佳实践"><a href="#八、JavaScript最佳实践" class="headerlink" title="八、JavaScript最佳实践"></a>八、JavaScript最佳实践</h2><p>下面列出了在进行JavaScript开发时，一些应该注意或应该避免的事项：</p>
<ul>
<li>使用parseInt()函数将字符串转换为整数，但请确保总是指定基数。更好的办法时使用一元操作符(+)将字符串转化为数值。<br>好的写法：parseInt(“020”,10);    //转化为十进制而不是八进制<br>更好的写法：console.log(+ “010”);    //简单而又高效</li>
<li>使用等同（===）操作符来比较两个值。避免意料之外的类型转换。</li>
<li><p>在在定义对象字面量时，在最后一个值的结尾不要使用逗号。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123;</div><div class="line">    <span class="string">"p1"</span> : <span class="number">1</span>,</div><div class="line">    <span class="string">"p2"</span> : <span class="number">2</span>,</div><div class="line">    <span class="comment">//非常糟糕！</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>eval()函数可以接收一个字符串，并将其视为JavaScript代码执行。应该限制eval()函数的使用，它很容易在代码中引入各种各样严重的安全问题。</p>
</li>
<li>使用分号作为语句的结尾，当精简代码时这特别有用。</li>
<li>应该避免使用全局变量。应该总是使用var关键字来声明变量。将代码包裹在匿名函数中，以避免命名冲突，请使用模块来阻止代码。</li>
<li>对函数名使用首字母大写表示该函数将作为new操作符的构造函数，但请不要对其他任何函数的函数名使用首字母大写。</li>
<li>不要使用with语句。</li>
<li>在循环中创建函数应该谨慎小心。这种方式非常低效。</li>
</ul>
<blockquote>
<p>最佳摘自Cesar Otero,Rob Larsen《jQuery高级编程》</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面向对象编程 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript中的数据类型回顾]]></title>
      <url>/2015/08/30/JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9B%9E%E9%A1%BE/</url>
      <content type="html"><![CDATA[<p>文本讲解标志符、数值、字符串、布尔、类型比较、日期数据类型<br><a id="more"></a></p>
<h2 id="标识符（Names）"><a href="#标识符（Names）" class="headerlink" title="标识符（Names）"></a>标识符（Names）</h2><p>标识符由一个字母、下划线和美元符开头，其后可以选择性的加上一个或多个字母、数字或下划线。标识符不能使用下面这些保留字：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">abstract</div><div class="line">boolean、<span class="keyword">break</span>、byte</div><div class="line"><span class="keyword">case</span>、<span class="keyword">catch</span>、char、<span class="class"><span class="keyword">class</span>、<span class="title">const</span>、<span class="title">continue</span></span></div><div class="line"><span class="title">debugger</span>、<span class="title">default</span>、<span class="title">delete</span>、<span class="title">do</span>、<span class="title">double</span></div><div class="line"><span class="title">else</span>、<span class="title">enume</span>、<span class="title">export</span>、<span class="keyword">extends</span></div><div class="line"><span class="title">false</span>、<span class="title">final</span>、<span class="title">finally</span>、<span class="title">float</span>、<span class="title">for</span>、<span class="title">function</span></div><div class="line"><span class="title">goto</span></div><div class="line"><span class="title">if</span>、<span class="title">implement</span>、<span class="title">import</span>、<span class="title">in</span>、<span class="title">instanceof</span>、<span class="title">int</span>、<span class="title">interface</span></div><div class="line"><span class="title">long</span></div><div class="line"><span class="title">native</span>、<span class="title">new</span>、<span class="title">null</span></div><div class="line"><span class="title">package</span>、<span class="title">private</span>、<span class="title">protected</span>、<span class="title">public</span></div><div class="line"><span class="title">return</span></div><div class="line"><span class="title">short</span>、<span class="title">static</span>、<span class="title">supper</span>、<span class="title">switch</span>、<span class="title">synchronized</span></div><div class="line"><span class="title">this</span>、<span class="title">throw</span>、<span class="title">throws</span>、<span class="title">transient</span>、<span class="title">true</span>、<span class="title">try</span>、<span class="title">typeof</span></div><div class="line"><span class="title">var</span>、<span class="title">volatile</span>、<span class="title">void</span></div><div class="line"><span class="title">while</span>、<span class="title">with</span></div></pre></td></tr></table></figure></p>
<p>在这个列表中大部分保留字尚未在这门语言中使用。这个列表不包括一些本应该被保留而没有保留的字，诸如undefined、NaN和Infinity。JavaScript不允许使用保留字来命名变量或参数。更糟糕的饿是，JavaScript不逊雨在对象字面量中，或者用点运算符提取对象属性时，使用保留字作为对象的属性名。</p>
<p>标识符被用于语句、变量、参数、属性名、运算符和标记。</p>
<h2 id="数值（Numbers）"><a href="#数值（Numbers）" class="headerlink" title="数值（Numbers）"></a>数值（Numbers）</h2><p>与其他任边吃语言一样，JavaScript可以处理诸如数据或文本的值。一门语言可以使用的值的类型，称为该语言的数据类型。JavaScript支持基本的数值和字符串的数据类型。在JavaScript中，所有数值都是64位双精度的，取值范围从-5e-324到1.7976931348623157e308。也就是说，在JavaScript中整数和浮点数之间并没有什么区别，二者都是数值。下面的例子使用了typeof操作符进行演示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">typeof</span> <span class="number">1</span>;</div><div class="line"><span class="string">"number"</span></div><div class="line">&gt; <span class="keyword">typeof</span> <span class="number">1.5</span>;</div><div class="line"><span class="string">"number"</span></div></pre></td></tr></table></figure></p>
<p>所有JavaScript数值都是按照IEEE-754双精度二进制数标准进行表示。当执行算术运算时应该注意一些问题。例如，在把两个数值相加时，在你的脑海中这是一个通用的操作，然而在JavaScript中可能会获得令人大感意外的结果，下面的代码演示看着一问题：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="number">.1</span> + <span class="number">.2</span>;</div><div class="line"><span class="number">0.30000000000000004</span></div></pre></td></tr></table></figure></p>
<p>JavaScript没有内置的十进制数据类型，但JavaScript为数值提供了两个方法：toPrecision和toFixed，这两个方法可以按照固定位数的小数来格式化数值。下面的代码演示了着两个方法的使用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">var</span> num = <span class="number">1234.123454321</span>;</div><div class="line">&gt; num.toFixed(<span class="number">2</span>);</div><div class="line"><span class="string">"1234.12"</span></div><div class="line">&gt; <span class="keyword">var</span> num2 = <span class="number">1234.123454321</span>;</div><div class="line">&gt; num2.toPrecision(<span class="number">8</span>);</div><div class="line"><span class="string">"1234.1235"</span></div></pre></td></tr></table></figure></p>
<p>如果使用了一个超出64位范围的数值，或者获得一个超出64位范围的值，JavaScript将返回一个特殊的值：Infinity（无穷大）或者-Infinity（负无穷大）。除数为0将返回Infinity。其他特殊值还包括NaN，他表示一个“非数值”，她是一个容易产生错误的值，常常是一些BUG的根源。</p>
<p>当试图将一个无效字符串对象转换为一个数值时，结果为NaN值。NaN具有“毒性”，在NaN值与数值之间执行一个操作将返回一个NaN值。可以使用内置的isNaN()函数来检查一个变量是否是NaN值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="number">10</span> * <span class="number">1</span> + <span class="number">100</span> - <span class="number">1</span> -<span class="literal">NaN</span>;</div><div class="line"><span class="literal">NaN</span></div><div class="line">&gt; <span class="keyword">var</span> x = <span class="literal">NaN</span>;</div><div class="line">&gt; <span class="built_in">isNaN</span>(x);</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>JavaScript支持八进制（基数为8）和十六进制（基数为16）。八进制字面值用一个0（即零）作为前缀，十六进制数值则以一个x作为前缀。</p>
<p>JavaScript内置Math对象用于常见的数学运算。例如，可以使用Math.round()方法获得两位数的精度。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">Math</span>.round( (<span class="number">.1</span>+<span class="number">.2</span>)*<span class="number">100</span>)/<span class="number">100</span>;</div><div class="line"><span class="number">0.3</span></div></pre></td></tr></table></figure></p>
<p>充分利用内置对象可以节省时间、提高效率。</p>
<h2 id="字符串（Strings）"><a href="#字符串（Strings）" class="headerlink" title="字符串（Strings）"></a>字符串（Strings）</h2><p>字符串是一个由0个或多个16位的Unicode字符组成的系列，使用单引号或双引号将字符串括起。这里强调它是Unicode字符，是出于国际化环境中使用JavaScript的重要性。JavaScript中没有为字符串定义特殊的数据类型。字符串也是（不可变）对象，一旦被创建，就永远无法改变它。但你可以很容易的通过 + 运算符连接其他字符串来创建一个新字符串。两个包含着完全相同的字符且字符顺序也相同的字符串被认为是相同的字符串。所以：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="string">'c'</span> + <span class="string">'a'</span> + <span class="string">'t'</span> === <span class="string">'cat'</span>;</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>字符串是对象，因此字符串具有一些相应的属性和方法。字符串有一个length属性。例如，”JavaScript”.length是10；再比如下面的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="string">'test String'</span>.indexOf(<span class="string">'s'</span>);</div><div class="line"><span class="number">2</span></div><div class="line">&gt; <span class="string">'test String'</span>.charAt(<span class="number">5</span>);</div><div class="line"><span class="string">"S"</span></div></pre></td></tr></table></figure></p>
<p>我们也可以扩展内置的String对象以满足开发人员的需要。</p>
<h2 id="布尔（Boolean）"><a href="#布尔（Boolean）" class="headerlink" title="布尔（Boolean）"></a>布尔（Boolean）</h2><p>Boolean类型表示true值和false值。在适当的上下文中，比如在一个if语句中，任何条件判断的值都将被转换为Boolean值以判断“真”或“假”。在判断条件中，空字符串、NaN值、null、undefined、数值0和关键字false都将被计算为false，其它的任何值都将被解析为true。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="string">''</span>) &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'something happens'</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'nothing happens'</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//输出：nothing happens</span></div></pre></td></tr></table></figure></p>
<p>JavaScript支持的布尔操作包括：逻辑与（&amp;&amp;）、逻辑或（||）和逻辑非（!）。在很多常见任务中，布尔操作对于检验要求输入的字符串非常有用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> name_input = <span class="string">'java'</span>;</div><div class="line">    <span class="keyword">var</span> age_input;</div><div class="line">    <span class="keyword">return</span> name_input &amp;&amp; age_input;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(validate())&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'pass'</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'fail'</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//输出 fail</span></div></pre></td></tr></table></figure></p>
<p>NaN值表示一个非数值的值，但你如果输入下面的代码，结果将会很奇怪：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">typeof</span> <span class="literal">NaN</span>;</div><div class="line"><span class="string">"number"</span></div></pre></td></tr></table></figure></p>
<p>这是typeof操作符奇怪的行为之一。</p>
<h2 id="类型比较"><a href="#类型比较" class="headerlink" title="类型比较"></a>类型比较</h2><p>JavaScript具有等于（==）操作符和等同（===）操作符。==操作符是危险的，因为它在执行比较之前，强制执行类型转换。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="number">1</span> == <span class="string">'1'</span>;</div><div class="line"><span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>显然，这不是我们想要的比较结果。如果左操作数和右操作数真正完全相同，===操作符才会返回true。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="number">1</span> === <span class="string">'1'</span>;</div><div class="line"><span class="literal">false</span></div></pre></td></tr></table></figure></p>
<p>对应的还有!=和!==操作符，请总是使用===和!==操作符。</p>
<h2 id="日期（Data）"><a href="#日期（Data）" class="headerlink" title="日期（Data）"></a>日期（Data）</h2><p>JavaScript内置了Date对象，可以使用new操作符和Date()构造函数来创建Date对象，Date对象用于表示日期和时间。不带任何参数创建一个新的Date对象，获得的是一个表示当前日期和时间的Date对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">var</span> thisMoment = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">&gt; <span class="built_in">console</span>.log(thisMoment);</div><div class="line"><span class="built_in">Date</span> &#123;Sun Aug <span class="number">30</span> <span class="number">2015</span> <span class="number">10</span>:<span class="number">47</span>:<span class="number">14</span> GMT+<span class="number">0800</span>&#125;</div><div class="line">&gt; thisMoment.getFullYear();</div><div class="line"><span class="number">2015</span></div></pre></td></tr></table></figure></p>
<p>虽然Date是一个方便的对象，了解该对象当然还是有用的。强烈建议使用开源的Date.js库来执行日期/时间的计算，可以从<a href="https://github.com/datejs/Datejs找到该js库，datajs官方网站现在已经无法打开，返回503状态。" target="_blank" rel="external">https://github.com/datejs/Datejs找到该js库，datajs官方网站现在已经无法打开，返回503状态。</a></p>
<h2 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h2><p>声明一个变量时未对其赋值，或者访问了一个不存在的对象属性，结果都会产生一个称为undefined的类型。null时JavaScript的一个内置对象，它表示没有值。在执行比较操作时，undefined和null二者都被装换成false值，但是最好避免使用undefined。在很多JavaScript解析器中，undefined是可以重新赋值的，因而可能会产生存在弊病的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="literal">undefined</span> = <span class="literal">true</span>;</div><div class="line"><span class="keyword">if</span>(<span class="literal">undefined</span>)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'骗你！'</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//输出：骗你！</span></div></pre></td></tr></table></figure></p>
<p>下面列出了JavaScript支持的各种数据类型。正则表达式，或称为RegEx不在这里介绍。</p>
<ul>
<li>Number</li>
<li>String</li>
<li>Boolean</li>
<li>Object</li>
<li>Function</li>
<li>Array</li>
<li>Date</li>
<li>RegEx</li>
<li>Null</li>
<li>Undefined </li>
</ul>
<p>在使用try/catch语句时，某些附加的内置error类型是非常有用的。通常在throw语句中创建error对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'非常糟糕的事情发生了!'</span>);</div><div class="line">&#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">    <span class="built_in">console</span>.log(e.name + <span class="string">'：'</span> + e.message);</div><div class="line">&#125;</div><div class="line"><span class="comment">//输出：Error：非常糟糕的事情发生了!</span></div></pre></td></tr></table></figure></p>
<p>下面的列表列出了各种不同的error类型</p>
<ul>
<li>Error</li>
<li>EvalError</li>
<li>RangError</li>
<li>ReferenceError</li>
<li>SyntaxError</li>
<li>TypeError</li>
<li>URIError</li>
</ul>
<p>对于我来说，最常见的莫过于SyntaxError这个经典的语法错误，太熟悉了。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[强大的Http监控工具Fidder简单介绍]]></title>
      <url>/2015/08/30/%E5%BC%BA%E5%A4%A7%E7%9A%84Http%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7Fidder%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h2 id="1、简介与安装"><a href="#1、简介与安装" class="headerlink" title="1、简介与安装"></a>1、简介与安装</h2><p>Fiddler是一个http调试代理，它能 够记录所有的你电脑和互联网之间的http通讯，Fiddler 可以也可以让你检查所有的http通讯，设置断点，以及Fiddle 所有的“进出”的数据（指cookie,html,js,css等文件，这些都可以让你胡乱修改的意思）。 Fiddler 要比其他的网络调试器要更加简单，因为它仅仅暴露http通讯还有提供一个用户友好的格式。</p>
<p>Fiddler 包含一个简单却功能强大的基于JScript .NET 事件脚本子系统，他非常灵活性非常棒，可以支持众多的http调试任务。Fiddler 是用C#写出来的。</p>
<p>软件下载：<br><a href="http://fiddler2.com/get-fiddler" target="_blank" rel="external">http://fiddler2.com/get-fiddler</a></p>
<p>软件学习：<br><a href="http://www.cnblogs.com/TankXiao/archive/2012/02/06/2337728.html#request" target="_blank" rel="external">http://www.cnblogs.com/TankXiao/archive/2012/02/06/2337728.html#request</a></p>
<p>Fiddler还支持丰富的插件，官方也停供大量的插件：<br><a href="http://www.telerik.com/fiddler/add-on" target="_blank" rel="external">http://www.telerik.com/fiddler/add-on</a></p>
<h2 id="2、Fiddler工作原理"><a href="#2、Fiddler工作原理" class="headerlink" title="2、Fiddler工作原理"></a>2、Fiddler工作原理</h2><p><img src="http://upload-images.jianshu.io/upload_images/68937-1f34ea39f933a9cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Fiddler工作原理"></p>
<p>两种代理模式：</p>
<ul>
<li>流模式（streaming）：更接近浏览器的真实情况</li>
<li>缓冲模式（buffering）：HTTP请求所有的数据都准备好之后才把数据返回给客户端</li>
</ul>
<h2 id="3、使用场景"><a href="#3、使用场景" class="headerlink" title="3、使用场景"></a>3、使用场景</h2><ul>
<li>开发环境HOST配置：通常情况下配置host需要修改系统文件，很不方便；</li>
<li>在多个环境下切换很低效;Fiddler提供了先对高效的配置方法；</li>
<li>前后端接口调试：通常情况下调试前后端接口需要真实的环境、一大堆的假<br>数据、写JavaScript代码。Fiddler只需一个UI界面配置即可。</li>
<li>线上bug fix：Fiddler可将发布文件代理到本地，快速定位线上Bug。</li>
<li>性能分析和优化：Fiddler会提供请求的实际图，清晰明了网站需要优化的地方。</li>
</ul>
<h2 id="4、工具条、状态栏常用功能"><a href="#4、工具条、状态栏常用功能" class="headerlink" title="4、工具条、状态栏常用功能"></a>4、工具条、状态栏常用功能</h2><p>工具条:<br><img src="http://upload-images.jianshu.io/upload_images/68937-943a4c4d72c90ab7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="工具条"></p>
<p>状态栏:<br><img src="http://upload-images.jianshu.io/upload_images/68937-10dc95c17bb76c61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="状态栏"></p>
<h2 id="5、监控面板的使用"><a href="#5、监控面板的使用" class="headerlink" title="5、监控面板的使用"></a>5、监控面板的使用</h2><p><img src="http://upload-images.jianshu.io/upload_images/68937-7ea08c3508a1acbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="监控面板的使用"></p>
<h2 id="6、文件、文件夹代理和Host配置"><a href="#6、文件、文件夹代理和Host配置" class="headerlink" title="6、文件、文件夹代理和Host配置"></a>6、文件、文件夹代理和Host配置</h2><p><img src="http://upload-images.jianshu.io/upload_images/68937-f604a869aa803692.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Host配置"></p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 工具使用 </tag>
            
            <tag> http </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jQuery Core Style Guide（规范）]]></title>
      <url>/2015/08/29/jQuery-Core-Style-Guide/</url>
      <content type="html"><![CDATA[<p><a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml" target="_blank" rel="external">Google JavaScript Style Guide</a>定义了如下规范：</p>
<ul>
<li>除了意图明确的需要创建一个全局变量之外，总是使用var声明变量；</li>
<li>总是使用分号。只对于压缩代码非常重要；</li>
<li>常量使用大写，每个单词之间用一个下划线分隔；</li>
<li>函数、变量和方法名都是用驼峰写法，但整个变量名第一个字母小写；</li>
<li>类和枚举名也采用驼峰写法，但整个变量名的第一个字母大写。<a id="more"></a>
JQuery团队还发表了一些开发<a href="http://learn.jquery.com/style-guide/" target="_blank" rel="external">jQuery核心库的规范</a>。在该规范中描述了以下规则：</li>
</ul>
<p><strong>1. 使用代码有间隔</strong><br>在代码中明确的使用空格，并使用制表符（tab）缩进代码。在代码行末尾不要使用空格字符，在空行中也不应该使用空格字符。下面的代码描述了</p>
<p>一种在代码中使用间隔的较好方式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( test === <span class="string">"test string"</span> ) &#123; </div><div class="line">      methodCall( <span class="string">"see"</span>, <span class="string">"our"</span>, <span class="string">"spacing"</span> ); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>2. 使用注释</strong><br>对于多行注释使用/<em> </em>/，对于单行注释，使用//，在注释上保留一个空行。请将单行注释放在所有注释代码行之上，并且在注释行中仅包含注释的说明。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注释</span></div><div class="line"><span class="keyword">var</span> x = <span class="string">'blah'</span>;</div><div class="line"><span class="keyword">var</span> x = <span class="string">'blah'</span>; <span class="comment">// 不良方式</span></div></pre></td></tr></table></figure></p>
<p><strong>3.  相等性</strong><br>总是使用等同(===)进行比较，而不是简单的使用等于(==)进行比较。对于这一规则，jQuery团队的一个例外，就是检查null值时使用简单的等于操作符进行比较。正如规范所说，执行==null或者！=null的比较操作符实际上非常有用，因为当值为null嚯undefined时，这种比较会成功（或失败）。</p>
<p><strong>4.  以块方式组织代码</strong><br>对于控制结构（if/else/for/while/try）总是使用花括号，并且总是以多行的代码块方式来编写代码。不要使用没有花括号的单行if语句。应该将其实花括号与else/else if/catch放在同一行上。建议不要使用三元操作符来取代if/else语句。下面是一些例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不良方式</span></div><div class="line"><span class="keyword">if</span>( success ) alert( <span class="string">'操作成功'</span> );</div><div class="line"><span class="comment">//良好方式</span></div><div class="line"><span class="keyword">if</span>( success )&#123;</div><div class="line">     alert( <span class="string">'操作成功'</span> );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//良好方式</span></div><div class="line"><span class="keyword">if</span>( option ) &#123;</div><div class="line">     <span class="comment">//代码</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">     <span class="comment">//代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>5. 函数调用格式 </strong><br>在函数调用参数的两侧包含一个多余的空格。但当函数调用的是嵌套的、或是函数的参数为空、或者传入的参数是一个对象字面量或数组时例外。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//正确的函数调用方式</span></div><div class="line">f(arg );</div><div class="line">f( g(arg) );</div><div class="line">f();</div><div class="line">f( &#123; &#125; );</div><div class="line">f( [ ] );</div></pre></td></tr></table></figure></p>
<p><strong>6. 数组和对象</strong><br>对于空对象或数组字面量不要使用额外的空格，但在逗号和冒号之后使用一个空格：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> b = [];</div><div class="line"><span class="keyword">var</span> c = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ];</div></pre></td></tr></table></figure></p>
<p><strong>7. 对变量/对象赋值</strong><br>在赋值语句后总是使用一个分号结尾并结束改行。Google Style Guide也要求，在一行的代码结尾总是使用分号。</p>
<p><strong>8. 类型检查</strong><br>下表描述了执行类型检查的代码</p>
<p>对象：类型检查表达式</p>
<ul>
<li>String：typeof object === “String”</li>
<li>Number：typeof object === “number”</li>
<li>Boolean：typeof object === “boolean”</li>
<li>Object：typeof object === “object”</li>
<li>Element：object.nodeType</li>
<li>null：object === null</li>
<li>null 或 undefined：object == null</li>
</ul>
<p>下表列出了使用jQuery API对对象执行类型检查的方法。</p>
<p>对象：用于类型检查的jQuery方法</p>
<ul>
<li>Plain Object(测试对象是否是纯粹的对象(通过 “{}” 或者 “new Object” 创建的))：jQuery.isPlainObject(object)</li>
<li>Function：jQuery.isFunction(object)</li>
<li>Array：jQuery.isArray(object)</li>
</ul>
<p>下表列出了用于对undefined执行类型检查的方法</p>
<p>对象：类型检查表达式</p>
<ul>
<li>Global Variables（全局变量）：typeof variables === “undefined”</li>
<li>Local Variables（局部变量）：variable === undefined</li>
<li>Properties（属性）：object.prop === undefined</li>
</ul>
<p><strong>9. RegExp</strong><br>在.text()或.exec() 中创建正在表达式（RegExp）</p>
<p><strong>10. 字符串</strong><br>使用双引号而不是单引号</p>
<p>开发规范的文档中还提到了使用JSLint进行验证。</p>
<p>Google JavaScript Style Guide与jQuery的Style Guide之间也存在着一些差别，例如：Google JavaScript Style Guide建议使用单引号，而jQuery团队则将使用双引号作为一种标准。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jQuery </tag>
            
            <tag> 规范 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java-final修饰符梳理]]></title>
      <url>/2015/07/18/Java-final%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%A2%B3%E7%90%86/</url>
      <content type="html"><![CDATA[<p>final关键字可用于修饰方法、类和变量，表示它修饰的类、方法和变量不可改变。final修饰变量时，表示该变量一旦获得了初始值就不可改变，final既可以修饰成员变量，也可以修饰局部变量、形参。final修饰的成员变量不可被改变，一旦获得了初始值，该final变量的值就不能被重新赋值。<br><a id="more"></a></p>
<h2 id="一、final成员变量"><a href="#一、final成员变量" class="headerlink" title="一、final成员变量"></a>一、final成员变量</h2><p>成员变量时随类初始化或对象初始化而初始化的，当类初始化时，系统会为该类的类Field分配内存，并分配默认值；当创建对象时，系统会为该对象的实例Field分配内存并分配默认初始值。也就是说，当执行静态初始化块、构造器时可以对类Field赋初始值；当执行普通初始化块、构造器时可以对实例Field赋初始值。因此，成员变量的初始值可以在定义改变了时指定默认值，也可以在初始化块、构造器中指定初始值。</p>
<p>对于final修饰的成员变量而言，一但有了初始值，就不能被重新赋值，如果既没有在定义成员变量时指定初始值，也没在初始化块、构造器中为成员变量指定初始值，那么这些成员变量的值是系统默认分配的<code>0</code>、<code>\u000</code>、<code>false</code>或<code>null</code>，这些成员变量也就全失去了存在的意义。因此Java语法规定：<strong>final修饰的成员变量必须由程序员显示的指定初始值。</strong></p>
<p>归纳起来，final修饰的类Field、实例Field能指定初始值的地方如下：</p>
<ol>
<li>类Field：必须在静态初始化块中或声明该File的时指定初始化。</li>
<li>实例File的：必须在非静态初始化块、声明该File的或构造器中指定初始值。</li>
</ol>
<p>下面程序演示了final修饰成员变量的效果，详细示范了final修饰成员变量的各种具体情况。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinalVarTest</span> </span>&#123;</div><div class="line">    <span class="comment">//定义成员变量时指定默认值，合法</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">6</span>;</div><div class="line">    <span class="comment">//下面变量将在构造器中或初始化块中分配初始值</span></div><div class="line">    <span class="keyword">final</span> String str;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> c;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">double</span> d;</div><div class="line">    <span class="comment">//即没有指定默认值，也没用在初始化块中或构造器中指定初始值</span></div><div class="line">    <span class="comment">//下面定义char Filed是不合法的</span></div><div class="line">    <span class="comment">//final char ch;</span></div><div class="line">    <span class="comment">//初始化块，可对没有指定默认值的实例Filed指定初始值</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">//在初始化块中为实例Field指定初始值，合法</span></div><div class="line">        str = <span class="string">"hello"</span>;</div><div class="line">        <span class="comment">//定义a Field时已经指定了默认值，不能为a重新赋值，下面语句非法</span></div><div class="line">        a = <span class="number">9</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//静态初始化块，可对没有指定默认值的类Field指定初始值</span></div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        <span class="comment">//在静态初始化块中为类指定初始值，合法</span></div><div class="line">        d = <span class="number">5.6</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//构造器，可对既没有指定默认值，又没有在初始化块中指定初始值的实例Field指定初始值</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalVarTest</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//如果初始化块中对str指定了初始值</span></div><div class="line">        <span class="comment">//则构造器中不能对final变量重新赋值，下面语句非法。</span></div><div class="line">        <span class="comment">//str = "Java";</span></div><div class="line">        c = <span class="number">5</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeFinal</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//普通方法不能为final修饰的成员变量赋值</span></div><div class="line">        <span class="comment">//d = 1.2;</span></div><div class="line">        <span class="comment">//不能在普通方法中为final成员变量指定初始值</span></div><div class="line">        <span class="comment">//ch = 'a';</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        FinalVarTest ft = <span class="keyword">new</span> FinalVarTest();</div><div class="line">        System.out.println(ft.a);</div><div class="line">        System.out.println(ft.c);</div><div class="line">        System.out.println(ft.d);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="二、final局部变量"><a href="#二、final局部变量" class="headerlink" title="二、final局部变量"></a>二、final局部变量</h2><p>系统不会对局部变量进行初始化，局部变量必须由程序员显示初始化。因此，使用final修饰的局部变量时，既可以在定义时指定默认值，也可以不指定默认值。</p>
<p>规则：如果final修饰的局部变量在定义时没有指定默认值，则可以在后面的代码中对final变量赋初始值，但只能一次，不能重复赋值；如果final修饰的局部变量定义在定义时已经指定默认值，则后面的代码中不能再次对该变量赋值。下面程序示范了final修饰局部变量、形参的情形。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinalLocalVarTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> a)</span></span>&#123;</div><div class="line">        <span class="comment">//不能对final修饰的形参赋值，下面语句非法</span></div><div class="line">        <span class="comment">//a = 5;</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//定义final局部变量时指定默认值，则str变量无法重新赋值</span></div><div class="line">        <span class="keyword">final</span> String str = <span class="string">"hello"</span>;</div><div class="line">        <span class="comment">//下面语句非法</span></div><div class="line">        <span class="comment">//str = "Java";</span></div><div class="line">        <span class="comment">//定义final局部变量没有指定默认值，则d变量可以被赋值一次</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">double</span> d;</div><div class="line">        <span class="comment">//第一次赋值，成功</span></div><div class="line">        d = <span class="number">5.6</span>;</div><div class="line">        <span class="comment">//对final变量重复赋值，下面语句非法</span></div><div class="line">        <span class="comment">//d = 3.4;</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="三、final修饰基本类型变量和引用类型变量的区别"><a href="#三、final修饰基本类型变量和引用类型变量的区别" class="headerlink" title="三、final修饰基本类型变量和引用类型变量的区别"></a>三、final修饰基本类型变量和引用类型变量的区别</h2><p>当使用final修饰基本类型变量时，不能对基本类型变量重新赋值，因此基本类型变量不能被改变。但对于引用类型变量而言，它保存的仅仅是一个引用，final只保证这个引用类型变量所引用的地址不会改变，即一直引用同一个对象，但这个对象完全可以发生改变。</p>
<h2 id="四、可执行“宏替换”的final变量"><a href="#四、可执行“宏替换”的final变量" class="headerlink" title="四、可执行“宏替换”的final变量"></a>四、可执行“宏替换”的final变量</h2><p>对于一个final变量来说，不管它是类Field、实例Field，还是局部变量，只要该变量满足3个条件，这个final变量就不再是一个变量，而是相当于一个直接量：</p>
<ol>
<li>使用final修饰符修饰；</li>
<li>在定义该final变量时指定了初始值；</li>
<li>该初始值可以在编译时就被确定下来。</li>
</ol>
<p>看如下程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinalLocalTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//定义一个普通局部变量</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> a =<span class="number">5</span>;</div><div class="line">        System.out.println(a);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于上面程序来说，变量a其实根本不存在，当程序执行<code>System.out.println(a);</code>代码时，实际转换为执行<code>System.out.prinltn(5)</code>。“宏变量”，编译器会把程序中所有用到该变量的地方直接替换成该变量的值。</p>
<h2 id="五、final方法"><a href="#五、final方法" class="headerlink" title="五、final方法"></a>五、final方法</h2><p>final修饰的方法不可被重写，如果处于某种原因，不希望子类重写父类的某个方法，则可以使用final修饰该方法。</p>
<p>Java提供的Object类里就有一个final方法：<code>getClass()</code>。因为Java不希望任何类重写该方法，所以使用final把这个方法密封起来。但对于该类提供的<code>toString()</code>和<code>equals()</code>方法，都允许子类重写，因此没有使用final修饰它们。</p>
<p>下面程序试图重写final方法，将会引发编译错误。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinalMethodTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;&#125;;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">FinalMethodTest</span></span>&#123;</div><div class="line">    <span class="comment">//下面方法定义将出现编译错误，不能重写final方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于一个private方法，因为它仅在当前类中可见，其子类无法访问该方法，所以子类无法重写该方法——如果子类定义一个与父类private方法有相同的方法名、相同形参列表、相同返回值类的方法，也不是方法重写，只是重新定义了一个新方法。因此。即使final修饰一个private访问权限的方法，依然可以在其子类中定义与该方法具有相同方法名、相同形参列表、相同返回值类的方法。</p>
<p>下面程序示范了如何在子类中“重写”父类的private final方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrivateFinalMethodTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;&#125;;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">PrivateFinalMethodTest</span></span>&#123;</div><div class="line">    <span class="comment">//下面方法定义不会出现任何问题</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>final修饰的方法仅仅是不能被重写，并不是不能被重载，因此，下面程序完全没有问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinalOverload</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;&#125;;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String arg)</span></span>&#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="六、final类"><a href="#六、final类" class="headerlink" title="六、final类"></a>六、final类</h2><p>final修饰的类不可有子类，例如<code>java.lang.Math</code>类就是一个final类，它不可以有子类。</p>
<p>当子类继承父类时，可以访问到父类内部数据，并可以通过重写父类方法来改变父类方法的实现细节，这可能导致一些不安全的因素。为了保证某个类不可被继承，则可以使用final修饰这个类。下面代码示范了final修饰的类不可被继承。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalOverload</span> </span>&#123;&#125;</div><div class="line"><span class="comment">//下面的类定义将出现编译错误</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">FinalClass</span></span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<h2 id="七、不可变类"><a href="#七、不可变类" class="headerlink" title="七、不可变类"></a>七、不可变类</h2><p>不可变类的意思是，创建该类的实例后，该实例的Field是不可以被改变的。Java提供的8个包装类和Java.lang.String类都是不可变类，当创建它们的实例后，其实例的Field不可改变。</p>
<p>如果需要创建自定义的不可变类，可遵守如下规则：</p>
<ol>
<li>使用private和final修饰符修饰该类的Field；</li>
<li>提供带参数的构造器，用于根据传入的参数来初始化类里面的Field；</li>
<li>仅为该类的Field的提供getter方法，不要为该类的Field提供setter方法，因为普通方法无法修改final修饰的Field；</li>
<li>如果有必要，重写Object类的hashCode和equals方法，equal方法以关键Field来作为判断两个对象是否相等的标准，除此之外，还应该保证两个用equal方法判断为相等的对象的hashCode也相等。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javase </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java的方法详解]]></title>
      <url>/2015/07/05/Java%E7%9A%84%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>什么是方法？方法是类或对象的行为特征抽象，是类或对象的最重要组成部分。考试都喜欢考概念，你不是不懂，但就是还差那么一点，就比如问你什么是语文，什么是数学。。。。方法从功能上讲，完全类似于JavaScript等结构化程序设计语言里的函数。值得指出的是，Java中的方法并不能独立存在，所有的方法都必须定义在类里。方法在逻辑上要么属于类本身，要么属于类的对象。<br><a id="more"></a></p>
<h2 id="方法属于类本身或类的实例"><a href="#方法属于类本身或类的实例" class="headerlink" title="方法属于类本身或类的实例"></a>方法属于类本身或类的实例</h2><p>不论是从定义方法的语法上看，还是从方法的功能上来看，都不难发现方法和函数有着显著的相似性，在结构化编程语言里，如C、JavaScript，函数是一等公民，整个系统由一个个函数组成；在面向对象的编程语言中，类才是一等公民，整个系统由一个个类组成。因此，在Java语言里，方法不能独立存在，方法必须属于类或对象。</p>
<p>如果需要定义方法，则只能在类体中定义，不能独立的定义一个方法，一旦将某个方法定义在某个类体中，如果这个方法使用static修饰，则这个方法属于这个类本身，否则这个方法属于这个类的实例。</p>
<p>Java语言是静态的，一个类定义完成后，只要不重新编译这个类文件，该类和该类的对象所拥有的方法是固定的，永远都不会改变。</p>
<p>因为Java里的方法不能独立存在，必须属于一个类或一个对象，因此方法也不能像函数那样被独立执行，执行方法时必须使用类或对象来作为调用者，即所有方法都必须使用“类.方法”或“对象.方法”的形式来调用。这里可能产生一个问题：同一个类里不同方法之间相互调用时，不就是可以直接调用吗？这路需要指出的是：同一个类中的一个方法调用另一个方法时，如果被调用的方法时普通方法，则默认使用this前缀，使用this来作为调用者；如果被调用的方法是静态方法（static），则默认使用类作为调用者。也就是说，表面上看起来某些方法可以被独立执行，但实际上还是使用this或类来作为调用者。</p>
<p>永远不要把方法当成独立存在的实体，正如现实世界由类和对象组成，而方法只能作为类和对象的附属，Java语言里的方法也一样。Java语言里方法的所属性主要体现在如下几个方面：</p>
<ol>
<li>方法不能独立定义，方法只能在类体里定义。</li>
<li>从逻辑意义上来看，方法要么属于该类本身，要么属于该类的一个对象。</li>
<li>永远不能独立执行方法，执行方法必须使用类或对象作为调用者。</li>
</ol>
<p>使用static修饰的方法属于类本身，使用static修饰的方法既可以使用类作为调用者，也可以使用对象作为调用者，但值得指出的是，因为使用static修饰的方法还是属于这个类的，因此使用类的任何对象来调用这个方法时将会得到相同的执行结果，因为实际上还是使用这些实例的类作为调用者。</p>
<h2 id="基本类型的参数传递机制"><a href="#基本类型的参数传递机制" class="headerlink" title="基本类型的参数传递机制"></a>基本类型的参数传递机制</h2><p>前面已经说过，Java的方法是不能独立存在的，调用方法也必须使用类或对象作为主调着。如果声明方法时包含了形参声明，则调用方法时必须给这些形参指定参数值，调用方法时实际传给形参的参数值h也就是被称为实参。那么Java的实参值是如何传入方法的呢？这是由Java方法的参数传递机制来控制的。Java里方法的参数传递方法只有一种：值传递。所谓值传递，就是将实参的副本传入方法内，而参数本身不受任何影响。</p>
<p>下面是一个典型的值传递的效果程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AugrsTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</div><div class="line">        <span class="comment">//下面代码实现a，b变量的互换</span></div><div class="line">        <span class="keyword">int</span> temp = a;</div><div class="line">        a = b;</div><div class="line">        b = temp;</div><div class="line">        System.out.println(<span class="string">"swap方法里，a的值是："</span>+a+<span class="string">",b的值是："</span>+b);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> a = <span class="number">6</span>;</div><div class="line">        <span class="keyword">int</span> b = <span class="number">9</span>;</div><div class="line">        swap(a,b);</div><div class="line">        System.out.println(<span class="string">"交换后，变量a的值是："</span>+a+<span class="string">"，b的值是："</span>+b);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行上面程序看到如下输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">swap方法里，a的值是：9,b的值是：6</div><div class="line">交换后，变量a的值是：6，b的值是：9</div></pre></td></tr></table></figure></p>
<p>从上面的运行结果来看，swap方法里a和b的值是9，6，交换结束后，变量a和b的值依然是6、9.从这个运行结果可以看出，main方法里的变量a和b，并不是swap方法里的a和b。正如前面所说的，swap方法的a和b只是main方法变量a和b的复制品。下面通过内存示意图来说明上面程序执行的过程。Java程序总是从mian方法开始执行的，main方法开始定义了a、b两个局部变量，两个变量在内存中的存储示意图如图1：</p>
<p><img src="http://duni-article.stor.sinaapp.com/201507/method/0.png" alt=""></p>
<p>图1：main方法中定义了a、b变量存储示意图 图2：main方法中的变量作为参数值传入swap方法存储示意图<br>在main方法中调用swap方法时，main方法还未结束。因此，系统分别为main方法和swap方法分配两块栈区，用于保存main方法和swap方法的局部变量。main方法中的a、b变量将作为参数值传入swap方法，实际上是在swap方法栈区中重新产生了两个变量a、b并将main方法栈区中的a、b变量的值分别赋给swap方法栈区中的a、b参数（就是对swap方法的a、b形参进行初始化）。此时，系统存在两个a变量，两个b变量，只是存在于不同的方法栈区而已。</p>
<p>程序在swap方法中交换a、b两个变量的值，实际上是对图2中灰色覆盖区域的a、b变量进行交换，交换结束后swap方法中输出a、b变量的值，看到a的值为9，b的值为6，此时内存中的存储示意图如图3：</p>
<p><img src="http://duni-article.stor.sinaapp.com/201507/method/1.png" alt="图3：swap方法中a、b变量交换后存储示意图"></p>
<p>对比图2、图3，两个示意图中main方法栈区中a、b的值并未有任何改变，程序改变的只是swap方法栈区中的a、b。这就是值传递的实质：当系统开始执行方法时，系统为形参执行初始化，就是把实参变量的值赋给方法的形参变量，方法里操作的并不是实际的实参变量。</p>
<h2 id="引用类型的参数传递机制"><a href="#引用类型的参数传递机制" class="headerlink" title="引用类型的参数传递机制"></a>引用类型的参数传递机制</h2><p>引用类型的参数传递，其实一样采用的是值传递方法，只是引用类型的值传递很迷惑人，下面程序示范了引用类型的参数传递的效果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataWrap</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> a;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> b;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefreTest</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(DateWrap wd)</span></span>&#123;</div><div class="line">        <span class="comment">//下面代码实现a，b变量的互换</span></div><div class="line">        <span class="keyword">int</span> tmp = dw.a;</div><div class="line">        dw.a = dw.b;</div><div class="line">        dw.b = temp;</div><div class="line">        System.out.println(<span class="string">"交换结束后，a的值是："</span>+dw.a+<span class="string">";b的值是："</span>+dw.b);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        DataWrap dw = <span class="keyword">new</span> DataWrap();</div><div class="line">        dw.a = <span class="number">6</span>;</div><div class="line">        dw.b = <span class="number">9</span>;</div><div class="line">        swap(dw);</div><div class="line">        System.out.println(<span class="string">"交换结束后，a的值是："</span>+dw.a+<span class="string">";b的值是："</span>+dw.b);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">———- 运行 ———-</div><div class="line">交换结束后，a的值是：9;b的值是：6</div><div class="line">交换结束后，a的值是：9;b的值是：6</div></pre></td></tr></table></figure></p>
<p>输出完成 (耗时: 0 秒) – 正常终止</p>
<p>从上面运行效果来看，在swap方法里，a、b两个变量的值被成功交换，不仅如此，main方法里swap方法执行结束后，a、b变量也被交换了，这很容易造成一种错觉：调用swap方法时，传入swap方法的就是dw对象本身，而不是它的复制品，但这只是一种假象罢了，下面结合图像来说明程序的执行过程。</p>
<p>程序从main方法开始执行，main方法开始创建了一个DataWrap对象，并定义一个dw引用变量来指向DataWrap对象，这是一个与基本类型不同的地方。创建一个对象时，系统内存中有两个东西：堆内存中保存了对象本身，栈内存中保存了引用该对象的引用变量。接着程序通过引用来操作DataWrap对象，把该对象的a、b两个Field分别赋值为6、9.此时系统内存中的存储示意图如图4：</p>
<p><img src="http://duni-article.stor.sinaapp.com/201507/method/2.png" alt="图4：main方法中创建了DataWrap对象后的存储示意图"></p>
<p>接下来，main方法中开始调用swap方法，main方法并未结束，系统会分别开辟出main和swap两个栈区，用于存放mian和swap方法的局部变量。调用swap方法时，dw变量作为实参传入swap方法，同意采取值传递方式：把mian方法里的dw变量的值赋给swap方法里的dw形参，从而完成swap方法的dw形参的初始化，值得指出的是，main方法中的dw是一个引用（指针），它保了DataWrap对象的地址值，当把dw的值赋给swap方法的dw形参后，即让swap方法的dw形参也保存这个地址值，即也会引用到堆内存中的DataWrap对象。图5显示了dw传入swap方法后的存储示意图。</p>
<p><img src="http://duni-article.stor.sinaapp.com/201507/method/3.png" alt="图5：main方法中的dw传入swap方法后的存储示意图"></p>
<p>从图5来看，这种参数传递方式是不折不扣的值传递方式，系统一样复制了dw的副本传入swap方法，但关键在于dw只是一个引用变量，所以系统复制了dw变量，但并未复制DataWrap对象。</p>
<p>当程序在swap方法中操作dw形参时，由于dw只是一个引用变量，故实际上操作的还是堆内存中的DataWrap对象，此时，不管是操作main方法里的dw变量，还是操作swap方法里的dw参数，其实都是操作它所引用的DataWrap对象，它们操作的是同一个对象。因此，当swap方法中交换dw参数所引用的DataWrap对象的a、b两个变量值后，我们看到mian方法中的dw变量所引用的DataWrap对象中的a、b两个Field值也被交换了。</p>
<p>为了更好的证明main方法中的dw和swap方法中的dw是两个变量，我们在swap方法的最后一行增加如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//把dw直接赋值为null，让它不再指向任何有效地址</span></div><div class="line">dw = <span class="keyword">null</span>;</div></pre></td></tr></table></figure></p>
<p>执行上面代码的结果是swap方法中的dw变量不再指向任何有效的内存，程序在其他地方不做任何修改，main方法调用了swap方法后，再次访问dw变量的a、b两个Field，依然可以输出9，6。可mian方法中的dw变量没有受到任何影响。实际上，当swap方法中增加dw = null；代码后，内存中的存储示意图如图6</p>
<p><img src="http://duni-article.stor.sinaapp.com/201507/method/4.png" alt="图6：将swap方法的dw赋值为null后存储示意图"></p>
<p>从图6来看，把swap方法中dw赋值为null后，swap方法中失去了DataWrap的引用，不可再访问堆内存中的DataWrap对象，但main方法中的dw变量不受任何影响，依然引用DataWrap对象的a、b Field值。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javase </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[对象的this引用]]></title>
      <url>/2015/06/28/%E5%AF%B9%E8%B1%A1%E7%9A%84this%E5%BC%95%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>Java提供了this关键字，this关键字总是指向调用该方法的对象。根据this出现的位置不同，this作为对象的默认引用有两种情形：</p>
<ol>
<li>构造器中引用该构造器正在初始化的对象；</li>
<li>在方法中引用调用该方法的对象。<a id="more"></a>
<h2 id="在方法中引用调用该方法的对象"><a href="#在方法中引用调用该方法的对象" class="headerlink" title="在方法中引用调用该方法的对象"></a>在方法中引用调用该方法的对象</h2></li>
</ol>
<p>this关键字最大的作用就是让类中一个方法，访问该类里的另一个方法或Field。假设定义了一个Dog类，这个Dog对象的run方法需要调用它的jump方法，那么应该如何做呢？是否应该定义如下的Dog类呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</div><div class="line">    <span class="comment">//定义一个jump方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span></span>&#123;</div><div class="line">         System.out.println(<span class="string">"正在执行jump方法"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//定义一个run方法，run方法需要借助jump方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">         Dog d = <span class="keyword">new</span> Dog();</div><div class="line">         d.jump();</div><div class="line">         System.out.println(<span class="string">"正在执行run方法"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用这种方式来定义这个Dog类，确实可以实现在run方法中调用jump方法。那么这种做法是否够好呢？下面在提供一个程序来创建Dog对象，并调用该对象的run方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogTest</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">         <span class="comment">//创建Dog对象</span></div><div class="line">         Dog dog = <span class="keyword">new</span> Dog();</div><div class="line">         <span class="comment">//调用Dog对象的run方法</span></div><div class="line">         dog.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在上面程序中，一共产生了两个Dog对象，在Dog类的run方法中，程序创建了一个Dog对象，并使用名为d的引用变量来指向该Dog对象；在DogTest的main方法中，程序再次创建了一个Dog对象，并使用名为dog的引用变量来指向该Dog对象。</p>
<p>这里产生了两个问题。第一个问题：在run方法中调用jump方法时是否需一定需要一个Dog对象？第二个问题：是否一定需要重新创建一个Dog对象？第一个问题的答案是肯定的，因为没有使用static修饰的Field和方法都必须使用对象来调用。第二个问题的答案是否定的，因为当程序调用run方法时，一定会提供一个Dog对象，这样就可以直接使用这个已经存在的Dog对象，而无需重新创建新的Dog对象了。</p>
<p>为此，我们需要在run方法中获得调用该方法的对象，通过this关键字就可以满足这个要求。</p>
<p>this可以代表任何对象，当this出现在某个方法中时，它所代表的对象是不确定的，但它的类型是确定的，它所代表的对象只能是当前类，只有当这个方法被调用时，它所代表的对象才被确定下来：<strong>谁在调用这个方法，this就代表谁。</strong></p>
<p>将前面的Dog类改写为如下形式会更加合适：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</div><div class="line">    <span class="comment">//定义一个jump方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span></span>&#123;</div><div class="line">         System.out.println(<span class="string">"正在执行jump方法"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//定义一个run方法，run方法需要借助jump方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">         <span class="comment">//使用this引用调用jump()方法的对象</span></div><div class="line">         <span class="keyword">this</span>.jump();</div><div class="line">         <span class="comment">//可以省略this</span></div><div class="line">         <span class="comment">//jump();</span></div><div class="line">         System.out.println(<span class="string">"正在执行run方法"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以省略this前缀，大部分时候，一个方法访问该类中定义的其他方法、Field时加不加this前缀的效果是完全一样的。</p>
<p><strong>为什么说this与static不能共存？</strong><br>对于static修饰的方法而言，则可以使用类来直接调用该方法，如果在static修饰的方法中使用this关键字，则这个关键字就无法指向合适的对象。所以，static修饰的方法中不能使用this引用。由于static修饰的方法不能使用this引用，所以static修饰的方法不能访问不使用static修饰的普通成员，因此，Java语法规定：<strong>静态成员不能访问非静态成员。</strong></p>
<p>如果确实需要在静态方法中访问另一个普通方法，则只能通过重新创建一个对象，例如上面的jump调用可以改为如下形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Dog().jump();</div></pre></td></tr></table></figure></p>
<p><strong>什么时候需要使用this前缀？</strong><br>大部分时候，普通方法访问其他方法、Field时无需使用this前缀，但如果方法里有局部变量和Field同名，但程序有需要在该方法里访问这个被覆盖的Filed，则必须使用this前缀。</p>
<h2 id="构造器中引用该构造器正在初始化的对象"><a href="#构造器中引用该构造器正在初始化的对象" class="headerlink" title="构造器中引用该构造器正在初始化的对象"></a>构造器中引用该构造器正在初始化的对象</h2><p>this引用也可以用于构造器中作为默认的引用，这恐怕是我们看到this应用最多最明显的地方吧，由于构造器是直接使用new关键字来调用的，而不是使用对象来调用的，所以this在构造器中引用的是该构造器进行初始化的对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisInConstructor</span> </span>&#123;</div><div class="line">    <span class="comment">//定义一个名为foo的Field</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> foo;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThisInConstructor</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//在构造器里定义一个foo变量</span></div><div class="line">        <span class="keyword">int</span> foo = <span class="number">0</span>;</div><div class="line">        <span class="comment">//使用this代表此构造器进行初始化的对象</span></div><div class="line">        <span class="comment">//下面的代码将会把刚创建对象的foo Field设置为6</span></div><div class="line">        <span class="keyword">this</span>.foo = <span class="number">6</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//所有使用ThisInConstructor创建的对象的foo Field</span></div><div class="line">        <span class="comment">//都将被设为6，所以下面代码将会输出6</span></div><div class="line">        System.out.println(<span class="keyword">new</span> ThisInConstructor().foo);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在ThisInConstructor构造器中使用this引用时，this总是引用该构造器正在初始化的对象。程序弟9行将正在执行初始化的ThisInConstructor对象的foo Field设为6，这意味着该构造器返回的所有对象的foo Field都等于6.</p>
<p>与普通方法类似的是，大部分时候，在构造器中访问其他Field和方法时都可以省略this前缀，但如果构造器中有一个与Field同名的局部变量，又必须在构造器中访问这个被覆盖的Field，则必须使用this前缀。</p>
<p>当this作为对象的默认引用时，程序可以像访问普通引用变量一样来访问这个this引用，甚至可以把this当成普通方法的返回值。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javase </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数组与内存分配]]></title>
      <url>/2015/06/27/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数组是编程语言中最常见的数据结构，可用于存储多个数据，每个数组元素存放一个数据，通常可通过数组元素的索引来访问数组元素，包括为数组元素赋值和取出数组元素的值。Java数组并不是什么很难的知识，如果单从语法角度来看，数组的用法并不不难，只是对Java数组的内存分配可能不是很明白，《Java雇佣兵之数组与内存分配》系列尝试探讨从基础到内存分配的两大方面全面介绍Java的数组知识。</p>
<h2 id="一、数组入门"><a href="#一、数组入门" class="headerlink" title="一、数组入门"></a>一、数组入门</h2><h3 id="1、首先明确一点：数组也是一种类型"><a href="#1、首先明确一点：数组也是一种类型" class="headerlink" title="1、首先明确一点：数组也是一种类型"></a>1、首先明确一点：数组也是一种类型</h3><p>Java数组要求所有的数组元素具有相同的数据类型。因此，在一个数组中，数组元素的类型是唯一的，即要求数组里只能存储一种类型的数据，而不能存储多种数据类型的数据。</p>
<p>一旦数组的初始化完成，数组在内存中所占的空间将被固定下来，因此数组的长度将不可改变。即使把某个数组元素的数据清空，但它所占的空间依然被保留下来，依然属于该数组，数组的长度依然不变。Java数组既可以存储基本数据类型数据，也可以存储引用类型数据，只要所有的数组元素具有相同的类型即可。</p>
<p>值得指出的是，数组也是一种数据类型，它本身是一种引用类型。例如int是一个基本类型，但int[]就是一种引用类型了。</p>
<h3 id="2、定义数组"><a href="#2、定义数组" class="headerlink" title="2、定义数组"></a>2、定义数组</h3><p><strong>关于定义数组的语法</strong><br>Java语言支持两种语法格式来定义数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">type[] arrayName;</div><div class="line">type arrayName[];</div></pre></td></tr></table></figure></p>
<p>对于这种两种语法格式而言，通常推荐使用第一种格式。因为第一种格式不仅具有更好的语意，而且具有更好的可读性。对于<code>type[] arrayName;</code>方式，很容易理解这是定义一个变量，其中变量名是arrayName，而变量类型是<code>type[]</code>。<code>type[]</code>是一种新类型，与type完全不同，例如，int类型是几本类型，但<code>int[]</code>是引用类型，因此，这种方式既容易理解也符合定义变量的语法。但这第二种个事故<code>type arrayname[]</code>的可读性就差了，看起来好像定义了一个类型为type的变量，而变量名是<code>arrayName[]</code>，这与真实的含义相去甚远。Java的这个设计就很糟糕，语法就像数学上的公理和定义，不要让语法产生歧义。</p>
<p><strong>定义数组时不能指定数组长度？（是的，为什么？）</strong><br>数组是一种引用类型的变量，因此使用它定义一个变量时，仅仅表示定义了一个引用变量（可以认为是指针），这个引用变量还未指向任何有效的内存，因此定义数组时不能指定数组长度。而且由于定义数组只是定义了一个引用变量，并未指向任何有效的内存空间，所以还没有内存空间来存储数组元素，因此这个数组也不能使用，只有对数组进行初始化后才能使用。说白了，就是还没有内存空间，所以你还什么都干不了。</p>
<h3 id="3、数组的初始化"><a href="#3、数组的初始化" class="headerlink" title="3、数组的初始化"></a>3、数组的初始化</h3><p>Java语言中数组必须先初始化，然后才可以使用。所谓初始化，就是为数组的数组元素分配内存空间，并为每个数组元素赋初始值。</p>
<p><strong>能不能只分配内存空间而不赋予初始值呢？</strong><br>不能。一旦为数组的每个数组元素分配了内存空间，每个内存空间里存储的内容就是该数组元素的值，即使这个内存空间存储的内容是空，这个空也是一个值（null）。不管以哪种方式来初始化数组，只要为数组元素分配了内存空间，数组元素就具有了初始值。初始值的获得有两种方式：一种由系统自动分配，另一种由程序员指定。</p>
<p><strong>数组的初始化的两种方式</strong></p>
<ul>
<li>静态初始化：初始化时有程序员显示指定每个数组元素的初始值，由系统决定数组的长度。</li>
<li>动态初始化：初始化时程序员只指定数组长度，由系统分配数组元素的初始值。</li>
</ul>
<p><strong>静态初始化</strong><br>语法格式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arrayName = <span class="keyword">new</span> type[]&#123;element1,element2,element3,element4,....&#125;</div></pre></td></tr></table></figure></p>
<p>在上面的语法格式中，前面的type就是数组元素的数据类型，此处的type必须与定义数组变量时所使用的type相同，也可以是定义数组时所指定的type的子类。下面举个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义一个int数组类型的变量，变量名为intArr</span></div><div class="line"><span class="keyword">int</span>[] intArr;</div><div class="line"><span class="comment">//使用静态初始化，初始化时只只指定数组元素的初始值，不指定数组长度</span></div><div class="line">intArr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</div><div class="line"><span class="comment">//定义一个object数组类的变量，变量名为objArr</span></div><div class="line">Object[] objArr;</div><div class="line"><span class="comment">//使用静态初始化。初始化数组元素的类型是定义数组时数组元素的子类。</span></div><div class="line">objArr = <span class="keyword">new</span> String[]&#123;<span class="string">"Java"</span>,<span class="string">"C#"</span>&#125;</div><div class="line">Object objArr2;</div><div class="line">objArr2 = <span class="keyword">new</span> Object[]&#123;<span class="string">"Java"</span>,<span class="string">"C#"</span>&#125;</div></pre></td></tr></table></figure></p>
<p>因为Java语言是面向对象的编程语言，能很好的支持子类和父类的继承关系：子类实例是一种特殊的父类实例。在上面程序中，String类型是Object类型的子类，即字符串是一种特殊的Object实例。</p>
<p>除此之外，静态初始化还有如下简化的语法格式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arryName = &#123;element1,element2,element3,...&#125;</div></pre></td></tr></table></figure></p>
<p>在这种语法格式中，直接使用花括号来定义一个数组，在实际开发中，可能更习惯使用这种方式来定义和初始化数组，上面的代码也可以如下，等价：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] intArr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</div></pre></td></tr></table></figure></p>
<p><strong>动态初始化</strong><br>动态初始化只指定数组的长度，由系统为每个数组元素指定初始值。动态初始化的语法格式如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arryName = <span class="keyword">new</span> type[length];</div></pre></td></tr></table></figure></p>
<p>在上面语法中，需要指定一个int类型的length参数，这个参数之地呢了数组的长度，也即是可以容纳的数组元素的个数。与静态初始化相似的是，此处的type必须与定义数组时使用的type类型要相同，或者是定义数组时使用的type类型的子类。下面代码演示了动态初始化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] prices = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</div><div class="line">Object[] books = <span class="keyword">new</span> String[<span class="number">4</span>];</div></pre></td></tr></table></figure></p>
<p>指向初始化时，程序员只需要指定数组的长度，即为每个数组元素指定所需要的内存空间，系统将负责为这些数组元素分配初始值。那么系统时按什么规则来分配初始值的呢？规则如下：<br>a. 数组元素的类型是基本类型中的整数类型时（byte、short、int和long），则数组元素的值是0；<br>b. 数组元素的类型是基本类型中的浮点类型（float、double），则数组元素的值是<code>0.0</code>；<br>c. 数组元素的类型是基本类型中的字符类型（char），则数组元素的值是<code>\u0000</code>；<br>d. 数组元素的类型是基本类型中的布尔类型（boolean），则数组元素的值是<code>false</code>；<br>e. 数组元素的类型是引用类型（类、接口和数组），则数组元素的值是<code>null</code>；</p>
<h3 id="4、数组一定要初始化吗？"><a href="#4、数组一定要初始化吗？" class="headerlink" title="4、数组一定要初始化吗？"></a>4、数组一定要初始化吗？</h3><p>从前面我们已经知道，使用java数组之前必须先初始化数组，也就是位数组元素分配空间，并指定初始值。实际上，如果真正掌握了Java数组在内存中的分配机制，那么完全可以换一个方式来 初始化数组，或者说，数组无须经过初始化。</p>
<p>始终记住：java的数组变量是引用类型的变量，他并不是数组对象本身，只要让数组变量指向有效的数组对象，程序中即可使用该数组变量，示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	<span class="comment">//定义并初始化nums数组</span></div><div class="line">	<span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">20</span>, <span class="number">12</span>&#125;;</div><div class="line">	<span class="comment">//定义一个prices数组变量</span></div><div class="line">	<span class="keyword">int</span>[] prices;</div><div class="line">	<span class="comment">//让prices数组指向nums所引用的数组</span></div><div class="line">	prices = nums;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; prices.length ; i++ )&#123;</div><div class="line">		System.out.println(prices[i]);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//将prices数组的第三个元素赋值为34</span></div><div class="line">	prices[<span class="number">2</span>] = <span class="number">34</span>;</div><div class="line">	<span class="comment">//访问nums数组的第3个元素，将看到输出34</span></div><div class="line">	System.out.println(<span class="string">"nums数组的第3元素的值是："</span> + nums[<span class="number">2</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面粗体字可以看出，程序定义了prices数组之后，并对prices数组进行初始化。当执行int[] prices之后，程序在内存中的分配如下图：</p>
<p><img src="(http://duni-article.stor.sinaapp.com/201506%2Farray%2F0.png" alt="">)</p>
<p>当程序执行<code>prices = nums；</code>之后，prices变量将指向nums变量所引用的数组，此时prices变量和nums变量引用同一个数组对象。执行这条语句之后，prices变量已经指向有效的内存及一个长度为4的数组对象，因此程序完全可以正常使用prices变量了。</p>
<p>常常说使用Java数组之前必须先初始化，可是现在prices变量却无须初始化，这不是互相矛盾吗？其实一点都不矛盾。关键是大部分的时候，我们把数组变量和数组对象搞混了，数组变量只是一个引用变量（有点类似于C语言里的指针），通常存放在栈内存中（也可被放入堆内存中）；而数组对象就是保存在对内存中的连续内存空间。对数组执行初始化，其实并不是对数组变量执行初始化，而是要对数组对象执行初始化——也就是位该数组对象分配一块内存空间，这块连续的内存空间的长度就是数组长度。虽然上面程序中的prices变量看似没有经过初始化，但执行prices= nums;就会让prices变量直接指向一个已经执行初始化的数组。</p>
<h2 id="二、内存中的数组"><a href="#二、内存中的数组" class="headerlink" title="二、内存中的数组"></a>二、内存中的数组</h2><p>数组引用变量只是一个引用，这个引用变可以指向任何有效的内存，只有当该引用指向有效的内存后，才可通过该数组变量来访问数组元素。引用变量时访问真实对象的根本方式。也就是说，如果我们希望在程序中访问数组对象本身，则只能通过这个数组的引用变量来访问。</p>
<p>实际的数组对象被存储在堆（heap）内存中，如果引用该数组对象的数组引用变量是一个局部变量，那么它被存储在栈（stack）内存中。数组在内存中的存储示意图如下1：</p>
<p><img src="http://duni-article.stor.sinaapp.com/201506/array/1.png" alt="图1：数组在内存中的存储示意图"></p>
<p>如果需要访问图1所示堆内存中的数组元素，则程序中只能通过<code>p[index]</code>的形式实现。也就是说，数组引用变量时访问堆内存中数组元素的根本方式。</p>
<p>如果对内存中数组不在有任何引用变量指向自己，则这个数组将成为垃圾，该数组所占的内存将会被系统垃圾回收几只回收。因此，为了让垃圾回收机制回收一个数组所占用的内存空间，可以将该数组变量赋值为null，也就是切断了数组引用变量和实际数组之间的引用关系，实际的数组也就成为了垃圾。</p>
<p>只要类型相互兼容，就可以让一个数组变量指向另一个实际的数组，这种操作会让人产生数组的长度可变的错觉。如下面代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义并初始化一个数组，使用静态初始化</span></div><div class="line"><span class="keyword">int</span>[] a = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">20</span>];</div><div class="line"><span class="comment">//定义并初始化一个数组，使用动态初始化</span></div><div class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</div><div class="line"><span class="comment">//输出b数组的长度</span></div><div class="line">System.out.println(<span class="string">"b数组的长度："</span> + b.length);</div><div class="line"><span class="comment">//循环输出a数组的元素</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++)&#123;</div><div class="line">    System.out.println(a[i]);</div><div class="line">&#125;</div><div class="line"><span class="comment">//循环输出b数组的元素</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;b.length; i++)&#123;</div><div class="line">    System.out.println(b[i]);</div><div class="line">&#125;</div><div class="line"><span class="comment">//因为a是int类型,b也是，所以可以将a的值赋给b。</span></div><div class="line"><span class="comment">//也就是让b引用指向a引用指向的数组</span></div><div class="line">b = a;</div><div class="line"><span class="comment">//在此输出b数组的长度</span></div><div class="line">System.out.println(<span class="string">"b数组的长度为："</span> + b.length);</div></pre></td></tr></table></figure></p>
<p>输出结果：</p>
<p>看起来似乎数组的长度是可变的，但这只是一个假象。我们必须牢记：定义并初始化一个数组后，在内存中分配了两个空间，一个用于存放数组的引用变量，另一个用于存放数组本身。下面结合图像来说明上面程序都的运行过程。</p>
<p>当程序定义并初始化了两个a、b数组后，系统内存中实际产生了4块内存区域，其中栈内存中有两个引用变量：a和b，堆内存中也有两块内存区，分别用于存储a和b引用所指向的数组本身。此时计算机内存的存储示意图如下图：</p>
<p><img src="http://duni-article.stor.sinaapp.com/201506/array/3.png" alt="图2：定义并初始化a、b两个数组的存储示意图"></p>
<p>从图2中可以看出a和b引用个字所引用的数组对象，并可以很清楚的看出a变量所引用的数组长度是3，b变量所引用的数组长度是4。</p>
<p>当执行b=a时，系统将会把a的赋值给b，a和b都是引用类型变量，存储的是地址。因此把a的值赋给b后，就是让b指向a所指向的地址。此时计算机内存的存储示意图如下图：</p>
<p><img src="http://duni-article.stor.sinaapp.com/201506/array/4.png" alt="图3：让b引用指向a引用所指向的数组后的存储示意图"></p>
<p>从图3可以看出，当执行了b=a之后，堆内存中的第一个数组具有了两个引用：a变量和b变量都引用了第一个数组。此时第二个数组就失去了引用，就变成了垃圾了，只有等待垃圾回收机制来回收它——但它的长度依然保持不变，直到它彻底消失。</p>
<h3 id="1、基本类型数组的初始化"><a href="#1、基本类型数组的初始化" class="headerlink" title="1、基本类型数组的初始化"></a>1、基本类型数组的初始化</h3><p>对于基本数组类型而言，数组元素的值直接存储在对应数组元素中，因此，初始化数组时，先为该数组分配内存空间，然后直接将数组元素的值存入对应数组中。</p>
<p>下面程序定义了一个<code>int[]</code>类型的数组变量，采用动态初始化方式初始化了该数组，并显示的为每个数组元素赋值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">     <span class="keyword">int</span>[] iArr;</div><div class="line">     iArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</div><div class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; iArr.length ; i ++)&#123;</div><div class="line">	     iArr[i] = i + <span class="number">10</span>;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码的执行过程代表了基本类型数组初始化的典型过程。下面将集合示意图详细介绍这段代码的执行过程。<br>执行第一行代码<code>int[] iArr;</code>时，仅定义一个数组变量，此时内存中的存储示意图如图4：</p>
<p><img src="http://duni-article.stor.sinaapp.com/201506/array/5.png" alt="图4：定义iArr数组变量后的存储示意图"></p>
<p>执行了<code>int[] iArr;</code>后，仅在内存中定义了一个空引用（就是iArr数组变量），这个引用濒危指向任何有效的内存，淡然无法指定数组的长度。</p>
<p>当执行<code>iArr = new int[5];</code>动态初始化后，系统将负责为该数组分配内存空间，并分配默认的初始值；所有数组元素都被赋值为0，此时内存中的存储示意图如图5所示：</p>
<p><img src="http://duni-article.stor.sinaapp.com/201506/array/6.png" alt="图5：动态初始化iArr数组后的存储示意图"></p>
<p>此时iArr数组的每个元素的值都是0，当循环为该数组的每个元素一次赋值后，此时每个数组元素的值都变成程序显示指定的值。显示指定每个数组元素值后的存储示意图如下：</p>
<p><img src="http://duni-article.stor.sinaapp.com/201506/array/7.png" alt="图6：显示指定每个数组元素值后的存储示意图"></p>
<p>从上图中可以看到基本类型数组的存储示意图，每个数组元素的值直接存储在对应的内存中。操作基本类型数组的数组元素是，实际上就是操作基本类型的变量。</p>
<h3 id="2、引用类型数组的初始化"><a href="#2、引用类型数组的初始化" class="headerlink" title="2、引用类型数组的初始化"></a>2、引用类型数组的初始化</h3><p>引用类型数组的数组元素是引用，因此情况变得更为复杂。每个数组元素里存储的还是一个引用，它指向另一块内存，这块内存里存储了有效的数据。</p>
<p>为了更好的说明引用类型数组的运行过程，下面先定义一个Person类（所有类都是引用类型）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">	<span class="comment">//年龄</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> age;</div><div class="line">	<span class="comment">//身高</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">double</span> height;</div><div class="line">	<span class="comment">//定义一个info方法</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"我的年龄是："</span>+age +<span class="string">"，我的身高是："</span>+height);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面程序定义一个Person[]数组，接着动态初始化这个数组，并为每个数组元素指定值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTest</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">//定义一个students数组变量，其类型是Person[]</span></div><div class="line">		Person[] students;</div><div class="line">		<span class="comment">//执行动态初始化</span></div><div class="line">		students = <span class="keyword">new</span> Person[<span class="number">2</span>];</div><div class="line">		<span class="comment">//创建一个Person实例，并将这个Person实例赋给zhang变量</span></div><div class="line">		Person zhang = <span class="keyword">new</span> Person();</div><div class="line">		<span class="comment">//为zhang所引用的Person对象的age,height赋值</span></div><div class="line">		zhang.age = <span class="number">15</span>;</div><div class="line">		zhang.height = <span class="number">158</span>;</div><div class="line">		<span class="comment">//创建一个Person实例，并将这个Person实例赋给li变量</span></div><div class="line">		Perosn li = <span class="keyword">new</span> Person();</div><div class="line">		<span class="comment">//为li所引用的Person对象的age,height赋值</span></div><div class="line">		li.age = <span class="number">16</span>;</div><div class="line">		li.height = <span class="number">161</span>;</div><div class="line">		<span class="comment">//将zhang变量的值赋值给第一数组元素</span></div><div class="line">		students[<span class="number">0</span>] = zhang;</div><div class="line">		<span class="comment">//将li变量的值赋值给第二数组元素</span></div><div class="line">		students[<span class="number">1</span>] = li;</div><div class="line">		<span class="comment">//下面两行代码的结果完全一样，因为li和students[1]指向的是同一个Person实例</span></div><div class="line">		li.info();</div><div class="line">		stsudents[<span class="number">1</span>].info();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码的执行过程代表了引用类型数组初始化的典型过程。</p>
<p>执行<code>Person[] students;</code>代码时，这行代码仅仅在栈内存中定义了一个引用变量，也就是一个指针，这个指针还并没有指向任何有效的内存区。此时内存中存储示意图如下：</p>
<p><img src="http://duni-article.stor.sinaapp.com/201506/array/8.png" alt="图7：定义一个students数组变量后的存储示意图"></p>
<p>在上图中，栈内存中定义了一个students变量，它仅仅是一个引用，并未指向任何有效的内存，直到执行初始化，本程序对students数组执行动态初始化，动态初始化由系统为数组元素分配默认的初始值：null，即为每个数组元素的值都是null。执行动态初始化后的示意图如下图8：</p>
<p><img src="http://duni-article.stor.sinaapp.com/201506/array/9.png" alt="图8：执行动态初始化后的示意图"></p>
<p>从图8中可以看出，students数组的两个数组元素都是引用，而且这个引用并未指向任何有效的内存，因此每个数组元素的值都是null。这意味着依然不能直接使用students数组元素，因为每个数组元素都是null，这相当于定义了两个连续的Person变量，但这个变量还未指向任何有效的内存区，所以这两个连续的Person变量还不能使用。</p>
<p>接着代码定义了zhang和li两个Person实例，定义这两个实例实际上分配了4块内存，在栈内存中储存了zhang和li两个引用变量，还在堆内存中存储了两个Person实例，此时的内存示意图如下图9：</p>
<p><img src="http://duni-article.stor.sinaapp.com/201506/array/10.png" alt="图9：创建2个Person实例后的存储示意图"></p>
<p>此时students数组的两个元素依然是null，直到程序依次将zhang赋给students数组的第一个元素，把li赋给students数组的第二个元素，students数组的两个数组元素将会指向有效的内存区。此时的内存存储示意图如图10：</p>
<p><img src="http://duni-article.stor.sinaapp.com/201506/array/11.png" alt="图10：为数组赋值后的存储示意图"></p>
<p>此时<code>zhang</code>和<code>students[0]</code>指向同一个内存区，而且它们都是引用类型变量，因此通过<code>zhang</code>和<code>students[0]</code>来访问Person实例的Field和方法的效果完全一样，不论修改<code>students[0]</code>所指向的<code>Person</code>实例的<code>Field</code>还是修改<code>zhang</code>变量所指向的<code>Person</code>实例的Field，所修改的其实是同一个内存区，所以必然互相影响，同理，li和<code>students[1]</code>也是引用同一个Person对象，也具有相同的效果。</p>
]]></content>
      
        
        <tags>
            
            <tag> javase </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS常见问题(三)]]></title>
      <url>/2015/05/26/CSS%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98(%E4%B8%89)/</url>
      <content type="html"><![CDATA[<h2 id="display：inline-block和hasLayout"><a href="#display：inline-block和hasLayout" class="headerlink" title="display：inline-block和hasLayout"></a>display：inline-block和hasLayout</h2><p><code>display</code>的值除了<code>block</code>和<code>inline</code>，还有其他的值，比如<code>list-item</code>、<code>table-cell</code>等，但因为IE6和IE7浏览器支持的display类型很少，所以为了兼容IE，我们真正能用的display类型只有block、inline和none三种。</p>
<p>对于另一中非常有用的display类型inline-block，其实IE和IE7下也是有办法实现的，但需要注意的是，并不是说IE6和IE7支持display：inline-block，它的实现其实是一种hack——触发行内元素的hasLayout。在前面<a href="http://www.jianshu.com/p/35ec4d7200f9" target="_blank" rel="external">《CSS常见问题二：hasLayout》</a>我们讲过，hasLayout是IE浏览器为解释盒模型而设计的一个转有属性，它的设计初衷是用于块级元素的，如果触发行内元素的hasLayout，就会让行内元素拥有块级元素的特征。</p>
<p>先说说<code>display：inline-block</code>的特性吧，顾名思义，它是行内的块级元素，它拥有块级元素的特点，可以设置长宽，可以设置margin和padding值，但它却不是独占一行，它的宽度并不占满父元素，而是和行内元素一样，可以和其他行内元素排在同一行里。它集块级元素和行内元素的特点于一身，是个非常有用的display类型。</p>
<h2 id="relative、absolute和float"><a href="#relative、absolute和float" class="headerlink" title="relative、absolute和float"></a>relative、absolute和float</h2><p><code>position：relative</code>和<code>position：absolute</code>都可以改变元素在文档流中的位置，设置<code>position：relative</code>或<code>position：absolute</code>都可以让元素激活<code>left</code>、<code>right</code>、<code>top</code>、<code>bottom</code>和<code>z-index</code>属性（默认情况下，这些熟悉未激活，设置了也无效）。网页虽然看起来是平面的二维结构，但它其实是有Z轴的，Z轴的大小由<code>z-index</code>控制，默认情况下，所有元素都是在<code>z-index：0</code>这一层。元素根据自己的display类型、长宽、内外边距等属性顺序排列在<code>z-index：0</code>这一层里，这就是文档流。设置<code>position：relative</code>或<code>position：absolute</code>会让元素“浮”起来，也就是<code>z-index</code>的值大于0，它会改变正常情况下的文档流。不同的是<code>position：relative</code>会保留自己在<code>z-index：0</code>层的占位，left、top、right、bottom值是相对于自己在<code>z-index：0</code>层的位置，虽然它的实际位置可能因为设置了left、top、right、bottom值而偏离原来的位置，但对于其他仍然在<code>z-index：0</code>层的元素位置不会造成影响。而<code>position：absolute</code>会完全脱离文档流，不再在<code>z-index：0</code>层保留占位符，其left、top、right、bottom值是相对于自己最近的一个设置了<code>position：relative</code>和<code>position：absolute</code>的祖先元素的，如果祖先元素全都没有这是<code>position：relative</code>和<code>position：absolute</code>，那么就相对于body元素。</p>
<p>除了<code>position：relative</code>和<code>position：absolute</code>，float也能改变文档流，不同的是，float属性不会让元素“上浮”到另一个z-index层，它任然让元素在z-index：0层排列，float不像<code>position：relative</code>和<code>position：absolute</code>那样，它不能通过left、top、right、bottom属性精确地控制元素的坐标，它只能通过<code>float：left</code>或<code>float：right</code>来控制元素在同层里“左浮”“右浮”。float会改变正常的文档流排列，影响到周围元素。</p>
<p>另一个有趣的现象是<code>position：absolute</code>和float会隐式的改变display类型，不论之前什么类型的元素（display：none除外），只要设置了<code>position：absolute</code>、<code>float：left</code>或<code>float：right</code>中人一个，都会让元素以<code>display：inline-block</code>的方式显示：可以设置长宽，默认宽度并不占满父元素。就算我们显示的设置<code>display：inline</code>或者<code>display：block</code>，也任然是无效的（float在IE6下的双边距BUG就是利用添加<code>display：inline</code>来解决的）。值得注意的是，<code>position：relative</code>却不会隐式的改变display的类型。</p>
<p>跟多关于absolute、float、overflow的知识可以参考慕课网视频：<a href="">http://www.imooc.com/space/teacher/id/197450</a></p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS的常见问题(二)]]></title>
      <url>/2015/05/25/CSS%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98(%E4%BA%8C)/</url>
      <content type="html"><![CDATA[<h2 id="hasLayout"><a href="#hasLayout" class="headerlink" title="hasLayout"></a>hasLayout</h2><p>很多时候，CSS在IE下的解释十分奇怪，明明在Firefox下显示的非常正确，但到了IE下却出现了问题，有时候，这些问题甚至表的非常诡异——例如，一个比较经典的BUG就是设置<code>border</code>的时候，有时候<code>border</code>会断开，刷新页面或者滚动页面的时候，断掉的部分又会重新连接起来。</p>
<p>这些诡异的问题往往大部分和IE下的一个神秘的属性相关——hasLayout。</p>
<p>hasLayout是IE下的一个转有属性，用于CSS的解释引擎。有时候在IE下一些复杂的CSS设置解释起来会出现BUG，其原因可能是与hasLayout没有被自动触发有关，我们通过一些技巧，手动触发hasLayout属性就可以解决BUG了。这也算是针对IE下疑难杂症的特殊偏方了，很多时候，触发了hasLayout就可以药到病除了。</p>
<p>hasLayout的触发方法有很多种，例如设置<code>width</code>、<code>height</code>值，设置<code>position</code>为<code>relative</code>等。但如果设置了<code>width</code>、<code>height</code>或<code>position</code>都会触发hasLayout的同时带来一些副作用的。早期的工程师推荐使用<code>height：1%</code>来触发hasLayout，那时候还没有出现IE7，而height属性在IE6下其实是按照<code>min-height</code>来解释的，所以只要针对IE6进行hack，<code>* html{height:1%}</code>就可以触发hasLayout，同时又不带来副作用。后来出现的IE7任然存在很多hasLayout方面的问题，但IE7已经能够正确识别height属性了，<code>height：1%</code>的方法也就不再适用了。</p>
<p>于是，一个更好的方法开始流行了，它使用了一个生僻的CSS属性zoom来触发hasLayout——<code>zoom：1</code>可以触发hasLayout，并且不会像height等属性一样引入副作用，更妙的是，我们可以不用CSS hack了。但<code>zoom</code>并不是一定可以触发hasLayout的，在极少数的情况下，例如非常复杂的CSS设置，特别是使用DHTML的时候，使用“zoom：1”有时候也会无效，这时，我们可能需要借助更为强大的<code>position：relative</code>来帮助触发hasLayout，总之，<code>zoom</code>是最常用、最安全、成本最小的触发hasLayout的方式，一般情况下，使用它完全可以触发hasLayout了。如果遇到很特殊的情况，<code>zoom：1</code>无效的情况下，我们可以通过设置<code>position：relative</code>来触发hasLayout，尽管他会带来一点副作用。</p>
<p>值得强调的是，hasLayout的涉及初衷是用于辅助块级元素的盒模型解释的，他是用于块级元素的。如果用于行内元素，会引发一些特殊的效果。</p>
<p>值得庆幸的是，随着微软window10的推出，与之相伴的新浏览器斯巴达横空出世，IE成为永远的历史，不得不说，专治IE的各种私人解决方案会失效，我们不再需要为IE的各种诡异问题感到头痛，拥抱Webkit等新浏览器内核，相信前端WEB页面的工作会随Firefox一样，令人舒服（本人觉得Firefox是最懂开发者心的浏览器）。</p>
<h2 id="块级元素和行内元素的区别"><a href="#块级元素和行内元素的区别" class="headerlink" title="块级元素和行内元素的区别"></a>块级元素和行内元素的区别</h2><p>块级元素和行内元素是布局的最基本的两种元素，常见的块级元素有<code>div</code>、<code>p</code>、<code>form</code>、<code>ul</code>、<code>li</code>、<code>ol</code>等，常见的额行内元素有<code>span</code>、<code>strong</code>、<code>em</code>等。</p>
<p>块级元素和行内元素有什么区别呢？块级元素会独占一行，默认情况下，其宽度自动填满其父容器元素宽度，行内元素不会独占一行，相邻的元素排列在同一行中，直到一行拍不下才会换行，其宽度随元素的内容而变化。如如下代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;style type="text/css"&gt;</div><div class="line">p&#123;background-color: red;&#125;</div><div class="line">div&#123;background-color: yellow&#125;</div><div class="line">span&#123;background-color: blue&#125;</div><div class="line">strong&#123;background-color: green&#125;</div><div class="line">&lt;/style&gt;</div><div class="line"></div><div class="line">&lt;p&gt;块级元素P&lt;/p&gt;&lt;div&gt;块级元素DIV&lt;/div&gt;&lt;span&gt;行内元素span&lt;/span&gt;&lt;strong&gt;行内元素strong&lt;/strong&gt;</div></pre></td></tr></table></figure></p>
<p>在浏览器中的效果如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-6a8369f91245e8fb.png" alt="Paste_Image.png"></p>
<p>块级元素可以设置width、height属性，行内元素设置width、height属性无效。如下面代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;style type="text/css"&gt;</div><div class="line">p&#123;background-color: red;width: 200px;height: 200px;&#125;</div><div class="line">div&#123;background-color: yellow;width: 400px;height: 10px;&#125;</div><div class="line">span&#123;background-color: blue;width: 200px;height: 200px;&#125;</div><div class="line">strong&#123;background-color: green;width: 400px;height: 100px;&#125;</div><div class="line">&lt;/style&gt;</div><div class="line"></div><div class="line">&lt;p&gt;块级元素P&lt;/p&gt;&lt;div&gt;块级元素DIV&lt;/div&gt;&lt;span&gt;行内元素span&lt;/span&gt;&lt;strong&gt;行内元素strong&lt;/strong&gt;</div></pre></td></tr></table></figure></p>
<p>在浏览器中的效果如下图:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-559a5012de973dcf.png" alt="Paste_Image.png"></p>
<p>注意，块级元素即使设置了宽度，任然是独占一行的。</p>
<p>块级元素可以设置<code>margin</code>和<code>padding</code>属性。行内元素的<code>margin</code>、<code>padding</code>属性很奇怪，水平方向的<code>padding-left</code>、<code>padding-right</code>、<code>margin-left</code>、<code>margin-right</code>都产生边距效果，但 6方向的<code>padding-top</code>、<code>padding-bottom</code>、<code>margin-top</code>、<code>margin-bottom</code>却不会产生边距效果。如下代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;style type="text/css"&gt;</div><div class="line">p&#123;background-color: red;padding: 20px;margin: 20px;&#125;</div><div class="line">div&#123;background-color: yellow;padding: 20px;&#125;</div><div class="line">span&#123;background-color: blue;padding: 20px;margin: 20px;&#125;</div><div class="line">strong&#123;background-color: green;padding: 20px;margin: 20px;&#125;</div><div class="line">&lt;/style&gt;</div><div class="line"></div><div class="line">&lt;p&gt;块级元素P&lt;/p&gt;&lt;div&gt;块级元素DIV&lt;/div&gt;&lt;span&gt;行内元素span&lt;/span&gt;&lt;strong&gt;行内元素strong&lt;/strong&gt;</div></pre></td></tr></table></figure></p>
<p>在浏览器中的效果如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-1d071a966396c018.png" alt="Paste_Image.png"></p>
<p>如上图所示，竖直方向的<code>margin</code>看不到任何效果，竖直方向的<code>padding</code>虽然增加了，但却并没有和相邻的元素拉开距离。</p>
<p>块级元素和行内元素的CSS相关属性是<code>display</code>，其中块级元素对应于<code>display：block</code>，行内元素对应于<code>display：inline</code>。我们可以通过修改display属性来切换块级元素和行内元素，如下面代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;style type="text/css"&gt;</div><div class="line">p&#123;background-color: red;display: inline;&#125;</div><div class="line">div&#123;background-color: yellow;display: inline;&#125;</div><div class="line">span&#123;background-color: blue;display: block;&#125;</div><div class="line">strong&#123;background-color: green;display: block;&#125;</div><div class="line">&lt;/style&gt;</div><div class="line"></div><div class="line">&lt;p&gt;块级元素P&lt;/p&gt;&lt;div&gt;块级元素DIV&lt;/div&gt;&lt;span&gt;行内元素span&lt;/span&gt;&lt;strong&gt;行内元素strong&lt;/strong&gt;</div></pre></td></tr></table></figure></p>
<p>在浏览器中的效果如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-ec80ce3a0608ca5f.png" alt="Paste_Image.png"></p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS的低权重原则—避免滥用子选择器]]></title>
      <url>/2015/05/24/CSS%E7%9A%84%E4%BD%8E%E6%9D%83%E9%87%8D%E5%8E%9F%E5%88%99%E2%80%94%E9%81%BF%E5%85%8D%E6%BB%A5%E7%94%A8%E5%AD%90%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>CSS设置的样式是可以层叠的，如下面[代码1]</p>
<p>[代码1]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="css"></span></div><div class="line">	<span class="selector-tag">span</span>&#123;<span class="attribute">font-size</span>: <span class="number">40px</span>;&#125;</div><div class="line">	<span class="selector-class">.test</span>&#123;<span class="attribute">color</span>:red;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span>CSS的低权重原则<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>“CSS的低权重原则”既可以的到<code>font-size:40px</code>的样式，又可以得到<code>color： red</code>的样式。如果两个不同选择符设置的样式有冲突，又会如何？如下面[代码2]</p>
<p>[代码：CSS层叠有冲突的情况]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="css"></span></div><div class="line">	<span class="selector-tag">span</span>&#123;<span class="attribute">font-size</span>: <span class="number">40px</span>;<span class="attribute">color</span>:green&#125;</div><div class="line">	<span class="selector-class">.test</span>&#123;<span class="attribute">color</span>:red;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span>CSS的低权重原则<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>“CSS的低权重原则”颜色会是什么呢？是对<code>span</code>设置的<code>color:green</code>呢，还是第<code>.test</code>设置的<code>color:red</code>呢？这就涉及CSS选择符的权重问题了。</p>
<p>CSS的选择符是有权重的，当不同选择符的样式设置有冲突时，会采用权重高的选择符设置的样式。</p>
<p>权重的规则是这样的：HTML标签的权重是1，class的权重是10，id的权重是100，例如p的权重是1，“div em”的权重是1+1=2，“strong.demo”的权重是10+1=11，“#test.red”的权重是100+10=110.</p>
<p>[代码2]中，选择符span的权重是1，“.test”的权重是10，所以“CSS的低权重原则”的color应该是red。</p>
<p>但是如果是如下[代码3]时，又会如何呢？<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="css"></span></div><div class="line"><span class="selector-tag">span</span>&#123;<span class="attribute">font-size</span>: <span class="number">40px</span>;&#125;</div><div class="line"><span class="selector-class">.test</span>&#123;<span class="attribute">color</span>:red;&#125;</div><div class="line"><span class="selector-class">.test2</span>&#123;<span class="attribute">color</span>: green&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"test test2"</span>&gt;</span>CSS的低权重原则<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>span的标签同时挂了test和test2两个class，他们的权重都是10，那么“CSS的低权重原则”的color又该是哪个呢？<strong>如果 CSS选择符权重相同，那么样式就遵循就近原则，哪个选择符后定义，就采用哪个选择符的样式。</strong></p>
<p>[代码3]中test2后定义，所以color会采用<code>.test2</code>的设置为green。</p>
<p>如果改变<code>.test</code>和<code>.test2</code>定义的位置，如[代码4]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="css"></span></div><div class="line"><span class="selector-tag">span</span>&#123;<span class="attribute">font-size</span>: <span class="number">40px</span>;&#125;</div><div class="line"><span class="selector-class">.test2</span>&#123;<span class="attribute">color</span>: green&#125;</div><div class="line"><span class="selector-class">.test</span>&#123;<span class="attribute">color</span>:red;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"test test2"</span>&gt;</span>CSS的低权重原则<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>那么 “CSS的低权重原则”的color就为red了。</p>
<p>需要强调的是就近原则指的是选择符  的先后顺序，而不是挂class名的先后顺序，<code>&lt;span class=&quot;test test2&quot;&gt;CSS的低权重原则&lt;/span&gt;</code>和<code>&lt;span class=&quot;test2 test&quot;&gt;CSS的低权重原则&lt;/span&gt;</code>没有区别。</p>
<p>CSS选择符权重是个容易被忽略的问题。但事实上如果不太注意选择符的权重，常会出现意向不到的小麻烦。例如下面[代码5]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="css"></span></div><div class="line"><span class="selector-id">#test</span>&#123;<span class="attribute">font-size</span>: <span class="number">14px</span>;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span>CSS的选择符权重很重要<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>现在需要将“很重要”三个字设置为红色，我们应该怎么做呢？</p>
<p>方案一，利用子选择器，如[代码6]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="css"></span></div><div class="line"><span class="selector-id">#test</span>&#123;<span class="attribute">font-size</span>: <span class="number">14px</span>;&#125;</div><div class="line"><span class="selector-id">#test</span> <span class="selector-tag">span</span>&#123;<span class="attribute">color</span>: red&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span>CSS的选择符权重<span class="tag">&lt;<span class="name">span</span>&gt;</span>很重要<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>方案二，新建class，如[代码7]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="css"></span></div><div class="line"><span class="selector-id">#test</span>&#123;<span class="attribute">font-size</span>: <span class="number">14px</span>;&#125;</div><div class="line"><span class="selector-class">.font</span>&#123;<span class="attribute">color</span>: red&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span>CSS的选择符权重<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"font"</span>&gt;</span>很重要<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>很多工程师推荐使用方案一，因为使用子选择器可以避免新增class，让HTML代码更简洁，这么考虑是有道理的，但如果这时需求有变化，需要添加新的额文字进来，如[代码8]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="css"></span></div><div class="line"><span class="selector-id">#test</span>&#123;<span class="attribute">font-size</span>: <span class="number">14px</span>;&#125;</div><div class="line"><span class="selector-id">#test</span> <span class="selector-tag">span</span>&#123;<span class="attribute">color</span>: red&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span>CSS的选择符权重<span class="tag">&lt;<span class="name">span</span>&gt;</span>很重要<span class="tag">&lt;/<span class="name">span</span>&gt;</span>，我们要小心处理<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>要求我们将“小心处理”设置为绿色，我们可以这么做，如[代码9]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="css"></span></div><div class="line"><span class="selector-id">#test</span>&#123;<span class="attribute">font-size</span>: <span class="number">14px</span>;&#125;</div><div class="line"><span class="selector-id">#test</span> <span class="selector-tag">span</span>&#123;<span class="attribute">color</span>: red&#125;</div><div class="line"><span class="selector-class">.font</span>&#123;<span class="attribute">color</span>:green&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span>CSS的选择符权重<span class="tag">&lt;<span class="name">span</span>&gt;</span>很重要<span class="tag">&lt;/<span class="name">span</span>&gt;</span>，我们要<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"font"</span>&gt;</span>小心处理<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>本以为小心处理会被选择符font设置为绿色，但它却被选择符权重更高的“#test span”设置成了红色，子选择器在无意中影响到了我们新添加的代码。如果想要达到我们的预期，我们需要按代码[9]重写<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="css"></span></div><div class="line"><span class="selector-id">#test</span>&#123;<span class="attribute">font-size</span>: <span class="number">14px</span>;&#125;</div><div class="line"><span class="selector-id">#test</span> <span class="selector-tag">span</span>&#123;<span class="attribute">color</span>: red&#125;            <span class="comment">/* 选择符权重为100+1=101 */</span></div><div class="line"><span class="selector-id">#test</span> <span class="selector-class">.font</span>&#123;<span class="attribute">color</span>:green&#125;         <span class="comment">/* 选择符权重为100+10=110 */</span></div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span>CSS的选择符权重<span class="tag">&lt;<span class="name">span</span>&gt;</span>很重要<span class="tag">&lt;/<span class="name">span</span>&gt;</span>，我们要<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"font"</span>&gt;</span>小心处理<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>而如果使用方案二呢？<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="css"></span></div><div class="line"><span class="selector-id">#test</span>&#123;<span class="attribute">font-size</span>: <span class="number">14px</span>;&#125;</div><div class="line"><span class="selector-class">.test</span>&#123;<span class="attribute">color</span>: red&#125;            <span class="comment">/* 选择符权重为100+1=101 */</span></div><div class="line"><span class="selector-class">.font2</span>&#123;<span class="attribute">color</span>:green&#125;         <span class="comment">/* 选择符权重为100+10=110 */</span></div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span>CSS的选择符权重<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"font"</span>&gt;</span>很重要<span class="tag">&lt;/<span class="name">span</span>&gt;</span>，我们要<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"font2"</span>&gt;</span>小心处理<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>因为没有使用子选择器，所以我们添加新代码挂上新的class就可以顺利的完成样式的设置了。</p>
<p>使用子选择器，会增加CSS选择符的权重，CSS的选择符权重越高，样式越不易被覆盖，所以除非确定HTML结构非常稳定，一定不会再修改了，否则尽量使用子选择器。为了保证样式容易被覆盖，提高可维护性，CSS选择符权重尽可能低。</p>
<p>少用子选择器，就需要多添加class，在Web标准盛行的初期，很多工程师认为多添加class是不好的，如果能使用子选择器就应该尽量使用，使用大量的class的做法叫做“多class症”。在进过大量实践后，我并不认为多class有太大的坏处，相反，与使用子选择器相比，新添加class反而跟利于维护。</p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS的常见问题(一)]]></title>
      <url>/2015/05/24/CSS%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<h3 id="CSS的编码风格"><a href="#CSS的编码风格" class="headerlink" title="CSS的编码风格"></a>CSS的编码风格</h3><p>CSS的常见编码风格有两种，即一行式和多行式。</p>
<p>多行式如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.test</span>&#123;</div><div class="line">    <span class="attribute">width</span>:<span class="number">100px</span>;</div><div class="line">    <span class="attribute">height</span>:<span class="number">200px</span>;</div><div class="line">    <span class="attribute">color</span>:<span class="number">#ccc</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.demo</span>&#123;</div><div class="line">    </div><div class="line"><span class="attribute">background-color</span>:green;</div><div class="line">    <span class="attribute">font-size</span>:<span class="number">12px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一行式如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.test</span>&#123;<span class="attribute">width</span>:<span class="number">100px</span>;<span class="attribute">height</span>:<span class="number">200px</span>; <span class="attribute">color</span>:<span class="number">#ccc</span>;&#125;</div><div class="line"><span class="selector-class">.demo</span>&#123;<span class="attribute">background-color</span>:green;<span class="attribute">font-size</span>:<span class="number">12px</span>;&#125;</div></pre></td></tr></table></figure></p>
<p>多行式的编码风格可读性强，但缺点是容易使CSS文件的行数过多，编辑样式时，需要来回滚动编辑器，影响开发速度，另外，过多的空白，也会增大CSS的文件大小。一行式编码风格在可读性方面稍差，但可以有效减少CSS文件的行数，有利于提高开发速度，同时也可以减少CSS的 大小。</p>
<p>CSS布局刚兴起的时候，由于缺少强大的调试工具，很多时候样式的调试工作都需要仔细阅读CSS文件，所以良好的可读性起到了非常重要的作用。这一时期，多行编码风格是主流。随着前端调试工具的日益强大，特别是Firefox+firebug的流行，样式调试工作已经不再需要仔细阅读CSS文件了，一行式编码风格逐渐取代了多行式编码风格成了新的主流，现在推荐使用一行式编码风格。</p>
<h3 id="id和class"><a href="#id和class" class="headerlink" title="id和class"></a>id和class</h3><p>id和class作为CSS选择符最常用的挂钩，其区别已经成为了一个经典的问题。</p>
<ol>
<li>同一个网页，相同的id只能出现一次，他不可以重复有，而class可以任意出现多次；</li>
<li>id的CSS选择符权重为100，而<code>class</code>的CSS选择符权重为10；</li>
<li>原生JS提供<code>getElementById()</code>方法，支持通过id查找到相应的<code>HTMLElement</code>，但原生JS不支持通过<code>class</code>对应相关的HTMLElement。</li>
</ol>
<p>一般来说，id因为不能重复，使用id会限制网页的扩展性。比如，设计图中有某个模块只出现了一次，我们使用id作为挂钩，这本身是没有问题的。但如果需求变更，设计图中同样的模块需要再增加一个，这时问题就出现了，因为使用id作为挂钩，不能重用。所以，一般情况下，建议尽量使用class，少用id。</p>
]]></content>
      
        <categories>
            
            <category> 前端开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript中的继承入门]]></title>
      <url>/2015/05/18/JavaScript%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>正统的面相对象的语言都会提供extend之类的方法用于出来类的继承，但Javascript并不提供extend方法，在Javascript中使用继承需要用点技巧。<br><a id="more"></a><br>Javascript中的实例的属性和行为是由构造函数和原型两部分组成的，我们定义两个类：Person和zhangsan，它们在内存中的表现如下图1：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-9a7695ca97de0a85.png" alt="Person和zhangsan，它们在内存中的表现"></p>
<p>如果想让Zhangsan继承Person，那么我们需要把Person构造函数和原型中的属性和行为全部传给Zhangsan的构造函数和原型，如下图2所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-eb90342a9dfb167a.png" alt="Zhangsan的构造函数和原型"></p>
<p>Are you Ok？了解了继承的思路后，那么我们一步步完成Person和Zhangsan的继承功能。首先，我们需要定义Person类，如下代码：</p>
<p>[代码1]<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义Person类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.type = <span class="string">"人"</span>;</div><div class="line">&#125;</div><div class="line">Person.prototype=&#123;</div><div class="line">	<span class="attr">say</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.info(<span class="string">"我是一个"</span>+ <span class="keyword">this</span>.type +<span class="string">"，我的名字叫"</span> + <span class="keyword">this</span>.name);</div><div class="line">	&#125;</div><div class="line">&#125;	</div><div class="line"><span class="comment">//定义Zhangsan类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Zhangsan</span> (<span class="params">name</span>)</span>&#123;</div><div class="line">&#125;</div><div class="line">Zhangsan.prototype=&#123;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Zhangsan虽然有自己特有的属性和行为，但它大部分属性和行为和Person相同，需要继承自Person类。如前所述，JavaScript中继承是要分别继承构造函数和原型中的属性和行为的。我们先让Zhangsan继承Person的构造函数中的行为和属性，如下代码：</p>
<p>[代码2]<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义Person类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.type = <span class="string">"黄"</span>;</div><div class="line">&#125;</div><div class="line">Person.prototype=&#123;</div><div class="line">	<span class="attr">say</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.info(<span class="string">"我是一个"</span>+ <span class="keyword">this</span>.type +<span class="string">"种人，我的名字叫"</span> + <span class="keyword">this</span>.name);</div><div class="line">	&#125;</div><div class="line">&#125;	</div><div class="line"><span class="comment">//定义Zhangsan类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Zhangsan</span> (<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.type = <span class="string">"黄"</span>;</div><div class="line">&#125;</div><div class="line">Zhangsan.prototype=&#123;</div><div class="line">&#125;</div><div class="line"><span class="comment">//实例化Zhangsan对象</span></div><div class="line"><span class="keyword">var</span> zs = <span class="keyword">new</span> Zhangsan(<span class="string">"张三"</span>);</div><div class="line"><span class="built_in">console</span>.info(zs.type);    <span class="comment">// 黄</span></div></pre></td></tr></table></figure></p>
<p>运行正常，但我们怎么没看到继承的“味道”呢？我们在Zhangsan的构造函数中将Person的属性和行为复制了一份，与其说是继承不如说是“真巧，这两个类的构造函数除了函数名不同，其他地方都长得一样”。她的缺点很明显：如果Person类的构造函数有任何变动，我们也需要手动的同步修改Zhangsan类的构造函数，同样一份代码，我们复制了一份写在了程序中 的不同地方，这违法了DRY原则，降低了代码的可维护性。</p>
<p>好了，让我们来改进它：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义Person类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.type = <span class="string">"黄"</span>;</div><div class="line">&#125;</div><div class="line">Person.prototype=&#123;</div><div class="line">	<span class="attr">say</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.info(<span class="string">"我是一个"</span>+ <span class="keyword">this</span>.type +<span class="string">"种人，我的名字叫"</span> + <span class="keyword">this</span>.name);</div><div class="line">	&#125;</div><div class="line">&#125;	</div><div class="line"><span class="comment">// 定义Zhangsan类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Zhangsan</span> (<span class="params">name</span>)</span>&#123;</div><div class="line">	Person(name);</div><div class="line">&#125;</div><div class="line">Zhangsan.prototype=&#123;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 实例化Zhangsan对象</span></div><div class="line"><span class="keyword">var</span> zs = <span class="keyword">new</span> Zhangsan(<span class="string">"张三"</span>);</div><div class="line"><span class="built_in">console</span>.info(zs.type);        <span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<p>我们在Zhangsan的构造函数里调用Person()函数，希望它内部的<code>ths.xxx</code>可以在Zhangsan类的构造函数里执行一遍，但奇怪的是，出现<code>console.info(zs.type);</code>时，输出的是undefined，这是怎么回事呢？</p>
<p>这和Person的调用方式有关。在JavaScript中，function有两种不同的调用方法：</p>
<ol>
<li>作为函数存在，直接用<code>()</code>调用，例如<code>function test(){}; test();</code>test被用作函数，直接被<code>()</code>符号调用。</li>
<li>作为类的构造函数存在，使用new调用，例如<code>function test(){}; new test();</code>test作为类的构造函数，通过new进行test类的实例化。这两种方法的调用，function内部的this指向会有所不同—作为函数的function，其this指向的是window，而作为构造函数的function，其this指向的实例对象。</li>
</ol>
<p>上面代码中，Zhangsan类构造函数中的Person是通过函数方式调用的，它内部的this指向的是window对象，起效果等同于如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义Person类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.type = <span class="string">"黄"</span>;</div><div class="line">&#125;</div><div class="line">Person.prototype=&#123;</div><div class="line">	<span class="attr">say</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.info(<span class="string">"我是一个"</span>+ <span class="keyword">this</span>.type +<span class="string">"种人，我的名字叫"</span> + <span class="keyword">this</span>.name);</div><div class="line">	&#125;</div><div class="line">&#125;	</div><div class="line"><span class="comment">// 定义Zhangsan类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Zhangsan</span> (<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="built_in">window</span>.name = name;</div><div class="line">    <span class="built_in">window</span>.type = <span class="string">"黄"</span>;</div><div class="line">&#125;</div><div class="line">Zhangsan.prototype=&#123;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 实例化Zhangsan对象</span></div><div class="line"><span class="keyword">var</span> zs = <span class="keyword">new</span> Zhangsan(<span class="string">"张三"</span>);</div><div class="line"><span class="built_in">console</span>.info(zs.type);	<span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.info(type);		<span class="comment">// 黄 (window.type可以省略写成type)</span></div></pre></td></tr></table></figure></p>
<p>如果想达到[代码3]的效果，让Person内部this指向Zhangsan类的实例，可以通过call或apply方法实现，如下：<br>[代码5]<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义Person类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.type = <span class="string">"黄"</span>;</div><div class="line">&#125;</div><div class="line">Person.prototype=&#123;</div><div class="line">	<span class="attr">say</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.info(<span class="string">"我是一个"</span>+ <span class="keyword">this</span>.type +<span class="string">"种人，我的名字叫"</span> + <span class="keyword">this</span>.name);</div><div class="line">	&#125;</div><div class="line">&#125;	</div><div class="line"><span class="comment">// 定义Zhangsan类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Zhangsan</span> (<span class="params">name</span>)</span>&#123;</div><div class="line">	Person.call(<span class="keyword">this</span>,name);</div><div class="line">&#125;</div><div class="line">Zhangsan.prototype=&#123;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 实例化Zhangsan对象</span></div><div class="line"><span class="keyword">var</span> zs = <span class="keyword">new</span> Zhangsan(<span class="string">"张三"</span>);</div><div class="line"><span class="built_in">console</span>.info(zs.type);		<span class="comment">// 黄</span></div></pre></td></tr></table></figure></p>
<p>构造函数的属性和行为已经成功实现了继承，接下来我们要实现原型中的属性和行为的继承。既然Zhangsan类需要和Person类原型中同样的属性和行为，那么能否将Person类的原型直接传给Zhangsan类的原型，如下代码：</p>
<p>[代码6]<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义Person类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.type = <span class="string">"黄"</span>;</div><div class="line">&#125;</div><div class="line">Person.prototype=&#123;</div><div class="line">	<span class="attr">say</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.info(<span class="string">"我是一个"</span>+ <span class="keyword">this</span>.type +<span class="string">"种人，我的名字叫"</span> + <span class="keyword">this</span>.name);</div><div class="line">	&#125;</div><div class="line">&#125;	</div><div class="line"><span class="comment">// 定义Zhangsan类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Zhangsan</span> (<span class="params">name</span>)</span>&#123;</div><div class="line">	Person.call(<span class="keyword">this</span>,name);</div><div class="line">&#125;</div><div class="line">Zhangsan.prototype = Person.prototype;</div><div class="line"><span class="comment">// 实例化Zhangsan对象</span></div><div class="line"><span class="keyword">var</span> zs = <span class="keyword">new</span> Zhangsan(<span class="string">"张三"</span>);</div><div class="line"><span class="comment">// 我是一个黄种人，我的名字叫张三</span></div><div class="line">zs.say();</div></pre></td></tr></table></figure></p>
<p>通过Person类的原型传给Zhangsan类的原型，Zhangsan类成功获得了say行为，但事情并不像想象中的那么简单，如果我们要给Zhangsan类添加run行为呢？如下代码：</p>
<p>[代码7：添加run行为]<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义Person类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.type = <span class="string">"黄"</span>;</div><div class="line">&#125;</div><div class="line">Person.prototype=&#123;</div><div class="line">	<span class="attr">say</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.info(<span class="string">"我是一个"</span>+ <span class="keyword">this</span>.type +<span class="string">"种人，我的名字叫"</span> + <span class="keyword">this</span>.name);</div><div class="line">	&#125;</div><div class="line">&#125;	</div><div class="line"><span class="comment">// 定义Zhangsan类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Zhangsan</span> (<span class="params">name</span>)</span>&#123;</div><div class="line">	Person.call(<span class="keyword">this</span>,name);</div><div class="line">&#125;</div><div class="line">Zhangsan.prototype = Person.prototype;</div><div class="line">Zhangsan.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.info(<span class="string">"我100米短跑只要10秒！"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 实例化Zhangsan对象</span></div><div class="line"><span class="keyword">var</span> zs = <span class="keyword">new</span> Zhangsan(<span class="string">"张三"</span>);</div><div class="line">zs.say();   <span class="comment">// 我是一个黄种人，我的名字叫张三</span></div><div class="line">zs.run();   <span class="comment">//我100米短跑只要10秒！</span></div><div class="line"><span class="keyword">var</span> zs2 = <span class="keyword">new</span> Person(<span class="string">"张三2"</span>);</div><div class="line">zs2.run();	<span class="comment">//我100米短跑只要10秒！</span></div></pre></td></tr></table></figure></p>
<p>我们只想给Zhangsan类添加run行为，为什么Person类也获得了run行为了呢？这涉及传值和传址的两个问题—-在JavaScript中，赋值语句会用传值和传地址两种不同的方式进行赋值，如果是数值型、不尔型、字符型等基本数据类型，在进行赋值时会将数据直接赋值一份，将赋值的那一份数据进行赋值，也就是通常所说的传值；如果是数组、hash对象等复杂数据类型，在进行赋值时会直接用内存地址赋值，而不是将数据赋值一份，这就是传址赋值，就是传数据的映射地址。</p>
<p>[代码8：传值与传址]<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a=<span class="number">10</span>;		<span class="comment">// 基本数据类型</span></div><div class="line"><span class="keyword">var</span> b=a;		<span class="comment">// 将变量a保存的值赋值一份，传给变量b，b和a各保存一份数据</span></div><div class="line"><span class="keyword">var</span> c=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];	<span class="comment">// 复杂数据类型</span></div><div class="line"><span class="keyword">var</span> d=c;		<span class="comment">// 将变量c指向的数据内存地址传给变量d，c和d指向同一份数据</span></div><div class="line">b++;</div><div class="line">d.push(<span class="number">4</span>);</div><div class="line"><span class="built_in">console</span>.info(a);	<span class="comment">// 10</span></div><div class="line"><span class="built_in">console</span>.info(b);	<span class="comment">// 11		变量b保存的数据更改不会影响到变量a</span></div><div class="line"><span class="built_in">console</span>.info(c);	<span class="comment">// 1,2,3,4	变量c和d指向同一份数据，数据更改会相互影响</span></div><div class="line"><span class="built_in">console</span>.info(d);	<span class="comment">// 1,2,3,4</span></div></pre></td></tr></table></figure></p>
<p>在原生JavaScript中，选择传值还是传地址是根据数据类型来自动判断的，但传地址有时候会给我们带来意想不到的麻烦，所以我们需要对复杂数据类型的赋值进行控制，让复杂数据类型也可以进行传值。</p>
<p>最简单的做法是遍历数组或者Hash对象，将数组或者Hash对象这种复杂的数据拆分成一个个简单数据，然后分别赋值，如下面代码：</p>
<p>[代码9：对复杂数据类型进行传值]<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] ,b = &#123;<span class="attr">name</span>:<span class="string">'张三'</span>,<span class="attr">sex</span>:<span class="string">'男'</span>,<span class="attr">tel</span>:<span class="string">'1383838438'</span>&#125;;</div><div class="line"><span class="keyword">var</span> c = [] ,d = &#123;&#125;;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> p <span class="keyword">in</span> a)&#123;</div><div class="line">	c[p] = a[p]; </div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> p <span class="keyword">in</span> b)&#123;</div><div class="line">	d[p] = b[p];</div><div class="line">&#125;</div><div class="line">c.push(<span class="string">'4'</span>);</div><div class="line">d.email = <span class="string">'ibing@outlook.com'</span>;</div><div class="line"><span class="built_in">console</span>.info(a);			<span class="comment">// [1, 2, 3]</span></div><div class="line"><span class="built_in">console</span>.info(c);            <span class="comment">// [1, 2, 3, "4"]</span></div><div class="line"><span class="built_in">console</span>.info(b.email);		<span class="comment">// undefined</span></div><div class="line"><span class="built_in">console</span>.info(d.email);		<span class="comment">// ibing@outlook.com</span></div></pre></td></tr></table></figure></p>
<p>值得一提的是，对于数组的传值还可以使用数组类的slice或者concat方法实现，如下面代码：</p>
<p>[代码10：数组传值的简单方法]<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = a.slice(), c = a.concat();</div><div class="line">b.pop();</div><div class="line">c.push(<span class="number">4</span>);</div><div class="line"><span class="built_in">console</span>.info(a);		<span class="comment">// [1, 2, 3]</span></div><div class="line"><span class="built_in">console</span>.info(b);        <span class="comment">// [1, 2]</span></div><div class="line"><span class="built_in">console</span>.info(c);		<span class="comment">// [1, 2, 3, 4]</span></div></pre></td></tr></table></figure></p>
<p>prototype本质上也是一个hash对象，所以直接用它赋值时会进行传址，这也是为什么[代码7：添加润行为]中，zs2居然会run的原因。我们可以用for in来遍历prototype，从而实现prototype的传值。但因为prototype和function（用做类的function）的关系，我们还有另外一种方法实现prototype的传值—-<code>new SomeFunction()</code>，如下面代码：</p>
<p>[代码11]<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义Person类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.type = <span class="string">"黄"</span>;</div><div class="line">&#125;</div><div class="line">Person.prototype=&#123;</div><div class="line">	<span class="attr">say</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.info(<span class="string">"我是一个"</span>+ <span class="keyword">this</span>.type +<span class="string">"种人，我的名字叫"</span> + <span class="keyword">this</span>.name);</div><div class="line">	&#125;</div><div class="line">&#125;	</div><div class="line"><span class="comment">// 定义Zhangsan类</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Zhangsan</span> (<span class="params">name</span>)</span>&#123;</div><div class="line">	Person.call(<span class="keyword">this</span>,name);</div><div class="line">&#125;</div><div class="line">Zhangsan.prototype = <span class="keyword">new</span> Person();</div><div class="line">Zhangsan.prototype.constructor = Person;</div><div class="line">Zhangsan.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.info(<span class="string">"我100米短跑只要10秒！"</span>);</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="comment">// 实例化Zhangsan对象</span></div><div class="line"><span class="keyword">var</span> zs = <span class="keyword">new</span> Zhangsan(<span class="string">"张三"</span>);</div><div class="line">zs.say();   <span class="comment">// 我是一个黄种人，我的名字叫张三</span></div><div class="line">zs.run();   <span class="comment">// 我100米短跑只要10秒！</span></div><div class="line"><span class="keyword">var</span> zs2 = <span class="keyword">new</span> Person(<span class="string">"张三2"</span>);</div><div class="line">zs2.run();	<span class="comment">// TypeError: zs2.run is not a function</span></div></pre></td></tr></table></figure></p>
<p>您是否注意到上面这句<code>Zhangsan.prototype.constructor = Person;</code>，这是因为<code>Zhangsan.prototype = new Person();</code>时，<code>Zhangsan.prototype.constructor</code>指向了Person，我们需要将它纠正，重新指向Zhangsan。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[利用jQuery克隆对象实例]]></title>
      <url>/2014/12/15/%E5%88%A9%E7%94%A8jQuery%E5%85%8B%E9%9A%86%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B/</url>
      <content type="html"><![CDATA[<p>实现如下图所示的效果：</p>
<p><img src="http://img.imooc.com/56a62a0f0001028b05570369.png" alt="图片描述"></p>
<p>当点击右边元素的X时，向左边DIV添加一个，同时右边被设为<code>disabled</code>。当点击左边被加入的元素时，删除该元素，同时右边被<code>disabled</code>的元素恢复。利用jQuery的对象克隆，轻轻松松一行代码实现。</p>
<p>HTML：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div"</span> <span class="attr">id</span>=<span class="string">"leftDiv"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"leftUl"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div"</span> <span class="attr">id</span>=<span class="string">"rightDiv"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"rightUl"</span>&gt;</span></div><div class="line">		    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"item1"</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"item01"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"item01"</span>/&gt;</span>元素01<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>X<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"item2"</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"item02"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"item02"</span>/&gt;</span>元素02<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>X<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"item3"</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"item03"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"item03"</span>/&gt;</span>元素03<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>X<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"item4"</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"item04"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"item04"</span>/&gt;</span>元素04<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>X<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"item5"</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"item05"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"item05"</span>/&gt;</span>元素05<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>X<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"item6"</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"item006"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"item006"</span>/&gt;</span>元素06<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>X<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"item7"</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"item007"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"item007"</span>/&gt;</span>元素07<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>X<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"item8"</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"item008"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"item008"</span>/&gt;</span>元素08<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>X<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"item9"</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"item009"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"item009"</span>/&gt;</span>元素09<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>X<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"item10"</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"item010"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"item010"</span>/&gt;</span>元素10<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>X<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"item11"</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"item011"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"item011"</span>/&gt;</span>元素11<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>X<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"item12"</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"item012"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"item012"</span>/&gt;</span>元素12<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>X<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"item13"</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"item013"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"item013"</span>/&gt;</span>元素13<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>X<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"item14"</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"item014"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"item014"</span>/&gt;</span>元素14<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>X<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"item15"</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"item015"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"item015"</span>/&gt;</span>元素15<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>X<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"item15"</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"item015"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"item015"</span>/&gt;</span>元素16<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>X<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"item15"</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"item015"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"item015"</span>/&gt;</span>元素17<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>X<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"item15"</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"item015"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"item015"</span>/&gt;</span>元素18<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>X<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>先为他加上一些样式：</p>
<p>CSS：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.div</span>&#123;<span class="attribute">width</span>: <span class="number">200px</span>;<span class="attribute">height</span>: <span class="number">350px</span>;<span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#3385ff</span>;<span class="attribute">margin-right</span>: <span class="number">10px</span>;<span class="attribute">display</span>: block;<span class="attribute">float</span>: left;<span class="attribute">overflow</span>: auto;&#125;</div><div class="line"><span class="selector-class">.div</span> <span class="selector-tag">ul</span>&#123;<span class="attribute">margin</span>: <span class="number">2px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span>;<span class="attribute">padding</span>: <span class="number">0</span>;<span class="attribute">list-style-type</span>: none;&#125;</div><div class="line"><span class="selector-class">.div</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span>&#123;<span class="attribute">border</span>: <span class="number">1px</span> solid green;<span class="attribute">margin</span>: <span class="number">1px</span> <span class="number">2px</span>;<span class="attribute">padding</span>: <span class="number">2px</span>;<span class="attribute">border-left</span>: <span class="number">0</span>;<span class="attribute">border-right</span>: <span class="number">0</span>;<span class="attribute">border-top</span>: <span class="number">0</span>;&#125;</div><div class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">background-color</span>: <span class="number">#e6e6e6</span>;&#125;</div><div class="line"><span class="selector-tag">li</span> <span class="selector-tag">span</span>&#123;<span class="attribute">font-weight</span>: <span class="number">700</span>;<span class="attribute">margin-left</span>: <span class="number">10px</span>;<span class="attribute">background-color</span>: <span class="number">#abcdef</span>;<span class="attribute">padding</span>: <span class="number">0</span> <span class="number">8px</span>;<span class="attribute">height</span>: <span class="number">12px</span>;<span class="attribute">line-height</span>: <span class="number">12px</span>;&#125;</div><div class="line"><span class="selector-tag">li</span> <span class="selector-tag">span</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">cursor</span>: pointer;<span class="attribute">color</span>: red;&#125;</div><div class="line"><span class="selector-class">.disabled</span>&#123;<span class="attribute">background-color</span>: <span class="number">#e6e6e6</span>;&#125;</div></pre></td></tr></table></figure></p>
<p>JS的话，克咯对象的核心代码就下面这一行：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(obj).parent(<span class="string">"#id"</span>).clone(<span class="literal">true</span>).appendTo(<span class="string">"#id"</span>)</div></pre></td></tr></table></figure></p>
<p>下面我们来给右边的元素批量添加单击事件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="comment">/** 自动批量添加单击事件 */</span></div><div class="line">	$(<span class="string">"#rightUl"</span>).find(<span class="string">"span"</span>).attr(<span class="string">"onclick"</span>,<span class="string">"delRightLi(this)"</span>);</div><div class="line">        <span class="comment">//$("#leftUl").find("span").attr("onclick","delLeftLi(this)");</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>实现单击事件的delRightLi（this）方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> delRightLi = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> cloneObj = $(obj).parent(<span class="string">"li"</span>).clone(<span class="literal">true</span>);</div><div class="line">	$(cloneObj).find(<span class="string">"span"</span>).attr(<span class="string">"onclick"</span>,<span class="string">"delLeftLi(this)"</span>);</div><div class="line">	cloneObj.appendTo(<span class="string">"#leftUl"</span>);</div><div class="line">	$(obj).hide().parent(<span class="string">"li"</span>).addClass(<span class="string">"disabled"</span>);</div><div class="line">	<span class="comment">/** </span></div><div class="line">	 * ajax后台操作.....</div><div class="line">	 * </div><div class="line">	 */</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上就可以实现点击右边的元素克隆一个元素到左边的框中，并且为克隆的元素绑定了“delLeftLi（this）”单击事件方法。<br>关键是第2行的cloneObj变量，该变量是临时保存被克隆的对象，用以在这一步加上单击事件，不然克隆过去的话会把元对象的单击事件方法也克隆过去。</p>
<p>delLeftLi(this)方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> delLeftLi = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> id = $(obj).parent(<span class="string">"li"</span>).attr(<span class="string">"id"</span>);</div><div class="line">	$(obj).parent(<span class="string">"li"</span>).remove();</div><div class="line">	$(<span class="string">"#rightUl li#"</span>+id).removeClass(<span class="string">"disabled"</span>).find(<span class="string">"span"</span>).show();</div><div class="line">	<span class="comment">/** </span></div><div class="line">         * ajax后台操作.....</div><div class="line">	 * </div><div class="line">	 */</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>完毕，以上就是全部代码！</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Cookie和Session的区别与联系]]></title>
      <url>/2014/11/08/cookie-and-session-distinction-and-contact/</url>
      <content type="html"><![CDATA[<p>这些都是基础知识，不过有必要做深入了解。先简单介绍一下。</p>
<h2 id="二者的定义"><a href="#二者的定义" class="headerlink" title="二者的定义"></a>二者的定义</h2><p>当你在浏览网站的时候，WEB 服务器会先送一小小资料放在你的计算机上，Cookie 会帮你在网站上所打的文字或是一些选择，都纪录下来。当下次你再光临同一个网站，WEB 服务器会先看看有没有它上次留下的 Cookie 资料，有的话，就会依据 Cookie里的内容来判断使用者，送出特定的网页内容给你。 Cookie 的使用很普遍，许多有提供个人化服务的网站，都是利用 Cookie来辨认使用者，以方便送出使用者量身定做的内容，像是 Web 接口的免费 email 网站，都要用到 Cookie。</p>
<p><strong>具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。</strong>同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上它还有其他选择。</p>
<h2 id="cookie机制"><a href="#cookie机制" class="headerlink" title="cookie机制"></a>cookie机制</h2><p>正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript或者VBScript也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。</p>
<p>cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。<strong>会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。</strong>存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。</p>
<h2 id="session机制"><a href="#session机制" class="headerlink" title="session机制"></a>session机制</h2><p>session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。</p>
<p>经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。比如： </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">"testform"</span> <span class="attr">action</span>=<span class="string">"/xxx"</span>&gt;</span> </div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"jsessionid"</span> <span class="attr">value</span>=<span class="string">"ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764"</span>&gt;</span> </div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span> </div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
<p>实际上这种技术可以简单的用对action应用URL重写来代替。</p>
<h2 id="cookie-和session-的区别"><a href="#cookie-和session-的区别" class="headerlink" title="cookie 和session 的区别"></a>cookie 和session 的区别</h2><p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。<br>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。<br>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。<br>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。<br>5、所以个人建议：</p>
<ul>
<li><p>将登陆信息等重要信息存放为SESSION；</p>
</li>
<li><p>其他信息如果需要保留，可以放在COOKIE中。</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 备忘 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[漫谈AOP开发之开发Spring AOP程序]]></title>
      <url>/2014/10/29/Talking-about-the-development-of-AOP-development/</url>
      <content type="html"><![CDATA[<p>这是漫谈AOP系列的第三篇，前两篇请看</p>
<ol>
<li><a href="/2017/10/26/漫谈AOP开发之初探AOP及AspectJ的用法/">《漫谈AOP开发之初探AOP及AspectJ的用法》</a></li>
<li><a href="/2014/10/28/漫谈AOP开发之谈谈AOP那些学术概念/">《漫谈AOP开发之谈谈AOP那些学术概念 》</a></li>
</ol>
<p>我们在Eclipse中创建一个新的工程，导入UserService、BookService两个类，并配置Spring的Bean：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"us"</span> <span class="attr">class</span>=<span class="string">"com.mybry.aop.service.UserService"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bs"</span> <span class="attr">class</span>=<span class="string">"com.mybry.aop.service.BookService"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>写一个增强处理类（Advice）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.mybry.aop.aspect;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthAspect</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">auth</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"====执行权限检查的方法===="</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在前面的文章我们说过了，Spring AOP框架是在运行阶段动态生成AOP代理（在内存中动态地生成AOP代理类），以实现对目标对象的增强。它不需要特殊的编译器。所以不需要想<code>AspectJ</code>一样需要使用<code>aspect</code>声明类，这里直接用<code>class</code>即可。</p>
<p>接下来我们就在Spring中配置这个类：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"authAspect"</span> <span class="attr">class</span>=<span class="string">"com.mybry.aop.aspect.AuthAspect"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>但此时Spring并知道这个类要作为Aspect使用的，这样依然只是一个普通的bean。还不知道要当肉来使用。这时候我们需要到如一个的明白空间AOP：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></div><div class="line">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">    http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</div><div class="line">    http://www.springframework.org/schema/aop</div><div class="line">    http://www.springframework.org/schema/aop/spring-aop-3.2.xsd" &gt;</div></pre></td></tr></table></figure></p>
<p>所有有关AOP的配置，都放在aop:config元素中：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 将authAspect转换为Aspect </span></div><div class="line">	指定在执行com.mybry.aop.service包下任意类、返回值不限的任意方法之前，织入auth方法。</div><div class="line">    --&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"authAspect"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"auth"</span> <span class="attr">pointcut</span>=<span class="string">"execution(* com.mybry.aop.service.*.*(..))"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>AOP配置图：<br><img src="http://img2.ph.126.net/tXjLIgdljiKUdMZAkqwBug==/36591746989229366.png" alt=""></p>
<p>注意，我们需要增加如下几个包：aopalliance、AspectJ、cglib。<br>运行上面的程序结果：<br><img src="http://img0.ph.126.net/CyG6prkEKjVoSAGFph2S3Q==/1053560837844825609.png" alt=""></p>
<p><strong>1、Spring支持的Advice</strong><br>对于Advice而言，Spring一共支持5种Advice：</p>
<ul>
<li>Before： 在方法执行之前。</li>
<li>AfterReturning： 只有成功返回后，才会织入该Advice</li>
<li>AfterThrowing： 只有抛出异常后，才会织入该Advice</li>
<li>After： 不管是抛出异常后，还是成功返回，都会织入该Advice</li>
<li>Around： 在目标方法执行之前、之后，都织入该Advice。</li>
</ul>
<p><strong>2、AOP编程步骤总结</strong><br>(1) 写普通类，将打算作为Aspect用，并将该类配置在Spring容器中。<br>(2) 用aop:aspect将普通Bean，转换为Aspect, 需要指定ref属性，该属性指定将哪个Bean转换为Aspect。<br>(3) 在aop:aspect元素中配置：</p>
<ul>
<li>aop:before.</li>
<li>aop:after-returning. 额外可指定returning，用于访问目标方法的返回值。该属性指定的参数值，还可用于对目标方法的返回值类型进行限制。如果不想对目标方法返回值类型进行限制，只要声明该参数类型为Object即可。</li>
<li>aop:after-throwing. 额外可指定throwing，用于访问目标方法的抛出的异常。该属性指定的参数值，还可用于对目标方法的抛出的异常类型进行限制。如果不想对目标方法抛出的异常类型类型进行限制，只要声明该参数类型为Exception即可</li>
<li>aop:after  功能有点类似finally块，通常用于回收资源。</li>
<li>aop:around, Advice方法，建议声明返回值，而且必须带一个ProceedingJoinPoint（AspectJ的API）类型的形参。</li>
</ul>
<p>这5个元素，都可指定如下2个属性：</p>
<ul>
<li>method：指定把哪个方法转为Advice。</li>
<li>pointcut|pointcut-ref：指定将Advice放到那些组件的哪些目标方法处。    </li>
</ul>
<p><strong>3、Spring 的Advice的对比</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">动作</th>
<th>Befor</th>
<th>AfterReturning</th>
<th>AfterThrowing</th>
<th>After</th>
<th>Around</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">阻止方法执行</td>
<td>行（抛异常）</td>
<td>不行</td>
<td>不行</td>
<td>不行</td>
<td>行</td>
</tr>
<tr>
<td style="text-align:left">访问调用参数</td>
<td>行</td>
<td>行</td>
<td>行</td>
<td>行</td>
<td>行</td>
</tr>
<tr>
<td style="text-align:left">修改调用参数</td>
<td>不行</td>
<td>不行</td>
<td>不行</td>
<td>不行</td>
<td>行</td>
</tr>
<tr>
<td style="text-align:left">访问返回值</td>
<td>不行</td>
<td>行</td>
<td>不行</td>
<td>不行</td>
<td>行</td>
</tr>
<tr>
<td style="text-align:left">修改返回值</td>
<td>不行</td>
<td>不行</td>
<td>不行</td>
<td>不行</td>
<td>行</td>
</tr>
</tbody>
</table>
<p><strong>4、访问调用参数</strong></p>
<p>借助于Pointcut形参：只要为Advice方法增加一个JoinPoint形参，即可通过该形参来访 目标的参数。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- args切入点表达式，用于限制目标方法必须有N个参数  --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"auth"</span> <span class="attr">pointcut</span>=<span class="string">"execution(* com.mybry.aop.service.*.*(..)) and args(arg0, arg1) "</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthAspect</span></span>&#123;</div><div class="line">    <span class="comment">// 一旦在切入点表达式中使用args切入点表达式，即可在Advice方法中通过arg0、arg1来访问目标方法的调用参数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">auth</span><span class="params">(String arg0 , Object arg1)</span></span>&#123;</div><div class="line">	System.out.println(<span class="string">"模拟进行权限检查"</span>);</div><div class="line">	System.out.println(<span class="string">"第1个参数为："</span> + arg0);</div><div class="line">	System.out.println(<span class="string">"第2个参数为："</span> + arg1);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>5、切入点表达式的写法简单介绍</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">execution([访问权限] [返回值类型] 包.类.方法(形参) [throws 异常]);</div></pre></td></tr></table></figure></p>
<p>默认情况下，都可用<code>*</code>作为通配符。</p>
<p>形参列表支持2个通配符， <code>..</code>代表任意个任意类型的参数； <code>*</code> 代表一个任意的参数。<br><code>(*, java.lang.String)</code> 2个形参，且第二个形参必须是String<br><code>(.., java.lang.String)</code> 1~N个形参，最后一个形参必须是String</p>
<ul>
<li>target(类型） ——要求目标对象指定类型。</li>
<li>this(类型） ——要求AOP代理对象指定类型。</li>
<li>args(a,b) —— 要求目标方法必须有匹配的形参。</li>
<li>bean(beanid) —— 专门为用Spring的菜鸟准备的。 只为特定Bean的方法织入增强处理。<strong>原生AspectJ并不支持，只有用Spring才支持。</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"bean(us)"</span> <span class="attr">id</span>=<span class="string">"fkPc"</span>/&gt;</span></div><div class="line">	<span class="comment">&lt;!-- 将authAspect转换为Aspect </span></div><div class="line">	指定在执行org.fkjava.aop.service包下任意类、返回值不限的任意方法之前，织入auth方法。</div><div class="line">	--&gt;</div><div class="line">	<span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"authAspect"</span>&gt;</span></div><div class="line">	     <span class="comment">&lt;!-- args切入点表达式，用于限制目标方法必须有N个参数  --&gt;</span></div><div class="line">	     <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"auth"</span> <span class="attr">pointcut-ref</span>=<span class="string">"fkPc"</span>/&gt;</span>	        </div><div class="line">	<span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[漫谈AOP开发之谈谈AOP那些学术概念]]></title>
      <url>/2014/10/28/%E6%BC%AB%E8%B0%88AOP%E5%BC%80%E5%8F%91%E4%B9%8B%E8%B0%88%E8%B0%88AOP%E9%82%A3%E4%BA%9B%E5%AD%A6%E6%9C%AF%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<h2 id="我所知道的AOP"><a href="#我所知道的AOP" class="headerlink" title="我所知道的AOP"></a>我所知道的AOP</h2><p>初看起来，上来就是一大堆的术语，而且还有个拉风的名字，面向切面编程，都说是OOP的一种有益补充等等。一下让你不知所措，心想着：管不得很多人都和我说AOP多难多难。当我看进去以后，我才行发现：他就是一些Java基础上的朴实无华的应用，包括IOC（见《Spring IOC(依赖注入、控制反转)概念理解》），包括许许多多这样的名词，都是万变不离其宗而已。</p>
<h2 id="为什么要用AOP"><a href="#为什么要用AOP" class="headerlink" title="为什么要用AOP"></a>为什么要用AOP</h2><p>1）就是为了方便，看一个国外很有名的大师说，编程的人都是“懒人”，因为他把自己做的事情都让程序去做了。用了AOP能让你少写很多代码，这点就够充分了吧。</p>
<p>2）就是为了更清晰的逻辑，可以让你的业务逻辑去关注自己本身的业务，而不去想一些其他的事情。这些其他的事情包括：安全，事物，日志等等。</p>
<h2 id="那些AOP术语"><a href="#那些AOP术语" class="headerlink" title="那些AOP术语"></a>那些AOP术语</h2><p>初看这么多术语，一下子都不好接受，慢慢来，很快就会搞懂。</p>
<p><strong>通知、增强处理（Advice）</strong><br>就是你想要的功能，也就是上说的安全、事物、日子等。你给先定义好，然后再想用的地方用一下。包含Aspect的一段处理代码</p>
<p><strong>连接点（JoinPoint）</strong><br>这个就更好解释了，就是spring允许你是通知（Advice）的地方，那可就真多了，基本每个方法的钱、后（两者都有也行），或抛出异常是时都可以是连接点，spring只支持方法连接点。其他如AspectJ还可以让你在构造器或属性注入时都行，不过那不是咱们关注的，只要记住，和方法有关的前前后后都是连接点。</p>
<p><strong>切入点（Pointcut）</strong><br>上面说的连接点的基础上，来定义切入点，你的一个类里，有15个方法，那就有十几个连接点了对吧，但是你并不想在所有方法附件都使用通知（使用叫织入，下面再说），你只是想让其中几个，在调用这几个方法之前、之后或者抛出异常时干点什么，那么就用切入点来定义这几个方法，让切点来筛选连接点，选中那几个你想要的方法。</p>
<p><strong>切面（Aspect）</strong><br>切面是通知和切入点的结合。现在发现了吧，没连接点什么事，链接点就是为了让你好理解切点搞出来的，明白这个概念就行了。通知说明了干什么和什么时候干（什么时候通过方法名中的befor，after，around等就能知道），二切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。</p>
<p><strong>引入（introduction）</strong><br>允许我们向现有的类添加新方法属性。这不就是把切面（也就是新方法属性：通知定义的）用到目标类中吗</p>
<p><strong>目标（target）</strong><br>引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咋们织入切面。二自己专注于业务本身的逻辑。</p>
<p><strong>代理（proxy）</strong><br>怎么实现整套AOP机制的，都是通过代理，这个一会儿给细说。</p>
<p><strong>织入（weaving）</strong><br>把切面应用到目标对象来创建新的代理对象的过程。有三种方式，spring采用的是运行时，为什么是运行时，在上一文《Spring AOP开发漫谈之初探AOP及AspectJ的用法》中第二个标提到。</p>
<p><strong>目标对象</strong><br>项目原始的Java组件</p>
<p><strong>AOP代理</strong><br>由AOP框架生成java对象</p>
<p><strong>AOP代理方法</strong><br>= advice +　目标对象的方法</p>
<p>下面的图简化和形象的说明了AOP<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1492281710048&amp;di=c3ae0c2e27d10bc786894a19f061f3c5&amp;imgtype=jpg&amp;src=http%3A%2F%2Fimg0.imgtn.bdimg.com%2Fit%2Fu%3D1907845334%2C1997022002%26fm%3D214%26gp%3D0.jpg" alt=""></p>
<h2 id="我所理解的AOP原理"><a href="#我所理解的AOP原理" class="headerlink" title="我所理解的AOP原理"></a>我所理解的AOP原理</h2><p>spring用代理类包裹切面，吧他们织入到Spring管理的bean中，也就是说代理类伪装成目标类，它会截取对目标类中方法的调用，然调用者对目标类的调用都先变成伪装类，伪装类这就先执行了切面，再把调用转发给真正的目标bean。</p>
<p>现在可以自己想一想，怎么搞出来这个伪装类，才不会被调用者发现（过JVM的检查，JAVA是强类型检查，哪里都要检查类型）。</p>
<p><strong>实现和目标类相同的接口</strong></p>
<p>我也实现和你一样的接口，反正上层都是接口级别的调用，这样我就伪装成了和目标类一样的类（实现了同意接口，咱是兄弟了），也就逃过了类型检查，到java运行期的时候，利用多态的后期绑定（所以spring采用运行时），伪装类（代理类）就变成了接口的真正实现，二他里面包裹了真实的那个目标类，最后实现具体功能的还是目标类，只是不过伪装在之前干了点事情（写日志，安全检查，事物等）。</p>
<p>这就好比一个人让你办事，每次这个时候，你弟弟就会出来，当然他分不出来了，以为是你，你这个弟弟虽然办不了这个事，但是她知道你能办，所以就答应下来了，并且收了点礼物（写日志），收完礼物了，给把事给人家办了啊，所以你弟弟又找你这个哥哥来了，最后把这事办了还是你自己。但是你自己并不知道你弟弟已经收了礼物了，你只是专心把这件事做好。</p>
<p>顺着这个思想，要是本身这个类就没实现一个接口呢，你怎么伪装我，我就压给没有机会让你搞出这个双胞胎弟弟，那么就用第2种代理方式，创建一个目标类的子类，生个儿子，让儿子伪装我。</p>
<p><strong>生成子类调用</strong></p>
<p>这次用子类来做伪装，当然这样也能逃过JVM的强类型检查，我继承的吗，当然查不出来了，子类重写了目标类的所有方法，当然在这些重写的方法中，不仅实现了目标类的功能，还在这些功能之前，实现了一些其他的（写日志，安全检查，事物等）。</p>
<p>这次的对比就是，儿子先从爸爸那儿把本事都学会了，所有人都找儿子办事，但是儿子每次办和爸爸同样的事之前，都要收点小礼物（写日志），然后才去办真正的事。当然爸爸是不知道儿子这么干的了。这里就有事情要说，某些本事是爸爸独有（final的），儿子学不会，学不了就办不了这个事，办不了这个事情，自然就不能收人家的礼物了。</p>
<p>前一种兄弟模式，spring会使用JDK的java.lang.reflect.Proxy类，它允许Spring动态生成一个新类来实现必要的接口，织入通知，并且把这些接口的任何调用都转发到目标类。</p>
<p>后一种父子模式，spring使用CGLIB库生成目标类的一个子类，在创建这个子类的时候，spring织入通知，并且把对这个子类的调用委托到目标类。</p>
<p>相比之下，还是兄弟模式好一些，她能更好的实现松耦合，尤其在今天都高喊着面向接口编程的情况下，父子模式只是在没有实现接口的时候，也能织入通知，应该当做一种例外。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[漫谈AOP开发之初探AOP及AspectJ的用法]]></title>
      <url>/2014/10/26/%E6%BC%AB%E8%B0%88AOP%E5%BC%80%E5%8F%91%E4%B9%8B%E5%88%9D%E6%8E%A2AOP%E5%8F%8AAspectJ%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="一、为什么需要AOP技术"><a href="#一、为什么需要AOP技术" class="headerlink" title="一、为什么需要AOP技术"></a>一、为什么需要AOP技术</h2><p>AOP 是一个很成熟的技术。</p>
<p>假如项目中有方法A、方法B、方法C……等多个方法，</p>
<p>如果项目需要为方法A、方法B、方法C……这批方法增加具有通用性质的横切处理。</p>
<p>下图可以形象的说明具有通用性质的横切处理的思想：</p>
<p><img src="file:///var/folders/xc/nyykbxjj4w938ntjcjymx0rm0000gn/T/WizNote/d46a5cab-2910-4fed-abf3-94bf91c31a10/index_files/wpsD3C5.tmp3cfdfc77-43e2-4d1c-ac14-ffbf40c41c12.png" alt=""></p>
<p><strong>在以前传统的做法是</strong></p>
<ol>
<li>先定义一个Advice方法，该方法实现这个通用性质的横切处理。</li>
<li>打开方法A、方法B、方法C……的源代码修改，使得方法A、方法B、方法C……去调用Advice方法。</li>
</ol>
<p>客户电话： 为每个方法都增加日志。<br>客户电话： 为每个方法前都增加权限控制。<br>客户电话： 为每个方法都加……<br>….  </p>
<p>如果使用AOP，可以做到程序员无需修改方法A、方法B、方法C……，但又可以为方法A、方法B、方法C增加调用Advice方法。</p>
<p><strong>面向切面编程（AOP）是作为面向对象编程（OOP）的补充</strong><br>AOP框架具有如下两个特征：</p>
<ol>
<li>各步骤之间的良好隔离性。</li>
<li>源代码无关性。</li>
</ol>
<h2 id="二、AOP的功能"><a href="#二、AOP的功能" class="headerlink" title="二、AOP的功能"></a>二、AOP的功能</h2><p>保证程序员不修改方法A、方法B、方法C……的前提下，可以为方法A、方法B、方法C……增加通用处理。</p>
<p>AOP的本质：依然要去【修改】方法A、方法B、方法C……</p>
<p>—— 只是这个修改由AOP框架完成，程序员不需要改。</p>
<p>AOP要求去修改，到底怎么去修改方法A、方法B、方法……</p>
<p><strong>AOP的实现方式有两种</strong></p>
<p>AOP框架在编译阶段，就对目标类进行修改，得到的class文件已经是被修改过的。生成静态的AOP代理类（生成*.class文件已经被改掉了，需要使用特定的编译器）。以AspectJ为代表 —— 静态AOP框架。</p>
<p>AOP框架在运行阶段，动态生成AOP代理（在内存中动态地生成AOP代理类），以实现对目标对象的增强。它不需要特殊的编译器。以Spring AOP为代表。—— 动态AOP框架。</p>
<p>上面两种，哪种性能更好？很明显静态的AOP框架更好。</p>
<p>下面我们进入AspectJ的学习</p>
<h2 id="三、实战AspectJ"><a href="#三、实战AspectJ" class="headerlink" title="三、实战AspectJ"></a>三、实战AspectJ</h2><p>AspectJ是一个基于Java语言的AOP框架，提供了强大的AOP功能，其他很多AOP框架都借鉴或采纳其中的一些思想。</p>
<p><strong>下载和安装AspectJ</strong></p>
<ol>
<li>运行、下载得到的安装JAR包。在命令行窗口启动下载得到的jar文件：java -jar aspectj-1.6.10.jar，在弹出的安装界面会先让你选择Java，选择你安装的Java目录 即可。将该软件(绝对绿色）安装到指定目录下（笔者安装在C盘）。</li>
<li>系统还应该将<code>C:\Java\aspectj1.6\bin</code>路径添加到PATH环境变量中，将C:\Java\aspectj1.6\lib\aspectjrt.jar和aspectjtools.jar添加到 CLASSPATH环境变量中。</li>
</ol>
<p>成功安装了AspectJ之后，将会在<code>E:\Java\AOP\aspectj1.6</code>路径下（AspectJ的安装路径）看到如下文件结构：</p>
<ul>
<li>bin：该路径下存放了aj、aj5、ajc、ajdoc、ajbrowser等命令，其中ajc命令最常用，它的作用类似于javac，用于对普通Java类进行编译时增强。</li>
<li>docs：该路径下存放了AspectJ的使用说明、参考手册、API文档等文档。</li>
<li>lib：该路径下的4个JAR文件是AspectJ的核心类库。</li>
<li>相关授权文件。</li>
</ul>
<p>打开DOS窗口，输入ajc命令，可以看到输出ajc命令的所有信息，即可知安装和环境变量配置成功：</p>
<p><img src="file:///var/folders/xc/nyykbxjj4w938ntjcjymx0rm0000gn/T/WizNote/d46a5cab-2910-4fed-abf3-94bf91c31a10/index_files/fd543e0f-a031-46d6-8db3-525fa893f15f.png" alt=""></p>
<p><strong>使用AspectJ</strong></p>
<p>接下来我们模拟一个普通程序：<br>UserService：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.mybry.aop.service;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addUser</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"模拟添加用户的方法。"</span>);</div><div class="line">		<span class="keyword">return</span> <span class="number">20</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validateLogin</span><span class="params">()</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"验证用户登录。"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>BookServce：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.mybry.aop.service;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addBook</span><span class="params">(String name,<span class="keyword">int</span> price)</span></span>&#123;</div><div class="line">		System.out.println(<span class="string">"正在添加图书，书名是："</span>+name+<span class="string">",价格是："</span>+price);</div><div class="line">		<span class="keyword">return</span> <span class="number">100</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译运行结果：</p>
<p><img src="file:///var/folders/xc/nyykbxjj4w938ntjcjymx0rm0000gn/T/WizNote/d46a5cab-2910-4fed-abf3-94bf91c31a10/index_files/wps784F.tmp27792296-746a-45d1-aa46-4813d419e942.png" alt=""></p>
<p>这两个类正好相当于我们的方法A，方法B…..</p>
<p>假如客户现在要求在每个方法前面增加权限检查功能，那么该如何做呢？下面我们就是用AspectJ来实现这个功能。</p>
<p>现在我们在这个模拟程序基础上增加这个AOP功能</p>
<p>我们先写一个权限检查的Aspectj类:</p>
<p>实例1，AuthAspect：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.mybry.aop.aspectj;</div><div class="line"><span class="keyword">public</span> aspect AuthAspect&#123;</div><div class="line">	<span class="comment">// Advice</span></div><div class="line">	<span class="comment">// execution(* com.mybry.aop.service.*.*(..)执行 任意返回值 改包下的任意类的任意方法形参不限</span></div><div class="line">	before():execution(* com.mybry.aop.service.*.*(..))&#123;</div><div class="line">		<span class="comment">// 对原来方法进行修改、增强。</span></div><div class="line">		System.out.println(<span class="string">"----------模拟执行权限检查----------"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意这个类色声明类型：aspect，没错，这是写Aspect必须声明的类型，只有AspectJ编译器可以识别。<br>再用<code>ajc –d *.java</code>命令编译执行：</p>
<p><img src="file:///var/folders/xc/nyykbxjj4w938ntjcjymx0rm0000gn/T/WizNote/d46a5cab-2910-4fed-abf3-94bf91c31a10/index_files/wps4E5.tmp27877a68-a55f-4960-982c-588848d8ac56.png" alt=""></p>
<p>太开心了，搞定了！</p>
<p>假如此时客户又要求在每个方法中增加事物处理呢？也好办，下面是事物处理类：<br>实例1，TxAspect：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.mybry.aop.aspectj;</div><div class="line"><span class="keyword">public</span> aspect TxAspect&#123;</div><div class="line">    <span class="comment">//around的意思就是在方法的前面和后面都加</span></div><div class="line">	<span class="function">Object <span class="title">around</span><span class="params">()</span>:<span class="title">execution</span><span class="params">(* com.mybry.aop.service.*.*(..)</span>)</span>&#123;</div><div class="line">		<span class="comment">// 对原来方法进行修改、增强。</span></div><div class="line">		System.out.println(<span class="string">"====模拟开启事务===="</span>);</div><div class="line">		Object rvtVal = proceed();</div><div class="line">		System.out.println(<span class="string">"====模拟结束事务===="</span>);</div><div class="line">		<span class="keyword">return</span> rvtVal;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好了，我们再来编译运行它：</p>
<p><img src="file:///var/folders/xc/nyykbxjj4w938ntjcjymx0rm0000gn/T/WizNote/d46a5cab-2910-4fed-abf3-94bf91c31a10/index_files/wps4B96.tmp1d5122e1-9afe-4446-9cbe-76464a2ee9f1.png" alt=""></p>
<p>OK!我们的Aspect AOP程序到此为止！</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript事件探秘]]></title>
      <url>/2014/09/06/javascript-event/</url>
      <content type="html"><![CDATA[<h2 id="一、事件流"><a href="#一、事件流" class="headerlink" title="一、事件流"></a>一、事件流</h2><p>事件流描述的是从页面中接收事件的顺序。IE的事件流是事件冒泡流，而Netscape的事件流是事件捕获流</p>
<h3 id="1、事件冒泡"><a href="#1、事件冒泡" class="headerlink" title="1、事件冒泡"></a>1、事件冒泡</h3><p>事件冒泡，即事件最开始由最具体的元素(文档中嵌套层次最深的那个节点)接收，然后逐级向上传播至最不具体的节点(文档)。</p>
<p>如下图所示，如果你点击了按钮，那么也认为你点击了外面的div，最终会一直传递到document上，从小到大的传播，就好比水里鱼的冒泡，从小泡泡大道泡泡的过程。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-ad288388904dac46.png" alt="Paste_Image.png"></p>
<h3 id="2、事件捕获"><a href="#2、事件捕获" class="headerlink" title="2、事件捕获"></a>2、事件捕获</h3><p>事件捕获跟事件冒泡恰好相反。它的思想是不太具体的节点应该更早接收到事件，而最具体的节点最后接收到事件。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-320530fe2540a3e9.png" alt="Paste_Image.png"></p>
<h3 id="3、事件的三个阶段"><a href="#3、事件的三个阶段" class="headerlink" title="3、事件的三个阶段"></a>3、事件的三个阶段</h3><p>事件的三个阶段分别是：捕获阶段、目标阶段、冒泡阶段</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-b94c4415d8c290f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="事件的三个阶段"></p>
<h2 id="二、事件处理程序"><a href="#二、事件处理程序" class="headerlink" title="二、事件处理程序"></a>二、事件处理程序</h2><h3 id="1、HTML事件处理程序"><a href="#1、HTML事件处理程序" class="headerlink" title="1、HTML事件处理程序"></a>1、HTML事件处理程序</h3><p>所谓的HTML事件是指把JS直接写在HTML元素中，比如下面的代码：<br>[程序1]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>事件流<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮1"</span> <span class="attr">id</span>=<span class="string">"btn1"</span> <span class="attr">onclick</span>=<span class="string">"alert('hello')"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>或者<br>[程序2]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>事件流<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮1"</span> <span class="attr">id</span>=<span class="string">"btn1"</span> <span class="attr">onclick</span>=<span class="string">"showMsg()"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		alert(<span class="string">"hello"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>那么HTML事件处理程序有一种很明显的缺点：HTML与JS代码紧密的耦合在一起，这不是这一种好的程序设计。</p>
<h3 id="2、DOM0级事件处理程序"><a href="#2、DOM0级事件处理程序" class="headerlink" title="2、DOM0级事件处理程序"></a>2、DOM0级事件处理程序</h3><p>DOM0级别事件处理程序是一种比较传统的，是指把一个行数赋值给一个事件处理程序的属性，也是用的比较多的方式。<br>他的优点是：简单，而且具有夸浏览器的优势。</p>
<p>[程序3]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮2"</span> <span class="attr">id</span>=<span class="string">"btn2"</span>&gt;</span></div><div class="line">var btn2 = document.getElementById("btn2");</div><div class="line">btn2.onclick = function()&#123;</div><div class="line">     alert("这是通过DOM0级添加的事件！");</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果要需要这个事件，可以这样写：<br>[程序4]<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">btn2.onclick = <span class="literal">null</span>;</div></pre></td></tr></table></figure></p>
<p>以上就是DOM0级事件处理方法。</p>
<h3 id="3、DOM2级事件处理程序"><a href="#3、DOM2级事件处理程序" class="headerlink" title="3、DOM2级事件处理程序"></a>3、DOM2级事件处理程序</h3><p>DOM2级事件定义了两个方法：用于处理指定和删除事件处理程序的操作：addEventListener()和removeEventListener()。它们都接收三个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。</p>
<p>他的有点与DOM0级一样，还可以添加多个事件处理程序。<br>[程序5]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮1"</span> <span class="attr">id</span>=<span class="string">"btn1"</span> <span class="attr">onclick</span>=<span class="string">"showMsg()"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮2"</span> <span class="attr">id</span>=<span class="string">"btn2"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"按钮3"</span> <span class="attr">id</span>=<span class="string">"btn3"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="string">"hello"</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> btn2 = <span class="built_in">document</span>.getElementById(<span class="string">"btn2"</span>);</div><div class="line"><span class="keyword">var</span> btn3 = <span class="built_in">document</span>.getElementById(<span class="string">"btn3"</span>);</div><div class="line">btn2.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="string">"这是通过DOM0级添加的事件！"</span>);</div><div class="line">&#125;</div><div class="line">btn2.onclick = <span class="literal">null</span>;</div><div class="line"><span class="comment">//DOM2级事件</span></div><div class="line">btn3.addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="comment">//获取按钮的文本</span></div><div class="line">	alert(<span class="keyword">this</span>.value);</div><div class="line">&#125;,<span class="literal">false</span>);</div><div class="line"><span class="comment">//删除事件</span></div><div class="line">btn3.removeEventListener(<span class="string">"click"</span>,showMsg,<span class="literal">false</span>);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">`</div></pre></td></tr></table></figure></p>
<p>但是，在IE8-的浏览器中无法运行，不支持addEventListener，IE有IE独有的DOM2级事件处理程序。（IE11亲测可以，IE9、10没测试过）。</p>
<h3 id="4、IE事件处理程序"><a href="#4、IE事件处理程序" class="headerlink" title="4、IE事件处理程序"></a>4、IE事件处理程序</h3><p>在IE中也提供了类似的两个方法</p>
<ul>
<li>attachEvent()添加事件</li>
<li>detachEvent()删除事件</li>
</ul>
<p>这两个方法接收相同的两个参数：事件处理程序名称与事件处理函数</p>
<p>[程序6]<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">btn3.attachEvent(<span class="string">"onclick"</span>,showMsg);</div></pre></td></tr></table></figure></p>
<p>这这里又要给事件加上“on”，这与DOM2级事件处理程序想法。那么这就夸浏览器了。<br>那么怎么解决跨浏览器的问题？答案是，能力判断，即你支持attachEvent()的能力就给你这个，你有别的能力你就你其他的能力。</p>
<h3 id="5、跨浏览器的事件处理程序"><a href="#5、跨浏览器的事件处理程序" class="headerlink" title="5、跨浏览器的事件处理程序"></a>5、跨浏览器的事件处理程序</h3><p>我们封装到一个对象<br>[程序7]<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> eventUtil = &#123;</div><div class="line">	<span class="comment">//添加句柄</span></div><div class="line">	addHandle:<span class="function"><span class="keyword">function</span>(<span class="params">element,type,handle</span>)</span>&#123;</div><div class="line">		<span class="keyword">if</span> (element.addEventListener) &#123;</div><div class="line">			element.addEventListener(type,handle,<span class="literal">false</span>);</div><div class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent)&#123;</div><div class="line">			element.attachEvent(<span class="string">"on"</span>+type,handle);</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			element[<span class="string">"on"</span>+type] = handle;</div><div class="line">		&#125;;</div><div class="line">	&#125;,</div><div class="line">    <span class="comment">//删除句柄</span></div><div class="line">	removeHandle:<span class="function"><span class="keyword">function</span>(<span class="params">element,type,handle</span>)</span>&#123;</div><div class="line">		<span class="keyword">if</span> (element.removeEventListener) &#123;</div><div class="line">			element.removeEventListener(type,handle,<span class="literal">false</span>);</div><div class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.dettachEvent)&#123;</div><div class="line">			element.dettachEvent(<span class="string">"on"</span>+type,handle);</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			element[<span class="string">"on"</span>+type] = <span class="literal">null</span>;</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//调用</span></div><div class="line">eventUtil.addHandle(btn3,<span class="string">"click"</span>,showMsg);</div></pre></td></tr></table></figure></p>
<p>这样一来，IE和Chrome都能很好的支持了。</p>
<h2 id="三、事件对象"><a href="#三、事件对象" class="headerlink" title="三、事件对象"></a>三、事件对象</h2><p>事件对象event</p>
<p><img src="http://upload-images.jianshu.io/upload_images/68937-477214596bb6ec09.png" alt="Paste_Image.png"></p>
<h3 id="1、DOM中的事件对象"><a href="#1、DOM中的事件对象" class="headerlink" title="1、DOM中的事件对象"></a>1、DOM中的事件对象</h3><p><strong>type:获取事件类型</strong><br>[程序8]<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">	alert(event.type);	<span class="comment">//click</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>target：事件目标</strong><br>[程序9]<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">	alert(event.target.nodeName);	<span class="comment">//input</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>stopPropagation() 阻止事件冒泡</strong><br>我们已经知道了事件冒泡的概念，那么，当我点击按钮的时候我就是点击按钮，不让它再冒泡到div上了，那么我们可以在程序中加上<br>event.stopPropagation() 即可阻止事件的冒泡。</p>
<p><strong>preventDefault() 阻止事件的默认行为</strong><br>事件的默认行为，比如,<code>&lt;a href=&quot;&quot;&gt;跳转&lt;/a&gt;</code>，他的默认行为就是跳转到某个链接，那么现在我们想要点击它不让它跳转，去执行我们给他的事件行为。那么可以这样写：<code>event.preventDefault()</code></p>
<h3 id="2、IE中的事件对象"><a href="#2、IE中的事件对象" class="headerlink" title="2、IE中的事件对象"></a>2、IE中的事件对象</h3><p><strong>type:获取事件类型</strong><br><strong>srcElement：事件目标</strong><br><strong>cancelBubble=true阻止事件冒泡</strong><br><strong>returnValue=false阻止事件的默认行为</strong>  </p>
<p>[程序10]<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>事件<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/event.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index.html"</span> <span class="attr">id</span>=<span class="string">"go"</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">	<span class="keyword">var</span> go = <span class="built_in">document</span>.getElementById(<span class="string">"go"</span>);</div><div class="line">	go.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">		<span class="keyword">if</span>(event &amp;&amp; event.preventDefault)&#123;</div><div class="line">			event.preventDefault();</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="built_in">window</span>.event.returnValue = <span class="literal">false</span>;</div><div class="line">		&#125;</div><div class="line">		alert(<span class="string">"我阻止了你"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="3、夸浏览器的事件对象"><a href="#3、夸浏览器的事件对象" class="headerlink" title="3、夸浏览器的事件对象"></a>3、夸浏览器的事件对象</h3><p>虽然 DOM 和 IE 中的 event 对象不同，但基于它们之间的相似性依旧可以拿出跨浏览器的方案来。IE 中 event 对象的全部信息和方法 DOM 对象中都有，只不过实现方式不一样。不过，这种对应关系让实现两种事件模型之间的映射非常容易。可以对前面介绍的 EventUtil 对象加以增强，添加如下方法以求同存异。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">getEvent: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> event ? event : <span class="built_in">window</span>.event;</div><div class="line">&#125;,</div><div class="line"><span class="attr">getTarget</span>: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> event.target || event.srcElement;</div><div class="line">&#125;,</div><div class="line"><span class="attr">preventDefault</span>: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">   <span class="keyword">if</span> (event.preventDefault)&#123;</div><div class="line">       event.preventDefault();</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       event.returnValue = <span class="literal">false</span>;</div><div class="line">   &#125;</div><div class="line">&#125;,</div><div class="line"><span class="attr">stopPropagation</span>: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (event.stopPropagation)&#123;</div><div class="line">        event.stopPropagation();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        event.cancelBubble = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一个是 getEvent()，它返回对 event对象的引用，在兼容 DOM 的浏览器中， event 变量只是简单地传入和返回。而在 IE 中， event 参数是未定义的（undefined），因此就会返回 window.event。</p>
<p>第二个方法是 getTarget()，它返回事件的目标。在这个方法内部，会检测 event 对象的 target属性，如果存在则返回该属性的值；否则，返回 srcElement 属性的值。</p>
<p>第三个方法是 preventDefault()，用于取消事件的默认行为。在传入 event 对象后，这个方法会检查是否存在preventDefault()方法，如果存在则调用该方法。如果 preventDefault()方法不存在，则将 returnValue 设置为 false。</p>
<p>第四个方法是 stopPropagation()，其实现方式类似。首先尝试使用 DOM 方法阻止事件流，否则就使用 cancelBubble 属性。</p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[数据库设计的一些问题]]></title>
      <url>/2014/08/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p><strong>char与varchar如何选择</strong></p>
<p>原则：</p>
<ol>
<li>如果列中要存储的数据长度差不多一致的，则因该考虑用char；否则因该考虑用varchar。</li>
<li>如果列中的最大数据长度小于50Byte，则一般也考虑用char。（当然如果这个列很少用，则基于节省空间和减少I/O的考虑，还是可以选择varchar）</li>
<li>一般不宜定义大于50Byte的char类型列。<a id="more"></a>
<strong>decimal与float如何选择</strong></li>
</ol>
<p>原则：</p>
<ol>
<li>decimal用于存储精确数据，而float只能用于存储非精确数据。故而精确数据只能选择用decimal类型。</li>
<li>由于float的存储空间开销一般比decimal小（精确到7位小数只需4个字节，二精确到15位小数只需8个字节）故而非精确数据有限选择float类型。</li>
</ol>
<p><strong>时间类型如何选择</strong></p>
<p>使用int来存储时间字段的优缺点</p>
<ul>
<li>优点：字段长度比datetime小。</li>
<li>缺点：使用不方便，要进行函数转换。</li>
<li>限制：只能存储大2038年-1-19 11:14:07即2^32为21474483648<br>需要存储时间粒度</li>
<li>年月日小时分秒周</li>
</ul>
<p><strong>如何选择主键</strong></p>
<ol>
<li>区分业务主键和数据库主键<br>业务主键用于标识业务数据，进行表与表之间的关联；<br>数据库主键为了优化数据存储（InnoDB会生成6个字节的隐含主键）</li>
<li>跟数据库的类型，考虑主键是否要顺序增长<br>有些数据库是按主键的顺序逻辑存储的</li>
<li>主键的字段类型所占空间要尽可能的小<br>对于使用聚集索引方式存储的表，每个索引后都会附加主键信息。  </li>
</ol>
<p><strong>避免使用外键约束</strong></p>
<p>1.降低数据导入效率。<br>2.增加维护成本。<br>3.虽然不建议使用外键约束，但是相关联的列上一定要建立索引    </p>
<p><strong>避免使用触发器</strong></p>
<p>1、降低数据导入效率。<br>2、可能会出现意想不到的数据异常。<br>3、使业务逻辑变的复杂。  </p>
<p><strong>关于预留字段</strong></p>
<p>1、无法准确的知道的预留字段的类型。<br>2、无法准确的知道预留字段中所存储的内容。<br>3、后期维护预留字段所要的成本，同增加一个字段所需要的成本是相同的。<br>4、严禁使用预留字段。  </p>
<p><strong>什么是反范式化</strong></p>
<p>反方式化是针对范式化而言的，所谓的反范式化就是为了性能和读取效率的考虑而适当的对第三范式的要求进行违反，而允许存在少量的数据冗余，换句话来说反范式化就是使用空间来换取时间。</p>
<p><strong>为什么反范式化</strong></p>
<p>1、减少表的管理数量<br>2、增加数据的读取效率<br>3、反范式化一定要适度  </p>
<p><strong>维护和优化中要做什么</strong></p>
<p>1、维护数据字典<br>2、维护索引<br>3、维护表结构<br>4、在适当的时候对表进行水平拆分或垂直拆分</p>
]]></content>
      
        <categories>
            
            <category> 数据库&amp;SQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 系统设计 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring：一切都是Bean(二)]]></title>
      <url>/2014/07/27/Spring%EF%BC%9A%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AFBean(%E4%BA%8C)/</url>
      <content type="html"><![CDATA[<h2 id="实例化Bean的3种方式"><a href="#实例化Bean的3种方式" class="headerlink" title="实例化Bean的3种方式"></a>实例化Bean的3种方式</h2><ul>
<li>通过bean元素来驱动调用有参数或无参数的构造器。</li>
<li>通过驱动静态工厂方法来创建Bean<ul>
<li>使用静态工厂方法创建Bean实例时，class指定创建Bean实例的静态工厂类。</li>
<li>使用factory-method属性来指定静态工厂方法名，Spring将调用静态工厂方法（可能包含一组参数），来返回一个Bean实例。</li>
<li>使用<code>&lt;constructor-arg.../&gt;</code>元素为工厂方法指定参数值。</li>
</ul>
</li>
<li>通过驱动实例工厂方法来创建Bean<br>与静态工厂方法创建Bean的配置几乎是相同的。唯一的区别是，如果使用静态工厂方法创建Bean，只要用class属性指定静态工厂类的类名即可。<br>如果使用实例工厂方法创建Bean，只要用factory-bean属性指定工厂bean的名字即可。</li>
</ul>
<p><strong>结论：无论是静态工厂方法，还是实例工厂方法，都需要增加一个factory-method属性。实例工厂方法，还需要指定factory-bean属性。</strong></p>
<h2 id="Bean继承与子Bean"><a href="#Bean继承与子Bean" class="headerlink" title="Bean继承与子Bean"></a>Bean继承与子Bean</h2><p>作用是简化配置文件，提高应用的可维护性。</p>
<p>如果Spring配置文件中有多个Bean，它们的部分配置信息是重复的</p>
<ol>
<li>配置就很臃肿。</li>
<li>如果有天需要修改，就需要同时修改多个地方，不利于维护。  </li>
</ol>
<p>Spring允许先为一批具有大致相同配置的Bean配置一个Bean模板——将这批Bean中相同的配置信息配置成Bean模板，Bean模板通常配成抽象Bean——就是配置Bean模板。</p>
<p>Bean模板配置完成后，将实际的Bean实例配置成该Bean模板的子Bean即可。子Bean定义可以从父Bean继承实现类、构造器参数、属性值等配置信息，除此之外，子Bean配置可以增加新的配置信息，并可指定新的配置信息覆盖父Bean的定义。</p>
<p>如果有一批Bean配置的大量配置信息完全相同，只有少量配置不同。</p>
<p>可以将这批Bean中大量相同的配置信息抽取成Bean模板（抽象Bean）。各子Bean则可以只需继承该Bean模板，即可获得父Bean的大量配置参数。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog"</span> <span class="attr">class</span>=<span class="string">"com.idealsh.test.service.Dog"</span> <span class="attr">parent</span>=<span class="string">"dogCatTemplate"</span></span></div><div class="line"><span class="attr">p:bark</span>=<span class="string">"旺，旺!!"</span> /&gt;</div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat"</span> <span class="attr">class</span>=<span class="string">"com.idealsh.test.service.Cat"</span> <span class="attr">parent</span>=<span class="string">"dogCatTemplate"</span></span></div><div class="line"><span class="attr">p:bark</span>=<span class="string">"苗，苗~~"</span> /&gt;</div><div class="line"><span class="comment">&lt;!-- 因为Bean模板只是一些通用配置，</span></div><div class="line">因此要通知Spring容器不需要创建Bean模板的实例，因此要增加abstract=“true”</div><div class="line"> --&gt;</div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dogCatTemplate"</span> <span class="attr">abstract</span>=<span class="string">"true"</span> <span class="attr">p:name</span>=<span class="string">"旺财"</span> <span class="attr">p:age</span>=<span class="string">"3"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p>使用<code>abstract=”true”</code>，该bean配置不会被创建实例。如果程序试图获取抽象Bean，就会包异常。</p>
<p>子Bean，使用parent=”父Bean”即可。子Bean就会从父Bean那里继承得到大量的配置信息。</p>
<h2 id="FactoryBean-：-标准工厂Bean接口"><a href="#FactoryBean-：-标准工厂Bean接口" class="headerlink" title="FactoryBean ： 标准工厂Bean接口"></a>FactoryBean ： 标准工厂Bean接口</h2><ul>
<li>他是一个接口，该接口里有三个方法。</li>
<li>如果一个Bean实现类实现了该接口，并在容器中配置了该Bean。</li>
<li>接下来程序获取Bean时，实际返回的只是该Bean的getObject方法的返回值。</li>
<li>由于getObject方法由程序员自己实现，因此我们想要在这个方法里做什么操作就可以做什么操作。</li>
</ul>
<h2 id="获取Bean配置ID"><a href="#获取Bean配置ID" class="headerlink" title="获取Bean配置ID"></a>获取Bean配置ID</h2><p>在有些时候，程序需要在写Bean类时，就能【预知】Bean的配置ID，此时就可借助于BeanNameAware接口。</p>
<p>和ApplicationContextAware有点相似，实现BeanNameAware接口，必须实现setBeanName方法。</p>
<p>setBeanName方法由Spring调用，Spring调用该方法时会将该Bean的配置id作为参数传入。</p>
<h2 id="Bean的生命周期行为"><a href="#Bean的生命周期行为" class="headerlink" title="Bean的生命周期行为"></a>Bean的生命周期行为</h2><p>对于singleton Bean来说，容器可以跟踪该Bean的产生和销毁。</p>
<p>开发者可以定制Bean的生命周期行为。</p>
<p>Bean完成所有依赖关系的注入后有2种方式可以管理Bean的行为：</p>
<ol>
<li>使用init-method或default-init-method属性配置。<br>init-method所指定的方法，会在Bean实例化、所有属性被注入之后，被Spring自动调用。</li>
<li>实现InitializingBean接口<br>InitializingBean接口中定义的方法，会在Bean实例化、所有属性被注入之后，被Spring自动调用(调用该接口的afterPropertiesSet方法)。</li>
</ol>
<p><strong>注意：上面两种方式只需要使用一种即可，但是我们推荐使用第一种方式更好。第二种方式会侮辱代码。</strong></p>
<p>Bean销毁前也可以通过2种方式来管理Bean：</p>
<ol>
<li>配置destroy-method/default-destory-method属性；</li>
<li>实现DisposableBean接口；    </li>
</ol>
<p>在JavaSE项目中，Spring容器销毁地太快，容器中的Bean来不及调用生命周期方法回收自己。<strong>需要为Spring容器注册关闭钩子，保证Spring容器以优雅的方式销毁自己</strong>,——容器中的Bean都会调用生命周期方法来执行回收操作。</p>
<p>在Java Web项目中，Spring容器默认就会以优雅的方式销毁。</p>
<p><img src="http://img2.ph.126.net/e4U_CudXzU8GZlsaiGceFA==/6619306289816177318.png" alt=""></p>
<h2 id="作用域不同步的Bean"><a href="#作用域不同步的Bean" class="headerlink" title="作用域不同步的Bean"></a>作用域不同步的Bean</h2><p>当singleton Bean依赖propotype Bean时，singleton Bean会把propotype Bean也变成singleton作用域。</p>
<p>为了解决该问题，解决思路是：</p>
<ul>
<li>放弃依赖注入。<br>自定义一个方法，改方法<ol>
<li>获取Spring容器</li>
<li>获取、并返回prototype Bean</li>
</ol>
</li>
<li>使用lookup方法注入。<ol>
<li>将Bean类定义成一个抽象类。</li>
<li>配置<code>&lt;lookup_method.../&gt;</code>子元素让Spring去实现抽象Ban类。</li>
</ol>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring：一切都是Bean(一)]]></title>
      <url>/2014/07/24/Spring%EF%BC%9A%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AFBean(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<h2 id="Bean的别名"><a href="#Bean的别名" class="headerlink" title="Bean的别名"></a>Bean的别名</h2><p>何谓别名？ 就是外号。</p>
<p>Spring容器中的Bean，为什么要有别名？</p>
<p>XML配置文件中id属性值必须是一个有效的标识符， id属性值不能有特殊字符，否则XML就报错了；但有些时候，程序需要【为Bean起一个包含特殊字符的名字】。此时用id就不行了，只能起别名。<br><a id="more"></a><br>起别名的两种方式：</p>
<ol>
<li>在<code>&lt;bean .../&gt;</code>元素中通过name属性来指定别名，多个别名之间用逗号隔开。</li>
<li>专门用<code>&lt;alias.../&gt;</code>元素来起别名。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"us"</span> <span class="attr">name</span>=<span class="string">"aa"</span> <span class="attr">class</span>=<span class="string">"com.idealsh.test.service.UserService"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"us"</span> <span class="attr">alias</span>=<span class="string">"bb"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>上面的配置下面的配置将会让us对象有三个名字：us、aa、bb</p>
<h2 id="Bean获取Spring容器"><a href="#Bean获取Spring容器" class="headerlink" title="Bean获取Spring容器"></a>Bean获取Spring容器</h2><p>在某些时候，当Bean要实现某个功能时，该Bean必须借助于Spring容器才能完成。</p>
<p>比如说，某个Bean需要提供国际化支持，这就必须通过Spring容器来获得国际化支持。</p>
<p>此时，该Bean就必须获取它所处的容器。</p>
<p>方法： <strong>让Bean实现ApplicationContextAware接口即可。</strong></p>
<p>实现该接口后，必须实现setApplicationContext方法。</p>
<blockquote>
<p>Spring会通过反射检测所有Bean的实现类是否实现ApplicationContextAware接口，只要实现了该接口，Spring会自动调用该Bean的setApplicationContext方法，并将容器自身作为参数传入。</p>
</blockquote>
<h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><p>通俗的的讲就是说Bean活多久，通过scope属性来指定。Bean的作用域，一共有如下几个：</p>
<ul>
<li>singleton：单例，所有从Spring容器中取出的总是同一个实例。Spring默认采用该模式。</li>
</ul>
<p>“与天地同寿，与日月同庚”</p>
<ul>
<li>只要容器不死，singleton Bean就不死。</li>
<li>容器创建之后，singleton Bean默认会被预初始化</li>
</ul>
<ul>
<li>prototype：不会预初始化。每次通过Spring容器中获取实例，Spring都会new一个新的实例返回。对于prototype Bean而言，Spring每次都new一个实例，new出来之后根本不管这个prototype Bean。</li>
<li>request：对应web应用中的request作用域。只对Web应用才有效，在一次请求中相当于singleton。</li>
<li>session：对应web应用中的session作用域。只对Web应用才有效，在一次用户会话中相当于singleton。</li>
<li>global session：仅在使用portlet context的时候才有效。</li>
</ul>
<p>一般来说，singleton Bean的性能更好，因为singleton Bean创建成本低，内存开销小。</p>
<h2 id="beans元素的属性与bean元素的属性的规律"><a href="#beans元素的属性与bean元素的属性的规律" class="headerlink" title="beans元素的属性与bean元素的属性的规律"></a>beans元素的属性与bean元素的属性的规律</h2><p>假如bean元素有abc属性，beans元素通常可能有default-abc属性。</p>
<p>如果在bean元素中指定的属性，仅对该Bean起作用；但在beans元素上指定的属性，对所有Bean都起作用。如果他们起冲突了，范围小的胜利。  </p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[把头像图片以二进制形式保存到数据库（Hibernate实现）]]></title>
      <url>/2014/07/13/%E6%8A%8A%E5%A4%B4%E5%83%8F%E5%9B%BE%E7%89%87%E4%BB%A5%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%BD%A2%E5%BC%8F%E4%BF%9D%E5%AD%98%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88Hibernate%E5%AE%9E%E7%8E%B0%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>我们把头像直接保存到数据库，而不是保存一个地址。<br>使用Hibernate自动创建表方式，<strong>数据库photo字段的数据类型是CLOB，这是针对MySQL，其他数据库可能不一样。</strong></p>
<p>1、Hibernate环境搭建、建立工程略。<br>2、首先我们新建一个User类，储存一些用户信息字段，在Java中photo字段要申明为应该byte[]类型</p>
<p>User.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> Integer age;</div><div class="line">    <span class="keyword">private</span> Date birthday; <span class="comment">// 生日</span></div><div class="line">    <span class="keyword">private</span> String desc; <span class="comment">// 一大段说明</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] photo; <span class="comment">// 头像图片</span></div><div class="line">    <span class="comment">//省略getter and setter Method...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3、然后配置User的映射文件<br>User.hbm.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0"?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC</span></div><div class="line">        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</div><div class="line">        "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;</div><div class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">"cn.itcast.c_hbm_property"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- name属性：哪个类</span></div><div class="line">	 table属性：对应哪个表，如果不写，默认的表名就是类的简单名称</div><div class="line">    --&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"User"</span> <span class="attr">table</span>=<span class="string">"t_user"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">id</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!-- 普通的属性（数据库中的基本类型，如字符串、日期、数字等） </span></div><div class="line">    	name属性：对象中的属性名，必须要有。</div><div class="line">	     type属性：类型，如果不写，Hibernate会自动检测。</div><div class="line">	     可以写Java中类的全名。</div><div class="line">	     或是写hibernate类型。</div><div class="line">	     column属性：对应表中的列名，如果没有，默认为属性名。</div><div class="line">	     length属性：长度，不是所有的类型都有长度属性，比如varchar有，但int没有，如果不写默认为255</div><div class="line">	     not-null属性：非空约束，默认为false</div><div class="line">	 --&gt;</div><div class="line">	 <span class="comment">&lt;!-- </span></div><div class="line">	      &lt;property name="name"/&gt;</div><div class="line">	 --&gt;</div><div class="line">	 <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">length</span>=<span class="string">"20"</span> <span class="attr">not-null</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line">	 <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">column</span>=<span class="string">"age_"</span>/&gt;</span></div><div class="line">		</div><div class="line">	 <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">type</span>=<span class="string">"date"</span> <span class="attr">column</span>=<span class="string">"birthday_"</span>/&gt;</span></div><div class="line">	 <span class="comment">&lt;!-- 当列表与关键字冲突时，可以通过column属性指定一个其他的列名。</span></div><div class="line">	      或是使用反引号包围起来。</div><div class="line">	      指定使用text类型时，最好再指定length，以确定生成的SQL类型是能够存放指定数量的字符的。</div><div class="line">              &lt;property name="desc"&gt;</div><div class="line">                  &lt;column name="desc_" length="5000" sql-type="text"/&gt;</div><div class="line">              &lt;/property&gt;		</div><div class="line">	 --&gt;</div><div class="line">	 <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"desc"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">length</span>=<span class="string">"5000"</span> <span class="attr">column</span>=<span class="string">"`desc`"</span> &gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">	 <span class="comment">&lt;!-- 头像，二进制类型，最好指定长度 --&gt;</span></div><div class="line">	 <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"photo"</span> <span class="attr">type</span>=<span class="string">"binary"</span> <span class="attr">length</span>=<span class="string">"102400"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>4、测试类测试新增User信息</p>
<p>photoTest.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">photoTest</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SessionFactory sessionFactory;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">	sessionFactory = <span class="keyword">new</span> Configuration()<span class="comment">//</span></div><div class="line">	    .configure()<span class="comment">// 读取配置文件</span></div><div class="line">	    .addClass(User.class)<span class="comment">//</span></div><div class="line">	    .buildSessionFactory();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">// 读取图片文件</span></div><div class="line">        InputStream in = <span class="keyword">new</span> FileInputStream( <span class="string">"c:/test.png"</span>);</div><div class="line">        <span class="keyword">byte</span>[] photo = <span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];</div><div class="line">        in.read(photo);</div><div class="line">        in.close();</div><div class="line">		</div><div class="line">        <span class="comment">// 创建对象实例</span></div><div class="line">        User user = <span class="keyword">new</span> User();</div><div class="line">        user.setName(<span class="string">"张三"</span>);</div><div class="line">        user.setAge(<span class="number">20</span>);</div><div class="line">        user.setBirthday(<span class="keyword">new</span> Date());</div><div class="line">        user.setDesc(<span class="string">"一大段的说明，此处省略5000字……"</span>);</div><div class="line">        user.setPhoto(photo);</div><div class="line">        <span class="comment">// 保存</span></div><div class="line">        Session session = sessionFactory.openSession(); <span class="comment">// 打开一个新的Session</span></div><div class="line">        Transaction tx = session.beginTransaction(); <span class="comment">// 开始事务</span></div><div class="line">        session.save(user);</div><div class="line">        tx.commit(); <span class="comment">// 提交事务</span></div><div class="line">        session.close(); <span class="comment">// 关闭Session，释放资源</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码就是把c盘根目录的test.png图片保存到了数据库。<br>通过SQL查询该字段可看到是二进制数据，那么证明保存成功。</p>
<p>5、我们再把图片读取出来放在D盘下，取名copy.png</p>
<p>photoTest.testGet():<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></div><div class="line">    Session session = sessionFactory.openSession();</div><div class="line">    Transaction tx = session.beginTransaction();</div><div class="line">    User user = (User) session.get(User.class, <span class="number">1</span>); <span class="comment">// 获取</span></div><div class="line">    System.out.println(user.getId());</div><div class="line">    System.out.println(user.getName());</div><div class="line">    System.out.println(user.getDesc());</div><div class="line">    System.out.println(user.getPhoto());</div><div class="line">		</div><div class="line">    OutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">"D:/copy.png"</span>);</div><div class="line">    out.write(user.getPhoto());</div><div class="line">    out.close();</div><div class="line">    tx.commit();</div><div class="line">    session.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>经测试成功运行………..</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hibernate </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[根据分组依据对Java集合元素进行分组]]></title>
      <url>/2014/07/10/%E6%A0%B9%E6%8D%AE%E5%88%86%E7%BB%84%E4%BE%9D%E6%8D%AE%E5%AF%B9Java%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0%E8%BF%9B%E8%A1%8C%E5%88%86%E7%BB%84/</url>
      <content type="html"><![CDATA[<p>业务背景：在项目中有个“分账”功能，就是支付的钱一部分要根据不同商品的分账金额自动分给平台提供商。</p>
<p>有以下业务模型：</p>
<ul>
<li>商户号：提供给每个商家的一种凭证号码。</li>
<li>分销商：平台上的卖家。每个分销商拥有一个商户号。</li>
<li>主商户号：平台提供商的商户号，对应的，每个卖家的商户号被称为子商户号。</li>
<li>订单好和订单总金额：一个订单的总金额。</li>
<li>分账金额：每个商品被要求设置一个字段，存储分账金额。</li>
</ul>
<p>下面模拟一个业务模型：</p>
<ul>
<li><p>有如下分销商：<br>10001的商户号：0018888881<br>10002的商户号：0018888882<br>主商户号：1200000016</p>
</li>
<li><p>有如下订单：<br>2000020140530000672，总金额：600<br>订单下有三个物品：</p>
<ul>
<li>物品A：属于分销商10001，物品价格：100，分账：50</li>
<li>物品B：属于分销商10001，物品价格：200，分账：70</li>
<li>物品C：属于分销商10002，物品价格：300，分账：100</li>
</ul>
</li>
<li><p>计算后的10001商户分账总金额：70+50=120</p>
</li>
<li>计算后的10002商户分账总金额：100</li>
<li>计算后的主商户分账总金额：(100-50)+(200-70)+(300-100)=380</li>
</ul>
<p>那么，经过计算后，应该要得到一个如下的字符串参数，以用来传递给支付工具接口调用。<br>最后得出的分账参数字符串：1200000016：380 | 0018888881：120 | 0018888882：100</p>
<p>也就是，每个订单要分解成一个主商户号（平台提供商），若干个子商户号（卖家），而且每个字商户号只能出现一次，但分解后通常会出现一个订单中会有同一个商户号的若干商品，所以，必须要对分解出来的数据进行分组统计。</p>
<p>下面贴出模拟过程的完整代码，由于是模拟，所以部分地方数据直接自己构造进去了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 模拟中国电信翼支付的分账功能接口调用的参数字符串</div><div class="line"> * 根据分组依据对集合进行分组</div><div class="line"> * <span class="doctag">@author</span> ZhangBing</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionGroupTest</span> </span>&#123;</div><div class="line">    <span class="comment">/***</span></div><div class="line">     * 分组依据接口，用于集合分组时，获取分组依据</div><div class="line">     * <span class="doctag">@author</span> ZhangBing</div><div class="line">     * <span class="doctag">@date</span> 20140530</div><div class="line">     * <span class="doctag">@param</span> &lt;T&gt;</div><div class="line">     */</div><div class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">GroupBy</span>&lt;<span class="title">T</span>&gt;</span>&#123;</div><div class="line">        <span class="function">T <span class="title">groupBy</span><span class="params">(Object obj)</span></span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 模拟订单实体类</div><div class="line">     * <span class="doctag">@author</span> ZhangBing</div><div class="line">     *</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemInfo</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> String id;<span class="comment">//订单ID</span></div><div class="line">        <span class="keyword">private</span> String shopid;<span class="comment">//店铺ID</span></div><div class="line">        <span class="keyword">private</span> String fxSplitMoney;<span class="comment">//分账金额</span></div><div class="line">        <span class="keyword">private</span> String itemValue;<span class="comment">//物品价格</span></div><div class="line">        <span class="comment">/** 省略getter setter方法 */</span></div><div class="line">        .....</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 集合临时转换类,跟模拟订单实体类对应</div><div class="line">     * <span class="doctag">@author</span> ZhangBing</div><div class="line">     * <span class="doctag">@date</span> 2014-5-30 上午10:38:48</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyData</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> String id ;</div><div class="line">        <span class="keyword">private</span> String shopId ;</div><div class="line">        <span class="keyword">private</span> String itemValue;</div><div class="line">        <span class="keyword">private</span> String fxMoney;</div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getFxMoney</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> fxMoney;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> MyData <span class="title">setFxMoney</span><span class="params">(String fxMoney)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.fxMoney = fxMoney;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getItemValue</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">return</span> itemValue;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> MyData <span class="title">setItemValue</span><span class="params">(String itemValue)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.itemValue = itemValue;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> id;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> MyData <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.id = id;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getShopId</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> shopId;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> MyData <span class="title">setShopId</span><span class="params">(String shopId)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.shopId = shopId;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 分组依据实现</div><div class="line">     * <span class="doctag">@param</span> &lt;T&gt;</div><div class="line">     * <span class="doctag">@param</span> &lt;D&gt;</div><div class="line">     * <span class="doctag">@param</span> colls</div><div class="line">     * <span class="doctag">@param</span> gb</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> &lt;T extends Comparable&lt;T&gt;,D&gt; Map&lt;T,List&lt;D&gt;&gt; group(Collection&lt;D&gt; colls,GroupBy&lt;T&gt; gb)&#123;</div><div class="line">        <span class="keyword">if</span>(colls == <span class="keyword">null</span> || colls.isEmpty())&#123;</div><div class="line">            System.out.println(<span class="string">"分组集合不能为空!"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(gb == <span class="keyword">null</span>)&#123;</div><div class="line">            System.out.println(<span class="string">"分组依据接口不能为Null!"</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        Iterator&lt;D&gt; iter = colls.iterator();</div><div class="line">        Map&lt;T,List&lt;D&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;T, List&lt;D&gt;&gt;();</div><div class="line">        <span class="keyword">while</span>(iter.hasNext())&#123;</div><div class="line">            D d = iter.next();</div><div class="line">            T t = gb.groupBy(d);</div><div class="line">            <span class="keyword">if</span>(map.containsKey(t))&#123;</div><div class="line">                map.get(t).add(d);</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                List&lt;D&gt; list = <span class="keyword">new</span> ArrayList&lt;D&gt;();</div><div class="line">                list.add(d);</div><div class="line">                map.put(t, list);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> map;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 根据店铺号返回该店铺的商户号</div><div class="line">     * <span class="doctag">@param</span> shopId 店铺号</div><div class="line">     * <span class="doctag">@return</span> 商户号</div><div class="line">     * <span class="doctag">@throws</span> Exception</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getByShopID</span><span class="params">(String shopId)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="string">"10001"</span>.equals(shopId))&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"0018888881"</span>;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"10002"</span>.equals(shopId))&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"0018888882"</span>;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"找不到改店铺的商户号！"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/***</span></div><div class="line">     * 设置分账信息、组装分账信息参数字符串</div><div class="line">     * <span class="doctag">@param</span> orderIds 订单号码</div><div class="line">     * <span class="doctag">@param</span> ordersAmount 订单总金额</div><div class="line">     * <span class="doctag">@return</span> 分账信息参数字符串</div><div class="line">     * <span class="doctag">@throws</span> Exception </div><div class="line">     * <span class="doctag">@author</span> ZhangBing</div><div class="line">     * <span class="doctag">@date</span> 20140527</div><div class="line">     * <span class="doctag">@version</span> 2</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getPaymentDivDetails</span><span class="params">(List&lt;ItemInfo&gt; items,String ordersAmount)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="comment">//分账字符串</span></div><div class="line">        String divs = <span class="string">""</span>;            </div><div class="line">        String div =<span class="string">""</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//主商户号1200000016</span></div><div class="line">        String mainSid = <span class="string">"1200000016"</span>;    </div><div class="line">        </div><div class="line">        List&lt;MyData&gt; list = <span class="keyword">new</span> ArrayList&lt;MyData&gt;();</div><div class="line">        <span class="keyword">for</span>(ItemInfo item : items)&#123;</div><div class="line">            list.add(<span class="keyword">new</span> MyData().setId(item.getId()).setShopId(item.getShopid())</div><div class="line">                .setFxMoney(item.getFxSplitMoney()).setItemValue(item.getItemValue())) ;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//对得到的集合进行分组</span></div><div class="line">        Map&lt;String ,List&lt;MyData&gt;&gt; map = group(list, <span class="keyword">new</span> GroupBy&lt;String&gt;() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">groupBy</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">                MyData d = (MyData)obj;</div><div class="line">                <span class="keyword">return</span> d.getShopId();    <span class="comment">// 分组依据为店铺ID</span></div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">//主商户分账总金额</span></div><div class="line">        Double mainMoney = <span class="number">0.0</span>;</div><div class="line">        Set&lt;String&gt; set = map.keySet();</div><div class="line">        <span class="keyword">for</span>(Object key : set)&#123;</div><div class="line">            <span class="comment">//System.out.println(key);</span></div><div class="line">            String shopId = (String)key;</div><div class="line">            <span class="comment">//System.out.println("子商户号："+shop.getFxshopSid());</span></div><div class="line">            List&lt;MyData&gt; datas = map.get(key);</div><div class="line">            Double fxMoney = <span class="number">0.0</span>;</div><div class="line">            <span class="comment">//子商户号</span></div><div class="line">            String subSid = getByShopID(shopId);</div><div class="line">            <span class="keyword">for</span>(MyData d : datas)&#123;</div><div class="line">                <span class="comment">//System.out.println("价格:"+d.getItemValue());</span></div><div class="line">                <span class="comment">//System.out.println("分账:"+d.fxMoney);</span></div><div class="line">                </div><div class="line">                <span class="comment">//获取商品的子商户分账金额</span></div><div class="line">                Double fxSplitMoney = Double.parseDouble(d.fxMoney);</div><div class="line">                <span class="comment">//计算主商户分账总金额</span></div><div class="line">                mainMoney += Double.parseDouble(d.getItemValue()) - fxSplitMoney;</div><div class="line">                <span class="comment">//计算子商户分账金额</span></div><div class="line">                fxMoney += fxSplitMoney;</div><div class="line">                <span class="comment">//System.out.println("子商户号:"+subSid+" 子商号分账总金额:"+fxMoney);</span></div><div class="line">            &#125;</div><div class="line">            divs += subSid+<span class="string">":"</span>+fxMoney+<span class="string">"|"</span>;</div><div class="line">            <span class="comment">//System.out.println(divs);</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//System.out.println("主商户号:"+mainSid+" 主商号分账总金额:"+mainMoney);</span></div><div class="line">        div = mainSid+<span class="string">":"</span>+mainMoney+<span class="string">"|"</span>+divs;</div><div class="line">        <span class="comment">//System.out.println(div);</span></div><div class="line">        div = div.substring(<span class="number">0</span>, div.length()-<span class="number">1</span>);</div><div class="line">        <span class="comment">//System.out.println(div);</span></div><div class="line">        <span class="keyword">return</span> div;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 模拟有一个订单，订单下有三个物品</div><div class="line">         * ItemInfo+ordersAmount组成了一个订单信息</div><div class="line">         */</div><div class="line">        <span class="comment">//订单总金额/元</span></div><div class="line">        String ordersAmount = <span class="string">"3000"</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//物品1</span></div><div class="line">        ItemInfo ii = <span class="keyword">new</span> ItemInfo();</div><div class="line">        ii.setId(<span class="string">"1"</span>);                <span class="comment">//订单表ID</span></div><div class="line">        ii.setFxSplitMoney(<span class="string">"100"</span>);    <span class="comment">//分账金额，比如这个物品1价格为1000元，需要分给平台100元</span></div><div class="line">        ii.setItemValue(<span class="string">"1000"</span>);    <span class="comment">//物品价格</span></div><div class="line">        ii.setShopid(<span class="string">"10001"</span>);        <span class="comment">//店铺号</span></div><div class="line">        <span class="comment">//物品2</span></div><div class="line">        ItemInfo ii2 = <span class="keyword">new</span> ItemInfo();</div><div class="line">        ii2.setId(<span class="string">"2"</span>);</div><div class="line">        ii2.setFxSplitMoney(<span class="string">"300"</span>);</div><div class="line">        ii2.setItemValue(<span class="string">"1000"</span>);</div><div class="line">        ii2.setShopid(<span class="string">"10001"</span>);</div><div class="line">        <span class="comment">//物品3</span></div><div class="line">        ItemInfo ii3 = <span class="keyword">new</span> ItemInfo();</div><div class="line">        ii3.setId(<span class="string">"3"</span>);</div><div class="line">        ii3.setFxSplitMoney(<span class="string">"200"</span>);</div><div class="line">        ii3.setItemValue(<span class="string">"1000"</span>);</div><div class="line">        ii3.setShopid(<span class="string">"10002"</span>);</div><div class="line">        </div><div class="line">        List&lt;ItemInfo&gt; items = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        items.add(ii);</div><div class="line">        items.add(ii2);</div><div class="line">        items.add(ii3);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//得到这样的字符串：1200000016:2400.0|0018888881:400.0|0018888882:200.0</span></div><div class="line">            String divDetails = getPaymentDivDetails(items, ordersAmount);</div><div class="line">            System.out.println(divDetails);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;       </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行后正好能得到1200000016:2400.0|0018888881:400.0|0018888882:200.0。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 集合 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JDBC操作数据库的元数据信息，JDBC复习(四) ]]></title>
      <url>/2014/07/09/JDBC%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF%EF%BC%8CJDBC%E5%A4%8D%E4%B9%A0(%E5%9B%9B)/</url>
      <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="./#什么是数据库元数据？">什么是数据库元数据？</a><br><a href="./#JDBC中获取数据库元数据信息">JDBC中获取数据库元数据信息</a><br><a href="./#参数的元数据信息">参数的元数据信息</a><br><a href="./#结果集元数据信息">结果集元数据信息</a></p>
<h2 id="什么是数据库元数据？"><a href="#什么是数据库元数据？" class="headerlink" title="什么是数据库元数据？"></a>什么是数据库元数据？</h2><p>简单的说，元数据（Metadata）就是数据的数据。在数据仓库系统中，元数据可以帮助数据仓库管理员和数据仓库的开发人员非常方便地找到他们所关心的数据；元数据是描述数据仓库内数据的结构和建立方法的数据。</p>
<p>可将其按用途的不同分为两类：技术元数据（Technical Metadata）和业务元数据（Business Metadata）。</p>
<p><strong>技术元数据</strong><br>存储关于数据仓库系统技术细节的数据，是用于开发和管理数据仓库使用的数据，它主要包括以下信息：数据仓库结构的描述，包括仓库模式、视图、维、层次结构和导出数据的定义，以及数据集市的位置和内容；业务系统、数据仓库和数据集市的体系结构和模式；汇总用的算法，包括度量和维定义算法，数据粒度、主题领域、聚集、汇总、预定义的查询与报告；；由操作环境到数据仓库环境的映射，包括源数据和它们的内容、数据分割、数据提取、清理、转换规则和数据刷新规则、安全(用户授权和存取控制)。</p>
<p><strong>业务元数据</strong><br>从业务角度描述了数据仓库中的数据，它提供了介于使用者和实际系统之间的语义层，使得不懂计算机技术的业务人员也能够”读懂”数据仓库中的数据。业务元数据主要包括以下信息：使用者的业务术语所表达的数据模型、对象名和属性名；访问数据的原则和数据的来源；系统所提供的分析方法以及公式和报表的信息。</p>
<p>更多数据库元数据信息请百度吧，有点复杂深奥………</p>
<h2 id="JDBC中获取数据库元数据信息"><a href="#JDBC中获取数据库元数据信息" class="headerlink" title="JDBC中获取数据库元数据信息"></a>JDBC中获取数据库元数据信息</h2><p>JDBC中Connection有一个方法getMetaData()方法，可以获的数据库的元数据信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DatabaseMetaData meta = connection.getMetaData();</div></pre></td></tr></table></figure></p>
<p>通过DatabaseMetaData可以获得数据库相关的信息如：数据库版本、数据库名、数据库厂商信息、是否支持事务、是否支持某种事务隔离级别，是否支持滚动结果集等。</p>
<p>DataBaseMetaData对象：</p>
<ul>
<li><strong>getURL()</strong> 返回一个String类对象，代表数据库的URL。 </li>
<li><strong>getUserName()</strong> 返回连接当前数据库管理系统的用户名。 </li>
<li><strong>getDatabaseProductName()</strong> 返回数据库的产品名称。 </li>
<li><strong>getDatabaseProductVersion()</strong> 返回数据库的版本号。</li>
<li><strong>getDriverName()</strong> 返回驱动驱动程序的名称。 </li>
<li><strong>getDriverVersion()</strong> 返回驱动程序的版本号。 </li>
<li><strong>isReadOnly()</strong> 返回一个boolean值，指示数据库是否只允许读操作。</li>
</ul>
<p>获取数据库的元数据信息:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    java.sql.Connection conn = JdbcUtils.getConnenction();</div><div class="line">    DatabaseMetaData dbmd = conn.getMetaData();</div><div class="line">    <span class="comment">//获取使用的数据库是什么数据库  MySQL</span></div><div class="line">    System.out.println(<span class="string">"db name: "</span> + dbmd.getDatabaseProductName());</div><div class="line">    <span class="comment">//是否支持事物  true</span></div><div class="line">    System.out.println(<span class="string">"tx: "</span> + dbmd.supportsTransactions());</div><div class="line">    conn.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="参数的元数据信息"><a href="#参数的元数据信息" class="headerlink" title="参数的元数据信息"></a>参数的元数据信息</h2><p>PreparedStatement.getParameterMetaData()<br>获得代表PreparedStatement元数据的ParameterMetaData对象。<br>ParameterMetaData对象：</p>
<ul>
<li><strong>getParameterCount()</strong> 获得指定参数的个数</li>
<li><strong>getParameterClassName()</strong> 获得参数的类型，比如String等等</li>
<li><strong>getParameterType() </strong></li>
<li><strong>getParameterTypeName()</strong> 获得参数对应数据库的数据类型，比如VARCHAR等等</li>
</ul>
<p>获取ParameterMetaData元数据信息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">conn = JdbcUtils.getConnection();</div><div class="line">ps = conn.prepareStatement(sql);</div><div class="line">ParameterMetaData pmd = ps.getParameterMetaData();</div><div class="line"><span class="keyword">int</span> count = pmd.getParameterCount();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= params.length; i++) &#123;</div><div class="line">    System.out.print(pmd.getParameterClassName(i) + <span class="string">"\t"</span>);</div><div class="line">    System.out.print(pmd.getParameterType(i) + <span class="string">"\t"</span>);</div><div class="line">    System.out.println(pmd.getParameterTypeName(i));</div><div class="line">    ps.setObject(i, params[i - <span class="number">1</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="结果集元数据信息"><a href="#结果集元数据信息" class="headerlink" title="结果集元数据信息"></a>结果集元数据信息</h2><p>结果集(ResultSet)是数据中查询结果返回的一种对象，可以说结果集是一个存储查询结果的对象，但是结果集并不仅仅具有存储的功能，他同时还具有操纵数据的功能，可能完成对数据的更新等。</p>
<p><strong>PreparedStatement中的方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">getMetaData ResultSetMetaData <span class="title">getMetaData</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span></div></pre></td></tr></table></figure></p>
<p>获取包含有关 ResultSet 对象列信息的 <code>ResultSetMetaData</code> 对象，ResultSet 对象将在执行此 <code>PreparedStatement</code>对象时返回。</p>
<p>因为 <code>PreparedStatement</code> 对象被预编译，所以不必执行就可以知道它将返回的 ResultSet 对象。因此，可以对 <code>PreparedStatement</code> 对象调用 getMetaData 方法，而不必等待执行该对象，然后再对返回的 ResultSet 对象调用 <code>ResultSet.getMetaData</code> 方法。  </p>
<blockquote>
<p>注：对于某些缺乏底层 DBMS 支持的驱动程序，使用此方法开销可能很大。 </p>
</blockquote>
<p><strong>ResultSet中</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">getMetaData</span></div><div class="line">ResultSetMetaData <span class="title">getMetaData</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</div></pre></td></tr></table></figure></p>
<p>获取此 ResultSet 对象的列的编号、类型和属性。<br>返回： 此 ResultSet 对象的列的描述 </p>
<p>获取ResultSetMetaData元数据信息:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; read(String sql,Object[] params)&#123;   </div><div class="line">    <span class="keyword">try</span> &#123;    </div><div class="line">	ps = conn.prepareStatement(sql);    </div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;params.length;i++)&#123;     </div><div class="line">	    ps.setObject(i+<span class="number">1</span>, params[i]);     </div><div class="line">	&#125;     </div><div class="line">	rs=ps.executeQuery();     </div><div class="line">	ResultSetMetaData rsm=rs.getMetaData();    </div><div class="line">	<span class="comment">//获取查询结果有多少列     </span></div><div class="line">	<span class="keyword">int</span> count=rsm.getColumnCount();     </div><div class="line">	<span class="comment">//存储查询结果的列名     </span></div><div class="line">	String[] strColumns=<span class="keyword">new</span> String[rsm.getColumnCount()];    </div><div class="line">	<span class="comment">//循环遍历结果集       </span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=count;i++)&#123; </div><div class="line">	    <span class="comment">//返回构造其实例的 Java 类的完全限定名称//    </span></div><div class="line">	    System.out.print(rsm.getColumnClassName(i)+<span class="string">"\t"</span>); <span class="comment">//   </span></div><div class="line">	    <span class="comment">//获取指定列的 SQL 类型,返回值为int类型  //    </span></div><div class="line">	    System.out.print(rsm.getColumnType(i)+<span class="string">"\t"</span>); <span class="comment">//    </span></div><div class="line">	    <span class="comment">//获取指定列的数据库特定的类型名称。  //    </span></div><div class="line">	    System.out.print(rsm.getColumnTypeName(i)+<span class="string">"\t"</span>); <span class="comment">//    </span></div><div class="line">	    <span class="comment">//获取指定列的名称。  //    </span></div><div class="line">	    System.out.print(rsm.getColumnName(i)+<span class="string">"\t"</span>); <span class="comment">//       </span></div><div class="line">	    <span class="comment">/*获取用于打印输出和显示的指定列的建议标题。 </span></div><div class="line">	    //     * 建议标题通常由 SQL AS 子句来指定。  //     </div><div class="line">	    * 如果未指定 SQL AS，则从 getColumnLabel 返回的值将和 //     </div><div class="line">	    *  getColumnName 方法返回的值相同。 */  <span class="comment">//    </span></div><div class="line">	    System.out.println(rsm.getColumnLabel(i));     </div><div class="line">	    strColumns[i-<span class="number">1</span>]=rsm.getColumnLabel(i);     </div><div class="line">	&#125;     </div><div class="line">	List&lt;Map&lt;String, Object&gt;&gt; datas=<span class="keyword">new</span> ArrayList&lt;Map&lt;String,Object&gt;&gt;();    </div><div class="line">        <span class="keyword">while</span>(rs.next())&#123;     </div><div class="line">	    Map&lt;String, Object&gt; data=<span class="keyword">new</span> HashMap&lt;String, Object&gt;();     </div><div class="line">	    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strColumns.length;i++)&#123;       </div><div class="line">	        data.put(strColumns[i], rs.getObject(strColumns[i]));      </div><div class="line">	    &#125;      </div><div class="line">	    datas.add(data);     </div><div class="line">        &#125;     </div><div class="line">        <span class="keyword">return</span> datas;    </div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;     </div><div class="line">        e.printStackTrace();    </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;    </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jdbc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JDBC的批处理、可滚动和可更新结果集，JDBC复习(三)]]></title>
      <url>/2014/07/08/JDBC%E7%9A%84%E6%89%B9%E5%A4%84%E7%90%86%E3%80%81%E5%8F%AF%E6%BB%9A%E5%8A%A8%E5%92%8C%E5%8F%AF%E6%9B%B4%E6%96%B0%E7%BB%93%E6%9E%9C%E9%9B%86%EF%BC%8CJDBC%E5%A4%8D%E4%B9%A0(%E4%B8%89)/</url>
      <content type="html"><![CDATA[<h2 id="一、使用JDBC的批处理功能"><a href="#一、使用JDBC的批处理功能" class="headerlink" title="一、使用JDBC的批处理功能"></a>一、使用JDBC的批处理功能</h2><p>业务场景：当需要向数据库发送一批SQL语句执行时，应避免向数据库一条条的发送执行，而应采用JDBC的批处理机制，以提升执行效率。 </p>
<p>实现批处理有两种方式</p>
<h3 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h3><p><code>Statement.addBatch(sql)</code> 执行批处理SQL语句<br><code>executeBatch()方法</code>：执行批处理命令<br><code>clearBatch()方法</code>：清除批处理命令  </p>
<p>采用Statement.addBatch(sql)方式实现批处理：<br>优点：可以向数据库发送多条不同的ＳＱＬ语句。<br>缺点： SQL语句没有预编译。 当向数据库发送多条语句相同，但仅参数不同的SQL语句时，需重复写上很多条SQL语句。  </p>
<h3 id="实现批处理的第二种方式：PreparedStatement-addBatch"><a href="#实现批处理的第二种方式：PreparedStatement-addBatch" class="headerlink" title="实现批处理的第二种方式：PreparedStatement.addBatch()"></a>实现批处理的第二种方式：PreparedStatement.addBatch()</h3><p>优点：发送的是预编译后的SQL语句，执行效率高。<br>缺点：只能应用在SQL语句相同，但参数不同的批处理中。因此此种形式的批处理经常用于在同一个表中批量插入 数据，或批量更新表的数据。</p>
<p>批处理实例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createBatch</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    Connection conn = <span class="keyword">null</span>;</div><div class="line">    PreparedStatement ps = <span class="keyword">null</span>;</div><div class="line">    ResultSet rs = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">	conn = JdbcUtils.getConnection();</div><div class="line">	String sql = <span class="string">"insert into user(name,birthday, money) values (?, ?, ?) "</span>;</div><div class="line">	ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">	    ps.setString(<span class="number">1</span>, <span class="string">"batch name"</span> + i);</div><div class="line">	    ps.setDate(<span class="number">2</span>, <span class="keyword">new</span> Date(System.currentTimeMillis()));</div><div class="line">	    ps.setFloat(<span class="number">3</span>, <span class="number">100f</span> + i);</div><div class="line">	    ps.addBatch();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">int</span>[] is = ps.executeBatch();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">	JdbcUtils.free(rs, ps, conn);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="二、JDBC可滚动和可更新结果集"><a href="#二、JDBC可滚动和可更新结果集" class="headerlink" title="二、JDBC可滚动和可更新结果集"></a>二、JDBC可滚动和可更新结果集</h2><p>JDBC中ResultSet类中，我们可以使用next()方法从结果集中的一条记录移动到下一条记录。同时我们还可以在定义Statement或PrepareStatement时指定结果集是否可滚动或更新。以下是注意事项：</p>
<ul>
<li>即使使用了CONCUR_UPDATABLE参数来创建Statement，得到的结果集也不一定是“可更新的”。如果你的记录集来自合并查询，这样的结果集就可能是不可更新的。可以使用ResultSet类的getConcurrency()方法来确定是否为可更新结果集。</li>
<li><p>在JDBC中使用可更新的结果集来更新数据库，不能使用”select * from table”方式的sql语句，必须写成以下两种形式之一：</p>
<ul>
<li>select table.* from table </li>
<li>select column1,column2,column3 from table</li>
</ul>
</li>
<li><p>如果使用的JDBC版本是3.0 (JDK1.4以后的版本)，使用CallableStatement的setXXX()方法来设置IN参数时，既可以使用索引，也可以使用参数名称。如果使用JDBC2.0及以下版本，只能使用使用索引。对于对应的getXXX()中的参数也一样。</p>
</li>
</ul>
<blockquote>
<p>为了使照片能够快速、正确的存入oracle数据库中，最好使用oracle 10g的JDBC驱动！</p>
</blockquote>
<p>ResultSet 可取值常量值：</p>
<ul>
<li>TYPE_FORWARD_ONLY 结果集不能滚动</li>
<li>TYPE_SCROLL_INSENSITIVE 结果集可以滚动，但对数据库变化不敏感</li>
<li>TYPE_SCROLL_SENSITIVE 结果集可以滚动，但对数据库变化敏感</li>
<li>CONCUR_READ_ONLY 结果集不能用于更新数据库(默认值)</li>
<li>CONCUR_UPDATABLE 结果集可以用于更新数据库 </li>
</ul>
<p>例如：只想滚动遍历结果集，而不想修改他的数据，那么可以使用一下语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Statement stat = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);</div></pre></td></tr></table></figure></p>
<p>向前滚动：if(rs.previous)…<br>向前或者向后滚动：rs.relative(n); n为正数或者负数<br>返回当前行号：rs.getRow();</p>
<p>可滚动的结果集实例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scroll</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">    Connection conn = <span class="keyword">null</span>;</div><div class="line">    Statement st = <span class="keyword">null</span>;</div><div class="line">    ResultSet rs = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">	<span class="comment">// 2.建立连接</span></div><div class="line">	conn = JdbcUtils.getConnection();</div><div class="line">	st = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_READ_ONLY);</div><div class="line">	rs = st.executeQuery(<span class="string">"select id, name, money, birthday  from user limit 150, 10"</span>);</div><div class="line">	<span class="keyword">while</span> (rs.next()) &#123;</div><div class="line">	    System.out.println(rs.getObject(<span class="string">"id"</span>) + <span class="string">"\t"</span></div><div class="line">		+ rs.getObject(<span class="string">"name"</span>) + <span class="string">"\t"</span></div><div class="line">		+ rs.getObject(<span class="string">"birthday"</span>) + <span class="string">"\t"</span></div><div class="line">		+ rs.getObject(<span class="string">"money"</span>));</div><div class="line">	    &#125;</div><div class="line">	    System.out.println(<span class="string">"------------"</span>);</div><div class="line">	    <span class="comment">//绝对定位，定位到结果集的第5行</span></div><div class="line">	    rs.absolute(<span class="number">150</span>);</div><div class="line">	    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">	    <span class="keyword">while</span> (rs.next() &amp;&amp; i &lt; <span class="number">10</span>) &#123;</div><div class="line">		i++;</div><div class="line">		System.out.println(rs.getObject(<span class="string">"id"</span>) + <span class="string">"\t"</span></div><div class="line">	    	    + rs.getObject(<span class="string">"name"</span>) + <span class="string">"\t"</span></div><div class="line">		    + rs.getObject(<span class="string">"birthday"</span>) + <span class="string">"\t"</span></div><div class="line">		    + rs.getObject(<span class="string">"money"</span>));</div><div class="line">	    &#125;</div><div class="line">		</div><div class="line">	    <span class="comment">//结果集的上一行数据</span></div><div class="line">	    <span class="keyword">if</span> (rs.previous())</div><div class="line">		System.out.println(rs.getObject(<span class="string">"id"</span>) + <span class="string">"\t"</span></div><div class="line">		    + rs.getObject(<span class="string">"name"</span>) + <span class="string">"\t"</span></div><div class="line">		    + rs.getObject(<span class="string">"birthday"</span>) + <span class="string">"\t"</span></div><div class="line">		    + rs.getObject(<span class="string">"money"</span>));</div><div class="line">	&#125; <span class="keyword">finally</span> &#123;</div><div class="line">	    JdbcUtils.free(rs, st, conn);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在读取数据的时候可以更新数据</p>
<p>可更新的结果集实例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readRs</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    Connection conn = <span class="keyword">null</span>;</div><div class="line">    Statement stat = <span class="keyword">null</span>;</div><div class="line">    ResultSet rs = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">	<span class="comment">//conn = JdbcUtils.getConnenction();</span></div><div class="line">	conn = JdbcUtilsSingleton.getInstance().getConnenction();</div><div class="line">	<span class="comment">//3.创建语句</span></div><div class="line">	stat = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);</div><div class="line">	<span class="comment">//4.执行语句</span></div><div class="line">	rs = stat.executeQuery(<span class="string">"select id,name,login_name,pass_word from USER where id&gt;2"</span>);</div><div class="line">	<span class="comment">//5.处理结果</span></div><div class="line">	<span class="keyword">while</span>(rs.next())&#123;</div><div class="line">    	    System.out.println(<span class="string">"id:"</span>+rs.getString(<span class="string">"id"</span>));</div><div class="line">	    System.out.println(<span class="string">"name:"</span>+rs.getString(<span class="string">"name"</span>));</div><div class="line">			</div><div class="line">	    <span class="comment">//更新数据：如果name=zhangsan,那么就更新name=zhangsan2014</span></div><div class="line">	    String name = rs.getString(<span class="string">"name"</span>);</div><div class="line">	    <span class="keyword">if</span>(<span class="string">"zhangsan"</span>.equals(name))&#123;</div><div class="line">		rs.updateString(<span class="string">"name"</span>, <span class="string">"zhangsan2014"</span>);</div><div class="line">                rs.updateRow();</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">    &#125;<span class="keyword">finally</span>&#123;</div><div class="line">	JdbcUtils.close(rs, stat, conn);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在实际开发中并不建议这样直接更新数据，因为不明确，不只管。还是建议写一条update的更新语句去更新数据。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jdbc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用JDBC调用存储过程，JDBC复习(二) ]]></title>
      <url>/2014/07/07/%E4%BD%BF%E7%94%A8JDBC%E8%B0%83%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%EF%BC%8CJDBC%E5%A4%8D%E4%B9%A0(%E4%BA%8C)/</url>
      <content type="html"><![CDATA[<p>当不直接使用SQL语句,而是调用数据库中的Store Procedure时,要用到<code>Callable Statement</code>，<code>CallabelStatement</code>从<code>PreparedStatement</code>继承。<br><a id="more"></a><br><strong>案例一：编写一个过程，可以学生名，新年龄，可修改学生的年龄</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">PROCEDURE</span> pro1(prname VARCHAR2,newage <span class="built_in">NUMBER</span>) <span class="keyword">IS</span></div><div class="line"><span class="keyword">BEGIN</span></div><div class="line">   <span class="keyword">UPDATE</span> tb_student <span class="keyword">SET</span> age=newage <span class="keyword">WHERE</span> <span class="keyword">name</span>=prname;</div><div class="line"><span class="keyword">END</span>;</div></pre></td></tr></table></figure></p>
<p>演示JAVA如何让调用Oracle的存储过程示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">callOracleProTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">	    <span class="comment">//1.加载驱动</span></div><div class="line">	    Class.forName(<span class="string">"oracle.jdbc.driver.OracleDriver"</span>);</div><div class="line">			</div><div class="line">	    <span class="comment">//2.得到连接</span></div><div class="line">	    Connection conn=DriverManager.getConnection(<span class="string">"jdbc:oracle:thin:@localhost:1521:ORCL"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</div><div class="line">			</div><div class="line">            <span class="comment">//3.创建CallableStatment</span></div><div class="line">	    CallableStatement call=conn.prepareCall(<span class="string">"&#123;call pro1(?,?)&#125;"</span>);</div><div class="line">			</div><div class="line">	    <span class="comment">//4.给？号赋值</span></div><div class="line">	    call.setString(<span class="number">1</span>,<span class="string">"小强"</span>);</div><div class="line">	    call.setInt(<span class="number">2</span>,<span class="number">30</span>);</div><div class="line">			</div><div class="line">	    <span class="comment">//5.执行</span></div><div class="line">	    call.execute();</div><div class="line">			</div><div class="line">	    <span class="comment">//6.关闭资源</span></div><div class="line">	    call.close();</div><div class="line">	    conn.close();</div><div class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">	    System.out.println(<span class="string">"出错了，程序异常，可能没导入JDBC驱动jar文件哦！"</span>);</div><div class="line">	    e.printStackTrace();</div><div class="line">	&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>案例二：有返回值的存储过程</strong></p>
<p>编写一个过程，可以输入学生的编号，返回该学生的地址，并用Java程序调用执行<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">PROCEDURE</span> pro2(v_ID <span class="keyword">IN</span> <span class="built_in">NUMBER</span>,v_address <span class="keyword">OUT</span> VARCHAR2) <span class="keyword">IS</span></div><div class="line"><span class="keyword">BEGIN</span></div><div class="line">   <span class="keyword">SELECT</span> address <span class="keyword">INTO</span> v_address <span class="keyword">FROM</span> tb_student <span class="keyword">WHERE</span> <span class="keyword">ID</span>=v_ID;</div><div class="line"><span class="keyword">END</span>;</div></pre></td></tr></table></figure></p>
<p>演示JAVA如何让调用Oracle带返回值的存储过程示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">callOracleReturnValueProcedure</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnOne</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">	Connection conn = getConnection();</div><div class="line">		</div><div class="line">	<span class="comment">//3.创建CallableStatment</span></div><div class="line">        CallableStatement call=conn.prepareCall(<span class="string">"&#123;call pro2(?,?)&#125;"</span>);</div><div class="line">		</div><div class="line">	<span class="comment">//4.给第一个？号赋值</span></div><div class="line">	call.setInt(<span class="number">1</span>,<span class="number">2</span>);</div><div class="line">	<span class="comment">//4.给第二个？号赋值</span></div><div class="line">	call.registerOutParameter(<span class="number">2</span>,oracle.jdbc.OracleTypes.CHAR);</div><div class="line">			</div><div class="line">	<span class="comment">//5.执行</span></div><div class="line">	call.execute();</div><div class="line">			</div><div class="line">	<span class="comment">//6.取出返回值，注意？号的顺序</span></div><div class="line">	String address=call.getString(<span class="number">2</span>);</div><div class="line">	System.out.println(<span class="string">"编号为2的学生的地址是："</span>+address);</div><div class="line">			</div><div class="line">	<span class="comment">//7.关闭资源</span></div><div class="line">	call.close();</div><div class="line">	conn.close();</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">	System.out.println(<span class="string">"出错了，程序异常，可能没导入JDBC驱动jar文件哦！"</span>);</div><div class="line">	e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>案例三：有返回值的存储过程（返回多个值）</strong></p>
<p>编写一个过程，可以输入学生的编号，返回该学生的地址，年龄，性别，并用Java程序调用执行。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">PROCEDURE</span> pro3(v_ID <span class="keyword">IN</span> <span class="built_in">NUMBER</span>,v_sex <span class="keyword">OUT</span> varchar2,v_age <span class="keyword">OUT</span> <span class="built_in">INT</span>, v_address <span class="keyword">OUT</span> VARCHAR2) <span class="keyword">IS</span></div><div class="line"><span class="keyword">BEGIN</span></div><div class="line">   <span class="keyword">SELECT</span> sex,age,address <span class="keyword">INTO</span> v_sex,v_age,v_address <span class="keyword">FROM</span> tb_student <span class="keyword">WHERE</span> <span class="keyword">ID</span>=v_ID;</div><div class="line"><span class="keyword">END</span>;</div></pre></td></tr></table></figure></p>
<p>我们在callOracleReturnValueProcedure类中继续添加方法。</p>
<p>演示有返回值的存储过程（返回多个值）:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnMore</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">	Connection conn=<span class="keyword">this</span>.getConnection();</div><div class="line">			</div><div class="line">	CallableStatement call=conn.prepareCall(<span class="string">"&#123;call pro3(?,?,?,?)&#125;"</span>);</div><div class="line">	</div><div class="line">	call.setInt(<span class="number">1</span>,<span class="number">2</span>);</div><div class="line">	call.registerOutParameter(<span class="number">2</span>,oracle.jdbc.OracleTypes.CHAR);</div><div class="line">	call.registerOutParameter(<span class="number">3</span>,oracle.jdbc.OracleTypes.INTEGER);</div><div class="line">	call.registerOutParameter(<span class="number">4</span>,oracle.jdbc.OracleTypes.CHAR);</div><div class="line">			</div><div class="line">	call.execute();</div><div class="line">			</div><div class="line">	String sex=call.getString(<span class="number">2</span>);</div><div class="line">	<span class="keyword">int</span> age=call.getInt(<span class="number">3</span>);</div><div class="line">	String address=call.getString(<span class="number">4</span>);</div><div class="line">			</div><div class="line">	System.out.println(<span class="string">"编号为2的学生性别是："</span>+sex);</div><div class="line">	System.out.println(<span class="string">"编号为2的学生年龄是："</span>+age);</div><div class="line">	System.out.println(<span class="string">"编号为2的学生地址是："</span>+address);</div><div class="line">			</div><div class="line">	call.close();</div><div class="line">	conn.close();</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">	<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">	e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>案例四：返回结果集的存储过程</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">PROCEDURE</span> pro4(v_type <span class="keyword">IN</span> VARCHAR2,p_cur <span class="keyword">OUT</span> mypackage.my_cur) <span class="keyword">IS</span></div><div class="line"><span class="keyword">BEGIN</span></div><div class="line">  <span class="keyword">OPEN</span> p_cur <span class="keyword">FOR</span></div><div class="line">     <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tb_prod <span class="keyword">WHERE</span> <span class="keyword">TYPE</span>=v_type;</div><div class="line"><span class="keyword">END</span>;</div></pre></td></tr></table></figure></p>
<p>演示返回结果集的存储过程:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnResultSet</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">	Connection conn=<span class="keyword">this</span>.getConnection();</div><div class="line">	CallableStatement call=conn.prepareCall(<span class="string">"&#123;call pro4(?,?)&#125;"</span>);</div><div class="line">			</div><div class="line">	call.setString(<span class="number">1</span>,<span class="string">"笔记本"</span>);</div><div class="line">	call.registerOutParameter(<span class="number">2</span>,oracle.jdbc.OracleTypes.CURSOR);</div><div class="line">			</div><div class="line">	call.execute();</div><div class="line">	<span class="comment">//得到结果集</span></div><div class="line">	ResultSet rs=(ResultSet)call.getObject(<span class="number">2</span>);</div><div class="line">	<span class="keyword">while</span>(rs.next())&#123;</div><div class="line">    	    System.out.println(<span class="string">"ID:"</span>+rs.getInt(<span class="number">1</span>)+<span class="string">" type:"</span>+rs.getString(<span class="number">2</span>)+<span class="string">" mark:"</span>+rs.getString(<span class="number">3</span>)+<span class="string">" spec:"</span>+rs.getString(<span class="number">4</span>));</div><div class="line">	&#125;</div><div class="line">			</div><div class="line">	call.close();</div><div class="line">	conn.close();</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">	<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">	e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>案例五，编写一个分页的存储过程</strong></p>
<p>要求：输入表名，每页显示的记录数，当前页,返回总记录数、总页数、结果集<br>定义一个包，建立游标：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">PACKAGE</span> mypackage <span class="keyword">AS</span> <span class="keyword">TYPE</span> my_cur <span class="keyword">IS</span> <span class="keyword">REF</span> <span class="keyword">CURSOR</span>;</div></pre></td></tr></table></figure></p>
<p>建立存储过程如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function">CREATE OR REPLACE PROCEDURE <span class="title">fenye</span><span class="params">(</span></span></div><div class="line">     tableName IN VARCHAR2,        --表名</div><div class="line">     pageSize IN NUMBER,           --每页显示的记录数</div><div class="line">     pageNow IN NUMBER,            --当前页</div><div class="line">     rowsCount OUT NUMBER,         --总记录数</div><div class="line">     pageCount OUT NUMBER,         --总页数</div><div class="line">     page_cur OUT mypackage.my_cur --结果集的游标</div><div class="line">) IS</div><div class="line">--定义一个变量拼接分页SQL语句</div><div class="line">v_sql <span class="title">VARCHAR2</span><span class="params">(<span class="number">1000</span>)</span>;</div><div class="line">--定义两个整数，计算起始页和终止页</div><div class="line">v_begin NUMBER:=(pageNow-<span class="number">1</span>)*pageSize+<span class="number">1</span>;</div><div class="line">v_end NUMBER:=pageNow*pageSize;</div><div class="line">BEGIN</div><div class="line">    --执行</div><div class="line">    v_sql:=<span class="string">'SELECT * FROM (SELECT t.*,ROWNUM rn FROM (SELECT * FROM '</span>||tableName||<span class="string">') t WHERE ROWNUM&lt;='</span>||v_end||<span class="string">') WHERE rn&gt;='</span>||v_begin||;</div><div class="line">    --打开游标，把游标和sql关联起来</div><div class="line">    OPEN page_cur FOR v_sql;</div><div class="line">    --组织一个SQL，计算总记录数(rowsCount)和总页数(pageCount)</div><div class="line">    v_sql:=<span class="string">'select count(*) from'</span>||tableName;</div><div class="line">    --执行SQL,并把返回的结果赋值给rowsCount(总记录数)</div><div class="line">    EXECUTE IMMEDIATE v_sql INTO rowsCount;</div><div class="line">    --计算总页数(pageCount)</div><div class="line">    <span class="function">IF <span class="title">MOD</span><span class="params">(rowsCount,pageSize)</span></span>=<span class="number">0</span> THEN</div><div class="line">    	pageCount:=rowsCount/pageSize;</div><div class="line">    ELSE</div><div class="line">    	pageCount:=rowsCount/pageSize+<span class="number">1</span>;</div><div class="line">    END IF;</div><div class="line">    --关闭游标</div><div class="line">    --CLOSE page_cur;</div><div class="line">END;</div></pre></td></tr></table></figure></p>
<p>调用存储过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">	<span class="comment">//1.加载驱动</span></div><div class="line">	Class.forName(<span class="string">"oracle.jdbc.driver.OracleDriver"</span>);</div><div class="line">	<span class="comment">//2.得到连接</span></div><div class="line">	Connection conn=DriverManager.getConnection(<span class="string">"jdbc:oracle:thin:@localhost:1521:ORCL"</span>, <span class="string">"scott"</span>, <span class="string">"scott"</span>);</div><div class="line">			</div><div class="line">	CallableStatement call=conn.prepareCall(<span class="string">"&#123;call fenye(?,?,?,?,?,?)&#125;"</span>);</div><div class="line">        <span class="comment">//给输入参数?号赋值</span></div><div class="line">	call.setString(<span class="number">1</span>,<span class="string">"emp"</span>);	<span class="comment">//查询哪个表</span></div><div class="line">	call.setInt(<span class="number">2</span>,<span class="number">5</span>);			<span class="comment">//要显示几页</span></div><div class="line">	call.setInt(<span class="number">3</span>,<span class="number">1</span>);			<span class="comment">//从第几页开始显示</span></div><div class="line">	</div><div class="line">	<span class="comment">//给输出参数？号赋值</span></div><div class="line">	call.registerOutParameter(<span class="number">4</span>, oracle.jdbc.OracleTypes.INTEGER);	<span class="comment">//接收总记录数</span></div><div class="line">	call.registerOutParameter(<span class="number">5</span>, oracle.jdbc.OracleTypes.INTEGER);	<span class="comment">//接收总页数</span></div><div class="line">	call.registerOutParameter(<span class="number">6</span>, oracle.jdbc.OracleTypes.CURSOR);	<span class="comment">//接收结果集</span></div><div class="line">			</div><div class="line">	call.execute();</div><div class="line">			</div><div class="line">	<span class="keyword">int</span> rowCount=call.getInt(<span class="number">4</span>);	<span class="comment">//取出总记录数</span></div><div class="line">        <span class="keyword">int</span> pageCount=call.getInt(<span class="number">5</span>);	<span class="comment">//取出总页数</span></div><div class="line">	ResultSet rs=(ResultSet)call.getObject(<span class="number">6</span>);	<span class="comment">//取出结果集</span></div><div class="line">			</div><div class="line">	<span class="comment">//显示一下看对不对</span></div><div class="line">	System.out.println(<span class="string">"总记录数:"</span>+rowCount);</div><div class="line">	System.out.println(<span class="string">"总页数:"</span>+pageCount);</div><div class="line">	<span class="keyword">while</span>(rs.next())&#123;</div><div class="line">    	    System.out.println(<span class="string">"编号:"</span>+rs.getInt(<span class="number">1</span>)+<span class="string">" 名字:"</span>+rs.getString(<span class="number">2</span>)+<span class="string">" 职位:"</span>+rs.getString(<span class="number">3</span>));	</div><div class="line">        &#125;</div><div class="line">			</div><div class="line">	call.close();</div><div class="line">	conn.close();</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">	<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">	e.printStackTrace();</div><div class="line">    &#125;		</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javase </tag>
            
            <tag> jdbc </tag>
            
            <tag> 存储过程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JDBC编程与SQL注入、大数据、事物处理，JDBC复习(一) ]]></title>
      <url>/2014/07/06/JDBC%E7%BC%96%E7%A8%8B%E4%B8%8ESQL%E6%B3%A8%E5%85%A5%E3%80%81%E5%A4%A7%E6%95%B0%E6%8D%AE%E3%80%81%E4%BA%8B%E7%89%A9%E5%A4%84%E7%90%86%EF%BC%8CJDBC%E5%A4%8D%E4%B9%A0(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<p><a href="./#一、什么是JDBC">一、什么是JDBC</a><br><a href="./#二、JDBC驱动">二、JDBC驱动</a><br><a href="./#三、数据库驱动">三、数据库驱动</a><br><a href="./#四、应用程序、JDBC API、数据库驱动及数据库之间的关系">四、应用程序、JDBC API、数据库驱动及数据库之间的关系</a><br><a href="./#五、连接数据库的6步骤">五、连接数据库的6步骤</a><br><a href="./#六、规范和封装JDBC代码">六、规范和封装JDBC代码</a><br><a href="./#七、对数据库进行CRUD操作">七、对数据库进行CRUD操作</a><br><a href="./#八、Statement的SQL注入问题">八、Statement的SQL注入问题</a><br><a href="./#九、使用JDBC处理数据">九、使用JDBC处理数据</a><br><a href="./#十、JDBC事物处理">十、JDBC事物处理</a><br><a id="more"></a></p>
<h2 id="一、什么是JDBC"><a href="#一、什么是JDBC" class="headerlink" title="一、什么是JDBC"></a>一、什么是JDBC</h2><ol>
<li>SUN公司为统一对数据库的操作，定义了一套Java操作数据库的规范，称之为JDBC。</li>
<li>JDBC 是一种用于执行SQL 语句的 Java API.是 Java DataBase java数据库连接)的缩写. </li>
<li>它由一组用 java编程语言编写的类和接口组成. JDBC 为工具/数据库开发人员提供了一个标准的API,使得他们能够用纯 Java API 来编写数据库应用程序.</li>
<li>J2SE的一部分，由java.sql,javax.sql包组成。</li>
</ol>
<p>开发JDBC应用需要：</p>
<ol>
<li>java.sql和javax.sql2个包的支持外，</li>
<li>还需要导入相应JDBC的数据库实现(即数据库驱动)。</li>
</ol>
<h2 id="二、JDBC驱动"><a href="#二、JDBC驱动" class="headerlink" title="二、JDBC驱动"></a>二、JDBC驱动</h2><h3 id="2-1-JDBC-ODBC桥"><a href="#2-1-JDBC-ODBC桥" class="headerlink" title="2.1 JDBC-ODBC桥"></a>2.1 JDBC-ODBC桥</h3><p>由ODBC驱动提供JDBC访问 ODBC(Open Database Connectivity，开放数据库连接)是微软公司开放服务结构中有关数据库的一个组成部分，它建立了一组规范，并提供了一组对数据库访问的的标准API</p>
<p>缺点： 要求客户端必须安装ODBC驱动 执行效率比较低,对于那些大数据量存取的应用是不适合的 适用于快速的原型系统，没有提供JDBC驱动的数据库如Access</p>
<h3 id="2-2-纯Java类库"><a href="#2-2-纯Java类库" class="headerlink" title="2.2 纯Java类库"></a>2.2 纯Java类库</h3><p>他将JDBC 请求直接翻译成为特定的数据库协议。这种驱动直接把JDBC调用转换为符合相关数据库系统规范的请求。 最高的性能，通过自己的本地协议直接与数据库引擎通信</p>
<p>特点：适合那些连接单一或多个数据库的工作组应用。</p>
<h2 id="三、数据库驱动"><a href="#三、数据库驱动" class="headerlink" title="三、数据库驱动"></a>三、数据库驱动</h2><p>1）数据库厂商提供的实现接口</p>
<p>2）应用程序实现的编程接口 JDBC制定标准；数据厂商实现标准；用户使用标准。 </p>
<p>一个JDBC驱动程序的实现：</p>
<ul>
<li>在一个静态代码段中生成自己的一个实例</li>
<li>当系统调用它的构造方法时，它会向driver manger进行注册</li>
</ul>
<h2 id="四、应用程序、JDBC-API、数据库驱动及数据库之间的关系"><a href="#四、应用程序、JDBC-API、数据库驱动及数据库之间的关系" class="headerlink" title="四、应用程序、JDBC API、数据库驱动及数据库之间的关系"></a>四、应用程序、JDBC API、数据库驱动及数据库之间的关系</h2><p><img src="http://img1.ph.126.net/W8X6UYnbh3Z0Jl3fQ6vEwA==/6608410129586287978.jpg" alt=""></p>
<h2 id="五、连接数据库的6步骤"><a href="#五、连接数据库的6步骤" class="headerlink" title="五、连接数据库的6步骤"></a>五、连接数据库的6步骤</h2><p>1）注册驱动 (只做一次)<br>2）建立连接(Connection)<br>3）创建执行SQL的语句(Statement)<br>4）执行语句<br>5）处理执行结果(ResultSet)<br>6）释放资源  </p>
<p>下面我就依照上面六个步骤来写一个示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>&#123;</div><div class="line">    <span class="comment">//1.注册驱动</span></div><div class="line">    DriverManager.registerDriver(<span class="keyword">new</span> com.mysql.jdbc.Driver());</div><div class="line">    <span class="comment">//2.建立连接</span></div><div class="line">    Connection conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/test"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</div><div class="line">    <span class="comment">//3.创建语句</span></div><div class="line">    Statement st = conn.createStatement();</div><div class="line">    <span class="comment">//4.执行语句</span></div><div class="line">    ResultSet rs = st.executeQuery(<span class="string">"select * from oa_id_user"</span>);</div><div class="line">    <span class="comment">//6.处理结果</span></div><div class="line">    <span class="keyword">while</span>(rs.next())&#123;</div><div class="line">	System.out.println(<span class="string">"user_id:"</span>+rs.getString(<span class="string">"user_id"</span>));</div><div class="line">	System.out.println(<span class="string">"name:"</span>+rs.getString(<span class="string">"name"</span>));</div><div class="line">	System.out.println(<span class="string">"pass_word:"</span>+rs.getString(<span class="string">"pass_word"</span>));</div><div class="line">	System.out.println(<span class="string">"phone:"</span>+rs.getString(<span class="string">"phone"</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//7.释放资源</span></div><div class="line">    rs.close();</div><div class="line">    st.close();</div><div class="line">    conn.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，暂时不考虑其他代码优化性的东西，只是简单实现结果，我们这个代码其实是有很多问题的，比如关闭连接、异常的处理等，在后面会依次对6个步骤进行详细讲解。并在此基础上逐步优化代码。</p>
<h3 id="5-1-注册驱动（Driver）"><a href="#5-1-注册驱动（Driver）" class="headerlink" title="5.1 注册驱动（Driver）"></a>5.1 注册驱动（Driver）</h3><p>Driver是一个接口，每个驱动程序类都必须实现这个接口</p>
<ul>
<li>Class.forName(“com.mysql.jdbc.Driver”);推荐这种方式，采用此种方式，程序仅仅只需要一个字符串，不需要import驱动的API，这样可使程序不依赖具体的驱动，使程序的灵活性更高。 </li>
<li>DriverManager.registerDriver(com.mysql.jdbc.Driver);会造成DriverManager中产生两个一样的驱动，并会对具体的驱动类产生依赖。 注意：在实际开发中，并不推荐采用这个方法注册驱动。</li>
<li>System.setProperty(“jdbc.drivers”, “driver1:driver2”);虽然不会对具体的驱动类产生依赖；但注册不太方便，所以很少使用。 根据url获取数据库的连接。如果能建立连接，则返回一个Connection对象，Connection对象代表与一个特定数据库的会话过程。</li>
<li>驱动类型(四种类型)</li>
</ul>
<h3 id="5-2-建立连接（Connection）"><a href="#5-2-建立连接（Connection）" class="headerlink" title="5.2 建立连接（Connection）"></a>5.2 建立连接（Connection）</h3><p>JDBC程序中的Connection，它用于代表数据库的连接，Collection是数据库编程中最重要的一个对象，客户端与数据库所有交互都是通过connection对象完成的，这个对象的常用方法：</p>
<ul>
<li>createStatement()：创建向数据库发送sql的statement对象。</li>
<li>prepareStatement(sql) ：创建向数据库发送预编译sql的PrepareSatement对象。</li>
<li>prepareCall(sql)：创建执行存储过程的callableStatement对象。</li>
<li>setAutoCommit(boolean autoCommit)：设置事务是否自动提交。</li>
<li>commit() ：在链接上提交事务。</li>
<li>rollback() ：在此链接上回滚事务</li>
</ul>
<p>Connection conn = DriverManager.getConnection(url, user, password); </p>
<ul>
<li>url格式：JDBC:子协议:子名称//主机名:端口/数据库名？属性名=属性值&amp;… </li>
<li>User,password可以用“属性名=属性值”方式告诉数据库； </li>
<li>其他参数如：useUnicode=true&amp;characterEncoding=GBK。</li>
</ul>
<h3 id="5-3-创建和执行SQL的语句-Statement"><a href="#5-3-创建和执行SQL的语句-Statement" class="headerlink" title="5.3 创建和执行SQL的语句(Statement)"></a>5.3 创建和执行SQL的语句(Statement)</h3><p>JDBC程序中的Statement对象用于向数据库发送SQL语句， Statement对象常用方法：</p>
<ul>
<li>execute(String sql)：用于向数据库发送任意sql语句</li>
<li>executeQuery(String sql) ：只能向数据发送select语句。</li>
<li>executeUpdate(String sql)：只能向数据库发送insert、update或delete语句</li>
<li>addBatch(String sql) ：把多条sql语句放到一个批处理中。</li>
<li>executeBatch()：向数据库发送一批sql语句执行。</li>
<li>clearBatch()：清空缓冲</li>
</ul>
<h3 id="5-4-处理结果（ResultSet）"><a href="#5-4-处理结果（ResultSet）" class="headerlink" title="5.4 处理结果（ResultSet）"></a>5.4 处理结果（ResultSet）</h3><p>JDBC程序中的ResultSet用于代表Sql语句的执行结果。Resultset封装执行结果时，采用的类似于表格的方式。ResultSet 对象维护了一个指向表格数据行的游标，初始的时候，游标在第一行之前，调用ResultSet.next() 方法，可以使游标指向具体的数据行，进行调用方法获取该行的数据。</p>
<p>ResultSet既然用于封装执行结果的，所以该对象提供的都是用于获取数据的get方法：</p>
<p><strong>获取任意类型的数据</strong><br>getObject(int index)<br>getObject(string columnName)  </p>
<p><strong>获取指定类型的数据，例如：</strong><br>getString(int index)<br>getString(String columnName)  </p>
<p><strong>ResultSet还提供了对结果集进行滚动的方法：</strong><br>next()：移动到下一行<br>previous()：移动到前一行<br>absolute(int row)：移动到指定行<br>beforeFirst()：移动resultSet的最前面。<br>afterLast() ：移动到resultSet的最后面。</p>
<h3 id="5-5-释放资源"><a href="#5-5-释放资源" class="headerlink" title="5.5 释放资源"></a>5.5 释放资源</h3><p>释放ResultSet, Statement,Connection. </p>
<p>数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放。</p>
<h2 id="六、规范和封装JDBC代码"><a href="#六、规范和封装JDBC代码" class="headerlink" title="六、规范和封装JDBC代码"></a>六、规范和封装JDBC代码</h2><p>我们来规范和封装前面所写的[程序1]代码，把注册驱动、建立连接、关闭资源封装成一个工具类jdbcUtils，建立一个机遇单例设计模式的jdbcUtils类，使用final修饰类，确保是一个不可变类；在static代码块中写注册驱动，因为注册驱动只需要注册一次就可以了。</p>
<p>jdbcUtils.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcUtilsSingleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url = <span class="string">"jdbc:mysql://localhost:3306/test"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user = <span class="string">"root"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password = <span class="string">"root"</span>;</div><div class="line">	</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JdbcUtilsSingleton</span><span class="params">()</span></span>&#123;&#125;;</div><div class="line">	</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JdbcUtilsSingleton instance = <span class="keyword">null</span>;</div><div class="line">	</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JdbcUtilsSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">    	<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">synchronized</span> (JdbcUtilsSingleton.class) &#123;</div><div class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">                        instance = <span class="keyword">new</span> JdbcUtilsSingleton();</div><div class="line">                &#125;</div><div class="line">	        &#125;</div><div class="line">	    &#125;</div><div class="line">	    <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">    <span class="comment">//1.注册驱动</span></div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">    	<span class="keyword">try</span> &#123;</div><div class="line">	        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</div><div class="line">	    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">	        <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(e);</div><div class="line">	    &#125;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">    <span class="comment">//2.获得连接</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnenction</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>&#123;</div><div class="line">	    <span class="keyword">return</span> DriverManager.getConnection(url, user, password);</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">    <span class="comment">//6.关闭资源</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet rs,Statement stat,Connection conn)</span></span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span>(rs!=<span class="keyword">null</span>)rs.close();</div><div class="line">        &#125;<span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></div><div class="line">        &#125;<span class="keyword">finally</span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span>(stat!=<span class="keyword">null</span>)stat.close();</div><div class="line">            &#125;<span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">                <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></div><div class="line">            &#125;<span class="keyword">finally</span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)conn.close();</div><div class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后我们一个测试方法进行调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">template</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    Connection conn = <span class="keyword">null</span>;</div><div class="line">    Statement stat = <span class="keyword">null</span>;</div><div class="line">    ResultSet rs = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//conn = JdbcUtils.getConnenction();</span></div><div class="line">        conn = JdbcUtilsSingleton.getInstance().getConnenction();</div><div class="line">        <span class="comment">//3.创建语句</span></div><div class="line">        stat = conn.createStatement();</div><div class="line">        <span class="comment">//4.执行语句</span></div><div class="line">        rs = stat.executeQuery(<span class="string">"select * from oa_id_user"</span>);</div><div class="line">        <span class="comment">//5.处理结果</span></div><div class="line">        <span class="keyword">while</span>(rs.next())</div><div class="line">            System.out.println(<span class="string">"user_id:"</span>+rs.getString(<span class="string">"user_id"</span>));</div><div class="line">            System.out.println(<span class="string">"name:"</span>+rs.getString(<span class="string">"name"</span>));</div><div class="line">            System.out.println(<span class="string">"pass_word:"</span>+rs.getString(<span class="string">"pass_word"</span>));</div><div class="line">            System.out.println(<span class="string">"phone:"</span>+rs.getString(<span class="string">"phone"</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;<span class="keyword">finally</span>&#123;</div><div class="line">	    JdbcUtils.close(rs, stat, conn);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="七、对数据库进行CRUD操作"><a href="#七、对数据库进行CRUD操作" class="headerlink" title="七、对数据库进行CRUD操作"></a>七、对数据库进行CRUD操作</h2><p>CRUD操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="comment">//read();</span></div><div class="line">    <span class="comment">//create();</span></div><div class="line">    <span class="comment">//update();</span></div><div class="line">    delete();</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">	Connection conn = <span class="keyword">null</span>;</div><div class="line">	Statement stat = <span class="keyword">null</span>;</div><div class="line">	ResultSet rs = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">	    <span class="comment">//conn = JdbcUtils.getConnenction();</span></div><div class="line">	    conn = JdbcUtilsSingleton.getInstance().getConnenction();</div><div class="line">	    <span class="comment">//3.创建语句</span></div><div class="line">	    stat = conn.createStatement();</div><div class="line">	    <span class="comment">//4.执行语句</span></div><div class="line">	    String sql = <span class="string">"insert into user(id,name,login_name,pass_word,sex) values('3','zhangsan','zhangsan','123456',1)"</span>;</div><div class="line">	    <span class="keyword">int</span> i = stat.executeUpdate(sql);</div><div class="line">	    <span class="comment">//5.处理结果</span></div><div class="line">	    System.out.println(<span class="string">"i="</span>+i);</div><div class="line">    &#125;<span class="keyword">finally</span>&#123;</div><div class="line">        JdbcUtils.close(rs, stat, conn);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    Connection conn = <span class="keyword">null</span>;</div><div class="line">    Statement stat = <span class="keyword">null</span>;</div><div class="line">    ResultSet rs = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//conn = JdbcUtils.getConnenction();</span></div><div class="line">        conn = JdbcUtilsSingleton.getInstance().getConnenction();</div><div class="line">        <span class="comment">//3.创建语句</span></div><div class="line">        stat = conn.createStatement();</div><div class="line">        <span class="comment">//4.执行语句</span></div><div class="line">        rs = stat.executeQuery(<span class="string">"select id,name,login_name,pass_word from USER"</span>);</div><div class="line">        <span class="comment">//5.处理结果</span></div><div class="line">        <span class="keyword">while</span>(rs.next())&#123;</div><div class="line">            System.out.println(<span class="string">"id:"</span>+rs.getString(<span class="string">"id"</span>));</div><div class="line">            System.out.println(<span class="string">"name:"</span>+rs.getString(<span class="string">"name"</span>));</div><div class="line">            System.out.println(<span class="string">"pass_word:"</span>+rs.getString(<span class="string">"pass_word"</span>));</div><div class="line">            System.out.println(<span class="string">"login_name:"</span>+rs.getString(<span class="string">"login_name"</span>));</div><div class="line">	    &#125;</div><div class="line">    &#125;<span class="keyword">finally</span>&#123;</div><div class="line">	    JdbcUtils.close(rs, stat, conn);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    Connection conn = <span class="keyword">null</span>;</div><div class="line">    Statement stat = <span class="keyword">null</span>;</div><div class="line">    ResultSet rs = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//conn = JdbcUtils.getConnenction();</span></div><div class="line">        conn = JdbcUtilsSingleton.getInstance().getConnenction();</div><div class="line">        <span class="comment">//3.创建语句</span></div><div class="line">        stat = conn.createStatement();</div><div class="line">        <span class="comment">//4.执行语句</span></div><div class="line">        String sql = <span class="string">"update user set sex=2 where sex=1"</span>;</div><div class="line">        <span class="keyword">int</span> i = stat.executeUpdate(sql);</div><div class="line">        <span class="comment">//5.处理结果</span></div><div class="line">        System.out.println(<span class="string">"i="</span>+i);</div><div class="line">    &#125;<span class="keyword">finally</span>&#123;</div><div class="line">	    JdbcUtils.close(rs, stat, conn);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    Connection conn = <span class="keyword">null</span>;</div><div class="line">    Statement stat = <span class="keyword">null</span>;</div><div class="line">    ResultSet rs = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//conn = JdbcUtils.getConnenction();</span></div><div class="line">        conn = JdbcUtilsSingleton.getInstance().getConnenction();</div><div class="line">        <span class="comment">//3.创建语句</span></div><div class="line">        stat = conn.createStatement();</div><div class="line">        <span class="comment">//4.执行语句</span></div><div class="line">        String sql = <span class="string">"delete from user where sex=1"</span>;</div><div class="line">        <span class="keyword">int</span> i = stat.executeUpdate(sql);</div><div class="line">        <span class="comment">//5.处理结果</span></div><div class="line">        System.out.println(<span class="string">"i="</span>+i);</div><div class="line">    &#125;<span class="keyword">finally</span>&#123;</div><div class="line">	    JdbcUtils.close(rs, stat, conn);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="八、Statement的SQL注入问题"><a href="#八、Statement的SQL注入问题" class="headerlink" title="八、Statement的SQL注入问题"></a>八、Statement的SQL注入问题</h2><p><strong>1、什么是PreparedStatement？</strong><br>预编译语句PreparedStatement 是java.sql中的一个接口，它是Statement的子接口。通过Statement对象执行SQL语句时，需要将SQL语句发送给DBMS，由DBMS首先进行编译后再执行。PreperedStatement（从Statement扩展而来）。</p>
<p><strong>2、SQL注入</strong><br>在SQL中包含特殊字符或SQL的关键字(如：<code>&#39; or 1 or &#39;</code>)时Statement将出现不可预料的结果（出现异常或查询的结果不正确），可用PreparedStatement来解决。</p>
<p><strong>3、使用它有什么好处？</strong><br>预编译语句和Statement不同，在创建PreparedStatement 对象时就指定了SQL语句，正常情况下，当你向数据库提交SQL语句后，数据库要对这条语句进行编译，例如语法分析、优化路径选择、分配资源等一系列操作，这是需要时间的。而使用PreparedStatement接口，数据库只需要编译一次，其他只是更改参数就可以了。 所以，当你向数据库中进行批量操作的时候，预编译效率比较高。 另外，Statement会使数据库频繁编译SQL，可能造成数据库缓冲区溢出。</p>
<p>相对于Statement对象而言：</p>
<ul>
<li>提高效率。<br>当需要对数据库进行数据插入、更新或者删除的时候，程序会发送整个SQL语句给数据库处理和执行。数据库处理一个SQL语句，需要完成解析SQL语句、检查语法和语义以及生成代码；一般说来，处理时间要比执行语句所需要的时间长。 PreparedStatement可以尽可能的提高访问数据库的性能，数据库在处理SQL语句时都有一个预编译的过程，而预编译对象就是把一些格式固定的SQL编译后，存放在内存池中即数据库缓冲池，当我们再次执行相同的SQL语句时就不需要编译的了，只需DBMS运行SQL语句。所以当你需要执行Statement对象多次的时候，PreparedStatement对象将会大大降低运行时间，特别是的大型的数据库中，它可以有效的也加快了访问数据库的速度。</li>
<li>提高安全性。PreperedStatement可以避免SQL注入的问题。</li>
<li>更加灵活。PreperedStatement对于sql中的参数，允许使用占位符(?)的形式进行替换，简化sql语句的编写。</li>
</ul>
<p>下面我写一个使用PreperedStatement方式的程序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 使用预编译的PreparedStatementSQL语句</div><div class="line"> * <span class="doctag">@param</span> login_name</div><div class="line"> * <span class="doctag">@throws</span> Exception</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read2</span><span class="params">(String login_name)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    Connection conn = <span class="keyword">null</span>;</div><div class="line">    PreparedStatement ps = <span class="keyword">null</span>;</div><div class="line">    ResultSet rs = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//conn = JdbcUtils.getConnenction();</span></div><div class="line">        conn = JdbcUtilsSingleton.getInstance().getConnenction();</div><div class="line">        <span class="comment">//3.创建语句</span></div><div class="line">        String sql = <span class="string">"select id,name,login_name,pass_word from USER where login_name=?"</span>;</div><div class="line">	    ps = conn.prepareStatement(sql);</div><div class="line">	    <span class="comment">//设置参数</span></div><div class="line">	    ps.setString(<span class="number">1</span>, login_name);</div><div class="line">	    <span class="comment">//4.执行语句，千万记住不要再给executeQuery()sql参数了</span></div><div class="line">	    rs = ps.executeQuery();</div><div class="line">	    <span class="comment">//5.处理结果</span></div><div class="line">	    <span class="keyword">while</span>(rs.next())&#123;</div><div class="line">            System.out.println(<span class="string">"id:"</span>+rs.getString(<span class="string">"id"</span>));</div><div class="line">            System.out.println(<span class="string">"name:"</span>+rs.getString(<span class="string">"name"</span>));</div><div class="line">	    &#125;</div><div class="line">      &#125;<span class="keyword">finally</span>&#123;</div><div class="line">          JdbcUtils.close(rs, ps, conn);</div><div class="line">      &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    read2(<span class="string">"admin"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="九、使用JDBC处理数据"><a href="#九、使用JDBC处理数据" class="headerlink" title="九、使用JDBC处理数据"></a>九、使用JDBC处理数据</h2><p>详细信息见java.sql.Types </p>
<p>几种特殊且比较常用的类型：  </p>
<ol>
<li>DATA,TIME,TIMESTAMP → date,time,datetime<br>存：ps.setDate(i,d); ps.setTime(i,t); ps.setTimestamp(i, ts);<br>取：rs.getDate(i); rs.getTime(i); rs.getTimestamp(i);     </li>
<li>CLOB → text<br>存：ps.setCharacterStream(index, reader, length); ps.setString(i, s);<br>取：reader = rs. getCharacterStream(i);reader = rs.getClob(i).getCharacterStream();string = rs.getString(i);     </li>
<li>BLOB → blob<br>存：ps.setBinaryStream(i, inputStream, length);<br>取：rs.getBinaryStream(i);rs.getBlob(i).getBinaryStream();</li>
</ol>
<h3 id="9-1-CLOB（Text）"><a href="#9-1-CLOB（Text）" class="headerlink" title="9.1 CLOB（Text）"></a>9.1 CLOB（Text）</h3><p>我们新建一个测试表：clob_text:<br><img src="http://img1.ph.126.net/IHo8eEw6bYxGakhajqSXyA==/6608903810306050402.png" alt=""></p>
<p>那么怎么插入一条带Clob数据呢？其实就是IO操作。。。</p>
<p>插入clob字段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    Connection conn = <span class="keyword">null</span>;</div><div class="line">    PreparedStatement ps = <span class="keyword">null</span>;</div><div class="line">    ResultSet rs = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        conn = JdbcUtilsSingleton.getInstance().getConnenction();</div><div class="line">        String sql = <span class="string">"insert into clob_text(id,news) values('1',?)"</span>;</div><div class="line">        ps = conn.prepareStatement(sql);</div><div class="line">	</div><div class="line">        <span class="comment">//处理clob字段	</span></div><div class="line">	    <span class="function">ew <span class="title">File</span><span class="params">(<span class="string">"src/com/ideal/jdbc/JdbcUtils.java"</span>)</span></span>;</div><div class="line">        Reader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file));</div><div class="line">	    ps.setCharacterStream(<span class="number">1</span>, reader, file.length());</div><div class="line">		</div><div class="line">        <span class="keyword">int</span> i = ps.executeUpdate();</div><div class="line">        reader.close();</div><div class="line">	</div><div class="line">        <span class="comment">//5.处理结果</span></div><div class="line">        System.out.println(<span class="string">"i="</span>+i);</div><div class="line">    &#125;<span class="keyword">finally</span>&#123;</div><div class="line">        JdbcUtils.close(rs, ps, conn);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>查询、读取clob字段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    Connection conn = <span class="keyword">null</span>;</div><div class="line">    Statement st = <span class="keyword">null</span>;</div><div class="line">    ResultSet rs = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        conn = JdbcUtilsSingleton.getInstance().getConnenction();</div><div class="line">        st = conn.createStatement();</div><div class="line">        String sql = <span class="string">"select id,news from clob_text"</span>;</div><div class="line">        rs = st.executeQuery(sql);</div><div class="line">		</div><div class="line">        <span class="comment">//处理clob结果</span></div><div class="line">        <span class="keyword">while</span>(rs.next())&#123;</div><div class="line">            Clob clob = rs.getClob(<span class="string">"news"</span>);</div><div class="line">            Reader reader = clob.getCharacterStream();</div><div class="line">                </div><div class="line">            File file = <span class="keyword">new</span> File(<span class="string">"JdbcUtils_bak.java"</span>);</div><div class="line">            Writer writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(file));</div><div class="line">            <span class="keyword">char</span>[] buff = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; (i = reader.read(buff)) &gt; <span class="number">0</span>;) &#123;</div><div class="line">                writer.write(buff, <span class="number">0</span>, i);</div><div class="line">            &#125;</div><div class="line">            writer.close();</div><div class="line">            reader.close();</div><div class="line">        &#125;</div><div class="line">    &#125;<span class="keyword">finally</span>&#123;</div><div class="line">	    JdbcUtils.close(rs, st, conn);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行后刷新工程，既可以看到跟目下有一个<code>JdbcUtils_bak.java</code>文件了。</p>
<h3 id="9-2-BLOB（二进制数据）"><a href="#9-2-BLOB（二进制数据）" class="headerlink" title="9.2 BLOB（二进制数据）"></a>9.2 BLOB（二进制数据）</h3><p>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。BLOB类型实际是个类型系列（TinyBlob、Blob、MediumBlob、LongBlob），除了在存储的最大信息量上不同外，他们是等同的。</p>
<p>插入blob字段:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> <span class="keyword">throws</span> SQLException, IOException </span>&#123;</div><div class="line">    Connection conn = <span class="keyword">null</span>;</div><div class="line">    PreparedStatement ps = <span class="keyword">null</span>;</div><div class="line">    ResultSet rs = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 2.建立连接</span></div><div class="line">        conn = JdbcUtils.getConnection();</div><div class="line">        <span class="comment">// conn = JdbcUtilsSing.getInstance().getConnection();</span></div><div class="line">        <span class="comment">// 3.创建语句</span></div><div class="line">        String sql = <span class="string">"insert into blob_test(big_bit) values (?) "</span>;</div><div class="line">        ps = conn.prepareStatement(sql);</div><div class="line">        File file = <span class="keyword">new</span> File(<span class="string">"IMG_0002.jpg"</span>);</div><div class="line">        InputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(file));</div><div class="line">        ps.setBinaryStream(<span class="number">1</span>, in, (<span class="keyword">int</span>) file.length());</div><div class="line">        <span class="comment">// 4.执行语句</span></div><div class="line">        <span class="keyword">int</span> i = ps.executeUpdate();</div><div class="line">        in.close();</div><div class="line">        System.out.println(<span class="string">"i="</span> + i);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">	    JdbcUtils.free(rs, ps, conn);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>查询、读取blob字段:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> SQLException, IOException </span>&#123;</div><div class="line">    Connection conn = <span class="keyword">null</span>;</div><div class="line">    Statement st = <span class="keyword">null</span>;</div><div class="line">    ResultSet rs = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 2.建立连接</span></div><div class="line">        conn = JdbcUtils.getConnection();</div><div class="line">        <span class="comment">// conn = JdbcUtilsSing.getInstance().getConnection();</span></div><div class="line">        <span class="comment">// 3.创建语句</span></div><div class="line">        st = conn.createStatement();</div><div class="line">        <span class="comment">// 4.执行语句</span></div><div class="line">        rs = st.executeQuery(<span class="string">"select big_bit  from blob_test"</span>);</div><div class="line">        <span class="comment">// 5.处理结果</span></div><div class="line">        <span class="keyword">while</span> (rs.next()) &#123;</div><div class="line">            <span class="comment">// Blob blob = rs.getBlob(1);</span></div><div class="line">            <span class="comment">// InputStream in = blob.getBinaryStream();</span></div><div class="line">            InputStream in = rs.getBinaryStream(<span class="string">"big_bit"</span>);</div><div class="line">            File file = <span class="keyword">new</span> File(<span class="string">"IMG_0002_bak.jpg"</span>);</div><div class="line">            OutputStream out = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(file));</div><div class="line">            <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; (i = in.read(buff)) &gt; <span class="number">0</span>;) &#123;</div><div class="line">                out.write(buff, <span class="number">0</span>, i);</div><div class="line">            &#125;</div><div class="line">            out.close();</div><div class="line">            in.close();</div><div class="line">	    &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">	    JdbcUtils.free(rs, st, conn);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="十、JDBC事物处理"><a href="#十、JDBC事物处理" class="headerlink" title="十、JDBC事物处理"></a>十、JDBC事物处理</h2><h3 id="10-1-事物的特性（ACID）"><a href="#10-1-事物的特性（ACID）" class="headerlink" title="10.1 事物的特性（ACID）"></a>10.1 事物的特性（ACID）</h3><p>原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。<br>一致性（Consistency）事务必须使数据库从一个一致性状态变换到另外一个一致性状态。<br>隔离性（Isolation）事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。<br>持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</p>
<h3 id="10-2-JDBC控制事物的三个方法"><a href="#10-2-JDBC控制事物的三个方法" class="headerlink" title="10.2 JDBC控制事物的三个方法"></a>10.2 JDBC控制事物的三个方法</h3><p>connection.setAutoCommit(false);//打开事务。<br>connection.commit();//提交事务。<br>connection.rollback();//回滚事务。</p>
<blockquote>
<p>注意：事物跟数据库启用的引擎有关系，数据库引擎在这里略。</p>
</blockquote>
<h3 id="10-3-事物的保存点设置"><a href="#10-3-事物的保存点设置" class="headerlink" title="10.3 事物的保存点设置"></a>10.3 事物的保存点设置</h3><p>在JDBC的事物处理中，可以应用保存点技术，对一个事物中的处理进行部分提交。</p>
<p>如下示例，三个处理：</p>
<ol>
<li>张三减10元</li>
<li>李四加10元</li>
<li>李四加100元，</li>
</ol>
<p>在3的地方出错的话，把1和2的处理进行提交，使用了保存点技术。</p>
<p>演示保存点:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SavePoint</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	    savepoint();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">savepoint</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.setProperty(<span class="string">"jdbc.drivers"</span>, <span class="string">"com.mysql.jdbc.Driver"</span>);</div><div class="line">        Connection conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/jdbc"</span>, <span class="string">"root"</span>, <span class="string">""</span>);</div><div class="line">        <span class="comment">//初始化不自动提交</span></div><div class="line">        conn.setAutoCommit(<span class="keyword">false</span>);</div><div class="line">        <span class="comment">// 张三减10元</span></div><div class="line">        String sql = <span class="string">"update user set money = money - 10 where id = 1"</span>;</div><div class="line">        PreparedStatement st = conn.prepareStatement(sql);</div><div class="line">        st.executeUpdate();</div><div class="line">        <span class="comment">// 李四加10元</span></div><div class="line">        sql = <span class="string">"update user set money = money + 10 where id = 2"</span>;</div><div class="line">        st = conn.prepareStatement(sql);</div><div class="line">        st.executeUpdate();</div><div class="line">		</div><div class="line">        <span class="comment">// 设立保存点</span></div><div class="line">        Savepoint sp = conn.setSavepoint();</div><div class="line">		</div><div class="line">        <span class="comment">// 李四加再加100元（SQL的where关键字写的不对，会出现异常）</span></div><div class="line">        sql = <span class="string">"update user set money = money + 100 wherewhere id = 2"</span>;</div><div class="line">        st = conn.prepareStatement(sql);</div><div class="line">		</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            st.executeUpdate();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</div><div class="line">            <span class="comment">// 回滚到李四加10元后的状态</span></div><div class="line">            conn.rollback(sp);</div><div class="line">            System.out.println(<span class="string">"回滚到李四加10元后的状态"</span>);</div><div class="line">        &#125;</div><div class="line">        conn.commit();</div><div class="line">        st.close();</div><div class="line">        conn.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="10-4-事物的隔离级别"><a href="#10-4-事物的隔离级别" class="headerlink" title="10.4 事物的隔离级别"></a>10.4 事物的隔离级别</h3><p>多个线程开启各自事务操作数据库中数据时，数据库系统要负责隔离操作，以保证各个线程在获取数据时的准确性。 如果不考虑隔离性，可能会引发如下问题：</p>
<ul>
<li><strong>脏读（dirty reads）</strong>，一个事务读取了另一个未提交的并行事务写的数据。 这是非常危险的。</li>
<li><strong>不可重复读（non-repeatable reads）</strong>， 在一个事物内读取表中的某一行数据，多次读取结果不同。<br>a）例如银行想查询A帐户余额，第一次查询A帐户为200元，此时A向帐户内存了100元并提交了，银行接着又进行了一次查询，此时A帐户为300元了。银行两次查询不一致，可能就会很困惑，不知道哪次查询是准的。<br>b）和脏读的区别是，脏读是读取前一事务未提交的脏数据，不可重复读是重新读取了前一事务已提交的数据。<br>c）很多人认为这种情况就对了，无须困惑，当然是后面的为准。我们可以考虑这样一种情况，比如银行程序需要将查询结果分别输出到电脑屏幕和写到文件中，结果在一个事务中针对输出的目的地，进行的两次查询不一致，导致文件和屏幕中的结果不一致，银行工作人员就不知道以哪个为准了。</li>
<li><strong>虚读/幻读（phantom read）</strong>，是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。<br>如丙存款100元未提交，这时银行做报表统计account表中所有用户的总额为500元，然后丙提交了，这时银行再统计发现帐户为600元了，造成虚读同样会使银行不知所措，到底以哪个为准。</li>
</ul>
<blockquote>
<p>注意：隔离级别越高并发性能越差。</p>
</blockquote>
<h3 id="10-5-事务隔离性的设置语句"><a href="#10-5-事务隔离性的设置语句" class="headerlink" title="10.5 事务隔离性的设置语句"></a>10.5 事务隔离性的设置语句</h3><p>数据库共定义了四种隔离级别： </p>
<ul>
<li>Serializable：可避免脏读、不可重复读、虚读情况的发生。（串行化） </li>
<li>Repeatable read：可避免脏读、不可重复读情况的发生。（可重复读） </li>
<li>Read committed：可避免脏读情况发生（读已提交）。 </li>
<li>Read uncommitted：最低级别，以上情况均无法保证。(读未提交)   </li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span>; <span class="comment">--设置事务隔离级别</span></div><div class="line"><span class="keyword">select</span> @@tx_isolation;  <span class="comment">--查询当前事务隔离级别</span></div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">connection.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);</div></pre></td></tr></table></figure>
<p>V:可能出现，X:不会出现<br><img src="http://img0.ph.126.net/UPhnDJtmQsIi_CshZ7WDTQ==/6608186928725852934.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> jdbc </tag>
            
            <tag> sql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[localhost、127.0.0.1和本机ip三者的区别]]></title>
      <url>/2014/06/24/localhost-and-ip/</url>
      <content type="html"><![CDATA[<h2 id="localhost"><a href="#localhost" class="headerlink" title="localhost"></a>localhost</h2><p>不联网<br>不使用网卡，不受防火墙和网卡限制<br>本机访问<br><a id="more"></a></p>
<h2 id="127-0-0-1"><a href="#127-0-0-1" class="headerlink" title="127.0.0.1"></a>127.0.0.1</h2><p>不联网<br>网卡传输，受防火墙和网卡限制<br>本机访问 </p>
<h2 id="本机IP"><a href="#本机IP" class="headerlink" title="本机IP"></a>本机IP</h2><p>联网<br>网卡传输 ，受防火墙和网卡限制<br>本机或外部访问</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javaweb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript中的this妙用]]></title>
      <url>/2014/04/16/JavaScript-this/</url>
      <content type="html"><![CDATA[<p>JavaScript关键字this始JS脚本能够根据使用这个关键字的上下文将值传递给函数。</p>
<p>我们先来看如下一个网页，在用户单击链接之后，弹出一个alert框，然后再转到href属性所指的网页<br><a id="more"></a><br>HTML：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JavaScript中的this妙用<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/script.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"text-algin:center;"</span>&gt;</span></div><div class="line">        你好，点击这里去<span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"redirect"</span> <span class="attr">href</span>=<span class="string">"http://duni.sinaapp.com/obook/"</span>&gt;</span>旧物商店<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>JS：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.onload = initAll;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initAll</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"redirect"</span>).onclick = initRedirect;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initRedirect</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">"这是我创建的旧物商城，欢迎访问！"</span>);</div><div class="line">    <span class="built_in">window</span>.location = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="http://sandbox.runjs.cn/show/mp2pnrda" target="_blank" rel="external">在线演示</a></p>
<p>你可能会主要到，代码中并没有引用特定的网页——这是this关键字的作用之一。this替我们完成的工作之一是从HTML链接获得URL（也就是a标签的href属性）。由于采用这种方式，如果以后脚本改为指向其他的页面而不是旧物商店页面，就不必修改JS。实际上，可以让WEB站点上的所有链接都调用这个相同的JS代码，这一行代码都会自动获得相应的href值。<br>这样写还有一个好处：如果用户的浏览器不理解JavaScript（比如禁用了JS）,那么它只会加载HTML页面，而不显示alert提示，当他们点击链接时，会像一般情况下那样加载页面，不会发生错误，没有任何问题。</p>
<p>我们在来看一个switch/case例子，创建如下页面：</p>
<p><img src="http://img.imooc.com/56a628240001481209180251.png" alt="switch/case例子"></p>
<p>HTML：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JavaScript中的this妙用<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/script.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>闲置二手图书<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"#"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"Java"</span> <span class="attr">value</span>=<span class="string">"Java"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"JavaScript"</span> <span class="attr">value</span>=<span class="string">"JavaScript"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"MySQL"</span> <span class="attr">value</span>=<span class="string">"MySQL"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"Html"</span> <span class="attr">value</span>=<span class="string">"HTML5"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>JS：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.onload = initAll;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initAll</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"Java"</span>).onclick = viewDetail;</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"JavaScript"</span>).onclick = viewDetail;</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"MySQL"</span>).onclick = viewDetail;</div><div class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"Html"</span>).onclick = viewDetail;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">viewDetail</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"this.id="</span>+<span class="keyword">this</span>.id);</div><div class="line">    <span class="keyword">switch</span>(<span class="keyword">this</span>.id)&#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">"Java"</span> : </div><div class="line">            alert(<span class="string">"《Java程序员基本功》这本书是李刚写的，在我的商店售价30元！"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">"JavaScript"</span> : </div><div class="line">            alert(<span class="string">"《JavaScript语言精粹》这本书是Yahoo的一位工程师写的，在我的商店售价15元！"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">"MySQL"</span> : </div><div class="line">            alert(<span class="string">"《MySQL入门很简单》这本书附带关盘，这个年代其实没什么卵用了，它在我的商店售价28元！"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> <span class="string">"Html"</span> : </div><div class="line">            alert(<span class="string">"《HTML5秘籍》这本书是图灵系统的图书，非常值得拥有，它在我的商店售价25元，卖的非常好！"</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span> : </div><div class="line">            alert(<span class="string">"没有这本书"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="http://sandbox.runjs.cn/show/wflrmken" target="_blank" rel="external">在线演示</a></p>
<p>直接用this.id作为switch的参数也是可以的。</p>
<p><a href="http://dunizb.com/">更多文章&gt;&gt;</a></p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> this </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用POI组件导出数据为Excel文件]]></title>
      <url>/2014/04/09/%E4%BD%BF%E7%94%A8POI%E7%BB%84%E4%BB%B6%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE%E4%B8%BAExcel%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>以下例子为HR系统中一个员工管理模块，导出员工数据为Excel文件的功能。</p>
<p>系统结构为：Struts2+MyBaties+Spring3+MySQL</p>
<p><img src="http://img2.ph.126.net/BVkxZkvJqRzgUbQVfehxVA==/6608189127748145441.png" alt=""></p>
<p>HTML、JS：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"导出EXCEL"</span> onclick=<span class="string">"excelFn();"</span>/&gt;</div><div class="line"><span class="comment">/** 生成Excel文件 */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">excelFn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">document</span>.location = <span class="string">"$&#123;pageContext.request.contextPath&#125;/employee/downExcel.action"</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Java Action：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 员工资料导出Excel */</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">downExcel</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">          <span class="comment">// 调用业务层导出员工资料</span></div><div class="line">          hrmService.exportEmployeeInfo(employee);</div><div class="line">    &#125;<span class="keyword">catch</span>(Exception ex)&#123;</div><div class="line">           log(ex);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> NONE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Java Service：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 导出员工资料</div><div class="line"> * <span class="doctag">@param</span> employee</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportEmployeeInfo</span><span class="params">(Employee employee)</span></span>&#123;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">           <span class="comment">// 查询条件判断(对查询参数进行封装)</span></div><div class="line">           Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</div><div class="line">           <span class="keyword">if</span> (employee != <span class="keyword">null</span>)&#123;</div><div class="line">               <span class="keyword">if</span> (!StringUtils.isNullOrEmpty(employee.getName()))&#123;</div><div class="line">                    params.put(<span class="string">"name"</span>, <span class="string">"%"</span> + employee.getName() + <span class="string">"%"</span>);</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">if</span> (!StringUtils.isNullOrEmpty(employee.getCardId()))&#123;</div><div class="line">                    params.put(<span class="string">"cardId"</span>, <span class="string">"%"</span> + employee.getCardId() + <span class="string">"%"</span>);</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">if</span> (!StringUtils.isNullOrEmpty(employee.getPhone()))&#123;</div><div class="line">                    params.put(<span class="string">"phone"</span>, <span class="string">"%"</span> + employee.getPhone() + <span class="string">"%"</span>);</div><div class="line">               &#125;</div><div class="line">               params.put(<span class="string">"employee"</span>, employee);</div><div class="line">            &#125;</div><div class="line">            List&lt;EmployeeInfo&gt; emps = employeeMapper.getEmployeeInfo(params);</div><div class="line">            <span class="comment">// 调用工具类来导出员工资料</span></div><div class="line">            <span class="comment">// </span></div><div class="line">            String[] titleHeader = &#123;<span class="string">"编号"</span>,<span class="string">"姓名"</span>,<span class="string">"性别"</span>, <span class="string">"手机号码"</span>,<span class="string">"邮箱"</span>, <span class="string">"职位"</span>,<span class="string">"学历"</span>,<span class="string">"身份证号码"</span>,<span class="string">" 部门"</span>,<span class="string">"联系地址"</span>,<span class="string">"建档日期"</span>&#125;;</div><div class="line">            ExcelUtils.export(<span class="string">"员工信息"</span>, <span class="string">"员工资料"</span>, titleHeader, </div><div class="line">                        ServletActionContext.getResponse(),</div><div class="line">                        ServletActionContext.getRequest(), emps);</div><div class="line">        &#125;<span class="keyword">catch</span>(Exception ex)&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HrmException(<span class="string">"导出员工资料时出现异常！"</span>, ex);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ExcelUtils.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Excel操作的工具类</div><div class="line"> * <span class="doctag">@date</span> 2013-5-29 上午9:47:52</div><div class="line"> * <span class="doctag">@version</span> 1.0</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelUtils</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 导出Excel的方法</div><div class="line">     * <span class="doctag">@param</span> excelFileName 生成Excel文件的名称</div><div class="line">     * <span class="doctag">@param</span> sheetname 工作单的名称</div><div class="line">     * <span class="doctag">@param</span> titleHeader (第一行)标题行</div><div class="line">     * <span class="doctag">@param</span> respone 响应</div><div class="line">     * <span class="doctag">@param</span> request 请求</div><div class="line">     * <span class="doctag">@param</span> data 数据</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">(String excelFileName, String sheetname, String[] titleHeader, </span></span></div><div class="line">                        HttpServletResponse response, </div><div class="line">                        HttpServletRequest request, List&lt;?&gt; data) &#123;</div><div class="line">        <span class="comment">/** 创建工作簿 */</span></div><div class="line">        HSSFWorkbook workbook = <span class="keyword">new</span> HSSFWorkbook();</div><div class="line">        <span class="comment">/** 创建工作单*/</span></div><div class="line">        HSSFSheet sheet = workbook.createSheet(sheetname);</div><div class="line">        </div><div class="line">        <span class="comment">/** 创建第一行作为标题行 */</span></div><div class="line">        HSSFRow row = sheet.createRow(<span class="number">0</span>);</div><div class="line">        <span class="comment">/** 循环创建第一行中的单元格 */</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; titleHeader.length; i++)&#123;</div><div class="line">            HSSFCell cell = row.createCell(i);</div><div class="line">            cell.setCellValue(titleHeader[i]);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            <span class="comment">/** 下面把集合中的数据写到Excel中  (从第二行开始)*/</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.size(); i++)&#123;</div><div class="line">                row = sheet.createRow(i + <span class="number">1</span>);</div><div class="line">                <span class="comment">// 从集合中获取一个实体</span></div><div class="line">                Object obj = data.get(i);</div><div class="line">                <span class="comment">// 获取这个实体中的所有属性</span></div><div class="line">                Field[] fields = obj.getClass().getDeclaredFields();</div><div class="line">                <span class="comment">// 循环该实体中所有属性</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; fields.length; j++)&#123;</div><div class="line">                    <span class="comment">// 创建单元格</span></div><div class="line">                    HSSFCell cell = row.createCell(j);</div><div class="line">                    <span class="comment">//  判断该Field是否能访问</span></div><div class="line">                    Field field = fields[j];</div><div class="line">                    <span class="keyword">if</span> (!field.isAccessible()) field.setAccessible(<span class="keyword">true</span>);</div><div class="line">                    <span class="comment">// 获取该Field的值</span></div><div class="line">                    Object res = field.get(obj);</div><div class="line">                    <span class="comment">// 设置单元格的值</span></div><div class="line">                    cell.setCellValue(res.toString());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 判断浏览器类型</span></div><div class="line">                String userAgent = request.getHeader(<span class="string">"user-agent"</span>);</div><div class="line">                <span class="keyword">if</span> (userAgent.toLowerCase().indexOf(<span class="string">"msie"</span>) != -<span class="number">1</span>)&#123; <span class="comment">//MSIE</span></div><div class="line">                    excelFileName = URLEncoder.encode(excelFileName, <span class="string">"utf-8"</span>);</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    excelFileName = <span class="keyword">new</span> String(excelFileName.getBytes(<span class="string">"utf-8"</span>), <span class="string">"iso-8859-1"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 设置响应头</span></div><div class="line">            response.setHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment;filename="</span> + excelFileName + <span class="string">".xls"</span>);</div><div class="line">            <span class="comment">// 输出Excel</span></div><div class="line">            workbook.write(response.getOutputStream());</div><div class="line">        &#125;<span class="keyword">catch</span>(Exception ex)&#123;</div><div class="line">            ex.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码完成后点击导出按钮，结果如图：<br><img src="http://img1.ph.126.net/KQ8Iezk1JrQG3udm8QtrLQ==/6599306173307820322.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 组件使用 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Tomcat学习笔记]]></title>
      <url>/2013/12/28/Tomcat-study-notes/</url>
      <content type="html"><![CDATA[<h2 id="一、Web服务器及Tomcat介绍"><a href="#一、Web服务器及Tomcat介绍" class="headerlink" title="一、Web服务器及Tomcat介绍"></a>一、Web服务器及Tomcat介绍</h2><p>Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，它是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。</p>
<p>特点：免费,处理速度快。大应用及大访问量支持吃力。不支持EJB。 </p>
<h2 id="二、Tomcat详细分析"><a href="#二、Tomcat详细分析" class="headerlink" title="二、Tomcat详细分析"></a>二、Tomcat详细分析</h2><p><strong>1、启动Tomcat</strong></p>
<p>将apache-tomcat-7.0.10-windows-x86.zip解压到磁盘根目录,如果不是根目录，建议不要有中文目录。</p>
<p>解压完成后,进入apache-tomcat-7.0.10，进入bin目录,找到startup.bat(如果是linux,则是startup.sh)双击，启动成功，浏览器输入:<a href="http://127.0.0.1:8080/" target="_blank" rel="external">http://127.0.0.1:8080/</a></p>
<p><strong>2、Tomcat启动闪一下就没了问</strong></p>
<ul>
<li>没有配置环境变量<br>解决: 没有配置JAVA环境变量，添加如下变量:<br>JAVA_HOME : JDK的安装目录<br>PATH: JDK的安装目录\bin</li>
<li>JDK版本太低，Tomcat7必须是jdk6之后的版本</li>
<li>8080端口被占用  </li>
</ul>
<p><strong>3、omcat启动分析</strong></p>
<ul>
<li>startup.bat</li>
<li>catalina.bat</li>
<li>setclasspath.bat  <code>%JAVA_HOME%\bin\java.exe</code></li>
</ul>
<p>结论: 因为Tomcat是java写成的，Tomcat启动时需要找到JDK运行</p>
<p><strong>4、Tomcat目录结构分析</strong></p>
<p>bin:  启动和停止脚本文件<br>conf: Tomcat的配置文件,最重要的文件就是server.xml<br>lib:  Tomcat需要的jar文件<br>logs: 日志文件<br>temp: 临时文件<br>webapps: web应用存放目录<br>work:  Tomcat的工作目录(jsp)  </p>
<h2 id="三、Web应用解释"><a href="#三、Web应用解释" class="headerlink" title="三、Web应用解释"></a>三、Web应用解释</h2><p>web资源：包括html文件、css文件、js文件、动态web页面、java程序、支持jar包、配置文件等</p>
<p>web应用： Web应用是多个web资源的集合</p>
<h2 id="四、使用Tomcat的webapps自动发布web应用"><a href="#四、使用Tomcat的webapps自动发布web应用" class="headerlink" title="四、使用Tomcat的webapps自动发布web应用"></a>四、使用Tomcat的webapps自动发布web应用</h2><p>标准的web应用的目录结构:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">web应用名称(文件夹)</div><div class="line">	--WEB-INF(文件夹)</div><div class="line">	  --web.xml(非常重要)</div></pre></td></tr></table></figure></p>
<p>只要将web应用放在webapps文件夹下面,Tomcat会自动部署这个web应用，web应用名称就是文件夹的名称。</p>
<p>在webapps目录下新建一个文件夹，作为web应用的名称，在里面新建一个hello.html，再拷贝一个web.xml，启动Tomcat即可访问了：<br><a href="http://localhost:8080/hello/hello.html" target="_blank" rel="external">http://localhost:8080/hello/hello.html</a>      </p>
<h2 id="五、使用虚拟目录方式发布Web应用"><a href="#五、使用虚拟目录方式发布Web应用" class="headerlink" title="五、使用虚拟目录方式发布Web应用"></a>五、使用虚拟目录方式发布Web应用</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span> <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>appBase：应用的基准目录</p>
<p>autoDeploye : 自动部署</p>
<p>一个Host元素代表一个web站点,一个web站点下面可以建立多个虚拟目录(web应用)<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"/hello"</span> <span class="attr">docBase</span>=<span class="string">"d:/hello"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p><a href="http://localhost:8080/fkhello/hello.html" target="_blank" rel="external">http://localhost:8080/fkhello/hello.html</a></p>
<p>Context元素：</p>
<ol>
<li>unpackWARs ：Tomcat在运行web程序前将展开所有压缩的Web应用程序，默认值是true。</li>
<li>reloadable：Tomcat服务器在运行时，会监视WEB-INF/classes和WEB-INF/lib目录下类的改变，如果发现有类被更新，Tomcat会自动重新加载应用程序。</li>
<li>docBase：指定Web应用程序的文档基本目录或者WAR文件的路径名</li>
<li>path：指定Web应用程序的上下文路径</li>
</ol>
<h2 id="六、虚拟站点"><a href="#六、虚拟站点" class="headerlink" title="六、虚拟站点"></a>六、虚拟站点</h2><p>http:/www.baidu.com</p>
<p><strong>6.1</strong><br>进入C:\Windows\System32\drivers\etc\hosts<br>加入127.0.0.1       www.baidu.com,目的是让机器能够找到www.baidu.com所代表的ip地址<br>输入:<a href="http://www.baidu.com:8080/hello/hello.html" target="_blank" rel="external">http://www.baidu.com:8080/hello/hello.html</a></p>
<p><strong>6.2</strong><br>修改服务器端口,将8080改为80，80是默认端口<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p><a href="http://www.baidu.com:80/hello/hello.html" target="_blank" rel="external">http://www.baidu.com:80/hello/hello.html</a><br><a href="http://www.baidu.com/hello/hello.html" target="_blank" rel="external">http://www.baidu.com/hello/hello.html</a></p>
<p><strong>6.3</strong><br>修改path<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">"/"</span> <span class="attr">docBase</span>=<span class="string">"d:/hello"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p>可以不输入web应用名称<br><a href="http://www.baidu.com/hello.html" target="_blank" rel="external">http://www.baidu.com/hello.html</a></p>
<p><strong>6.4</strong><br>设置欢迎文件<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>/hello.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>如果不输入要访问的web资源文件,则默认访问/hello.html<br><a href="http://www.baidu.com" target="_blank" rel="external">http://www.baidu.com</a></p>
<h2 id="七、什么是DNS？"><a href="#七、什么是DNS？" class="headerlink" title="七、什么是DNS？"></a>七、什么是DNS？</h2><p>DNS(Domain Name Service)DNS是电信内部的一个域名和IP地址的映射关系</p>
<p>在查询DNS之前，先查看本地操作系统对应的HOSTS文件，是否能找到对应的IP，如果能找到，不会查DNS了，只有在查找不到的情况下，再连网找DNS服务器 .</p>
<p>如果我们在hosts文件中配置了127.0.0.1       www.baidu.com，你就不能访问baidu的搜索引擎了。</p>
<p>上网时，输入的域名(www.baidu.com)，会首先进入到hosts文件中查找是否有对应的地址，如果有直接访问。如果没有，连到电信查询，通过DNS查找访问。</p>
<h2 id="五、服务器是如何加载web项目的？"><a href="#五、服务器是如何加载web项目的？" class="headerlink" title="五、服务器是如何加载web项目的？"></a>五、服务器是如何加载web项目的？</h2><ol>
<li>web服务器启动时会读取tomcat最重要的配置文件server.xml，然后加载所有的web项目。</li>
<li>加载web项目的时候会读取每一个web项目的web.xml部署配置文件，将读取到得内容加载到内存当中。</li>
<li>客户端发送请求<a href="http://localhost:8080/firstapp/hello" target="_blank" rel="external">http://localhost:8080/firstapp/hello</a></li>
<li>服务器判断请求的url“/hello”，从内存中查找匹配的url-pattern，没有找到则404.</li>
<li>找到匹配的url-pattern，获取<code>&lt;servlet-name&gt;</code>，查找对应的  <code>&lt;servlet-class&gt;org.fkjava.servlet.NowServlet&lt;/servlet-class&gt;</code></li>
<li>确定处理请求的servlet之后，通过反射获取该servlet的实例，并调用该实例的service方法处理请求。</li>
<li>客户端接收到返回的结果，渲染成可以识别的html，显示。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tomcat </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Struts2.xml的result里传多个参数]]></title>
      <url>/2013/12/08/Struts2-xml-result-in-the-transmission-of-multiple-parameters/</url>
      <content type="html"><![CDATA[<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;action name="update" class="com.ideal.webapp.action.image.ImageManageAction" method="updateIndexPicList"&gt; </div><div class="line">  &lt;interceptor-ref name="loginStack" /&gt;</div><div class="line">  &lt;result type="redirectAction"&gt;showUpdateIndexPicList?shoppingPicList.id=$&#123;shoppingPicList.id&#125;&amp;amp;flag=product&amp;amp;flag2=image&amp;amp;message=success&lt;/result&gt;</div><div class="line">  &lt;result name="invalid.token"&gt;/WEB-INF/jsp/image/bindProduct.jsp&lt;/result&gt;</div><div class="line">  &lt;result name="input"&gt;/WEB-INF/jsp/image/bindProduct.jsp&lt;/result&gt;</div><div class="line">&lt;/action&gt;</div></pre></td></tr></table></figure>
<p><strong>注意：</strong><br>1、<code>&amp;</code>不允许使用需要转义<code>&amp;amp;</code>即多个参数之间用<code>&amp;amp;</code>隔开<br>2、不能使用<code>chain</code>类型</p>
<p>当使用<code>type＝“redirectAction</code>” 或<code>type＝“redirect”</code>提交到一个action并且需要传递一个参数时。这里是有区别的：</p>
<ul>
<li>使用<code>type＝“redirectAction”</code>时，结果就只能写Action的配置名，不能带有后缀:<code>.action</code></li>
<li>使用<code>type＝“redirect”</code>时，结果应是action配置名＋后缀名 </li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 备忘 </tag>
            
            <tag> struts </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java I/O FTP同步代码及FileZilla Server设置]]></title>
      <url>/2013/12/07/Java-io-FTP-FileZill-Server%E8%AE%BE%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>假设现在有两台机器，一个是你本地开发的机器，一台是服务器，而你本地又有两个应用，需要从shopManage同步到fxShop,如下图.<br><a id="more"></a><br><img src="http://img2.ph.126.net/JpLDOQR5tmUvud6vQPrb_Q==/1984680060887185808.png" alt=""></p>
<p>在2的时间节点还要同时同步到右边的服务器上，二本地两个应用之间使用I\O拷贝。</p>
<p>新建一个工具类如下：<br>第一个方法用IO流方式进行本地拷贝<br>第二个方法才是FTP方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSynchronousUtil</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 文件本机拷贝</div><div class="line">     * <span class="doctag">@param</span> localPath 源路径</div><div class="line">     * <span class="doctag">@param</span> yinPath 目标路径</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">copy</span><span class="params">(String localPath, String yinPath)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">int</span> bytesum = <span class="number">0</span>; </div><div class="line">            <span class="keyword">int</span> byteread = <span class="number">0</span>;</div><div class="line">            File oldfile = <span class="keyword">new</span> File(localPath); </div><div class="line">            <span class="keyword">if</span> (oldfile.exists()) &#123; <span class="comment">// 文件存在时 </span></div><div class="line">                InputStream inStream = <span class="keyword">new</span> FileInputStream(localPath); </div><div class="line">                String wenjianName = localPath.substring(localPath.lastIndexOf(<span class="string">"\\"</span>));</div><div class="line">                System.out.println(wenjianName); </div><div class="line">                System.out.println(yinPath + wenjianName);</div><div class="line">                <span class="comment">// 读入原文件</span></div><div class="line">                FileOutputStream fs = <span class="keyword">new</span> FileOutputStream(yinPath + wenjianName);</div><div class="line">                <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1444</span>];</div><div class="line">                <span class="keyword">while</span> ((byteread = inStream.read(buffer)) != -<span class="number">1</span>) &#123;</div><div class="line">                    bytesum += byteread; <span class="comment">// 字节数 文件大小</span></div><div class="line">                    System.out.println(bytesum);</div><div class="line">                    fs.write(buffer, <span class="number">0</span>, byteread);</div><div class="line">                &#125;</div><div class="line">                inStream.close();</div><div class="line">           &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            System.out.println(<span class="string">"复制单个文件操作出错"</span>);</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 使用FTP方式同步文件到远程服务器</div><div class="line">     * <span class="doctag">@param</span> localPath 本地路径</div><div class="line">     * <span class="doctag">@param</span> FtpPath 远程FTP服务器路径</div><div class="line">     * <span class="doctag">@param</span> FtpPathName 远程FTP服务器登录名</div><div class="line">     * <span class="doctag">@param</span> FtpPathPass 远程FTP服务器登录密码</div><div class="line">     * <span class="doctag">@param</span> FtpIp 远程FTP服务器IP地址</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(String localPath, String FtpPath, String FtpPathName,</span></span></div><div class="line">        String FtpPathPass, String FtpIp) &#123;</div><div class="line">        <span class="comment">//链接FTP</span></div><div class="line">        FTPClient ftpClient = <span class="keyword">new</span> FTPClient();</div><div class="line">        FileInputStream fis = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">int</span> reply;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ftpClient.connect(FtpIp, <span class="number">21</span>);</div><div class="line">            ftpClient.login(FtpPathName, FtpPathPass);</div><div class="line">            reply = ftpClient.getReplyCode();</div><div class="line">            <span class="keyword">if</span> (!FTPReply.isPositiveCompletion(reply)) &#123;</div><div class="line">                ftpClient.disconnect();</div><div class="line">            &#125;</div><div class="line">            fis = <span class="keyword">new</span> FileInputStream(localPath);</div><div class="line">            ftpClient.setBufferSize(<span class="number">10240000</span>);</div><div class="line">            String wenjianName = localPath.substring(localPath.lastIndexOf(<span class="string">"\\"</span>)+<span class="number">1</span>); </div><div class="line">            ftpClient.makeDirectory(FtpPath);</div><div class="line">            ftpClient.changeWorkingDirectory(FtpPath);</div><div class="line">            ftpClient.setControlEncoding(<span class="string">"GBK"</span>);</div><div class="line">            ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE);</div><div class="line">            <span class="comment">//被动模式传输</span></div><div class="line">            ftpClient.enterLocalPassiveMode();</div><div class="line"><span class="comment">//          ftpClient.storeFile(new String(wenjianName.getBytes("GBK"), "iso-8859-1") , fis);</span></div><div class="line">            ftpClient.storeFile(wenjianName, fis);</div><div class="line">            fis.close();</div><div class="line">        <span class="comment">/*  String finalRemoteFileName = FtpPath.replaceAll(".ing", "");</span></div><div class="line">            ftpClient.rename(FtpPath, finalRemoteFileName);*/</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (ftpClient.isConnected()) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    ftpClient.disconnect();</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</div><div class="line">                    ioe.getMessage();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同时准备一个ftp.propertis文件，主要参数都在这里配置，需要读取这个文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#本地IP</div><div class="line">localIp=127.0.0.1</div><div class="line">##本地目标地址</div><div class="line">local_targetPath=D\:\\tomcat\\apache-tomcat-6.0.16\\webapps\\fxShop</div><div class="line">##远程目标地址</div><div class="line">remote_targetPath=</div><div class="line">#远程FTP服务器IP</div><div class="line">remote_ftpIp=127.0.0.1</div><div class="line">#远程FTP服务器登录名</div><div class="line">remote_ftpServerName=test</div><div class="line">#远程FTP服务器登录密码</div><div class="line">remote_ftpServerPassWord=123</div></pre></td></tr></table></figure></p>
<p>写一个主调（Main）方法，就可以进行调用测试了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//读取配置文件，</span></div><div class="line">        InputStream stream = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//stream = new BufferedInputStream(new FileInputStream(new File("src/common.properties")));</span></div><div class="line">            stream = NowFirst.class.getResourceAsStream(<span class="string">"/common.properties"</span>);</div><div class="line">            System.err.println(stream);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            System.out.println(<span class="string">"配置文件未找到！"</span>);</div><div class="line">        &#125;</div><div class="line">         Properties p = <span class="keyword">new</span> Properties();</div><div class="line">         <span class="keyword">try</span> &#123;</div><div class="line">            p.load(stream);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            System.out.println(<span class="string">"文件未加载"</span>);</div><div class="line">        &#125;</div><div class="line">        String localPath=p.getProperty(<span class="string">"localPath"</span>);</div><div class="line">        String targetPath=p.getProperty(<span class="string">"targetPath"</span>);</div><div class="line">        String FtpOnePath=p.getProperty(<span class="string">"FtpOnePath"</span>);</div><div class="line">        System.err.println(FtpOnePath);</div><div class="line">        String FtpOnePathName=p.getProperty(<span class="string">"FtpOnePathName"</span>);</div><div class="line">        String FtpOnePathPass=p.getProperty(<span class="string">"FtpOnePathPass"</span>);</div><div class="line">        String FtpTwoPath=p.getProperty(<span class="string">"FtpTwoPath"</span>);</div><div class="line">        String FtpTwoPathName=p.getProperty(<span class="string">"FtpTwoPathName"</span>);</div><div class="line">        String FtpTwoPathPass=p.getProperty(<span class="string">"FtpTwoPathPass"</span>);</div><div class="line">        String FtpOneIp=p.getProperty(<span class="string">"FtpOneIp"</span>);</div><div class="line">        String FtpTwoIp=p.getProperty(<span class="string">"FtpTwoIp"</span>)；</div><div class="line">        serviceDao dao=<span class="keyword">new</span> serviceDao();</div><div class="line">        <span class="comment">//同步本地</span></div><div class="line">        <span class="comment">//dao.copy(localPath, targetPath);</span></div><div class="line">        <span class="comment">//同步Ftp</span></div><div class="line">        <span class="comment">//第一台</span></div><div class="line">        dao.copy(localPath, FtpOnePath, FtpOnePathName, FtpOnePathPass,FtpOneIp);</div><div class="line">        <span class="comment">//第二台</span></div><div class="line">        <span class="comment">//dao.copy(localPath, FtpTwoPath, FtpTwoPathName, FtpTwoPathPass,FtpTwoIp);</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然了，是用FTP同步需要FTP服务器支持，你要建立一个FTP服务，比较方便的是使用FileZilla Server</p>
<p>FileZilla Server设置：<br>首先需要新建一个用户：</p>
<p><img src="http://img1.ph.126.net/uZOLgZpHBVw7VxngO7PFVA==/6608208918957013228.png" alt=""></p>
<p>直接填一个用户名就好了：</p>
<p><img src="http://img1.ph.126.net/q2dCitSNWuSmEfZOLC8eYQ==/3791467936392758896.png" alt=""></p>
<p>然后账号设置这里，你可以给给他分配一个密码，也可以不写，去掉勾就好了：</p>
<p><img src="http://img1.ph.126.net/rsrLREs2ZoWnroC5gmjlRA==/779404210611813346.png" alt=""></p>
<p>接下来就是制定一个共享目录，这个目录就是用来同步到的目标地址：</p>
<p><img src="http://img0.ph.126.net/YeQ28mHLYyu91js-4UmRdw==/6599325964516682538.png" alt=""></p>
<p>这里假设建在F盘的FTPTest目录下。<br>注意：这里的Read、Write必须勾选，否则FTP就没法写入文件了</p>
<p><img src="http://img1.ph.126.net/mncDGDxD3_GL51ezRvSEoA==/6597281972402231761.png" alt=""></p>
<p>还要设置这个文件夹为系统共享的，右键-属性-共享这个文件夹：</p>
<p><img src="http://img0.ph.126.net/q69xqdAuOBuEr8NcrfsNzA==/3191644761022136823.png" alt=""></p>
<p>好了，就弄完了。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ftp </tag>
            
            <tag> FileZill </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用JXL组件导入Excel文件数据到数据库]]></title>
      <url>/2013/11/15/%E4%BD%BF%E7%94%A8JXL%E7%BB%84%E4%BB%B6%E5%AF%BC%E5%85%A5Excel%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      <content type="html"><![CDATA[<p>一、功能需求和设计功能：</p>
<ol>
<li>点击浏览选择一个Excel文件，点击导入，即把Excel文件里的数据传输到数据库</li>
<li>过滤上传文件类型</li>
<li>需要验证文件标题顺序是否正确</li>
<li>表格字段验证</li>
<li>操作过程删除上传的文件<a id="more"></a>
功能界面如下：<br><img src="http://img2.ph.126.net/qalMBPpLcNC5gWqo0pcCtw==/1145040205359279692.png" alt=""></li>
</ol>
<p><strong>注意</strong></p>
<ol>
<li>Excel文件数据格式需要先约定好（模板），随便乱七八糟的可不行。</li>
<li>上传MS Office 2007以上版本、WPS Office需要添加MIME文件类型，详见《文件上传支持WPS Office、MS Office2003-2010的办法》</li>
</ol>
<p><img src="http://img2.ph.126.net/st5s0AYLZ2vLFsfEvPV0Kg==/1472677078250298239.png" alt=""></p>
<p>二、思路：</p>
<p>先上传、再读取</p>
<p>三、上传（本人使用Struts2+iBatis+Spring框架，上传部分自然也是Struts2方式上传）</p>
<p>上传主题代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 导入xls数据-UIM卡信息 */</span>  </div><div class="line"><span class="keyword">private</span> File excl;</div><div class="line"><span class="keyword">private</span> String exclFileName;</div><div class="line"><span class="keyword">private</span> String exclContentType;</div><div class="line"><span class="comment">/** 上传Excel文件 */</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">import_xls</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//设定拖存储在服务器的路径</span></div><div class="line">        String path = WebConstant.UIM_EXCEL_PATH;</div><div class="line">        String realPath = ServletActionContext.getServletContext().getRealPath(path);</div><div class="line">            </div><div class="line">        <span class="comment">//设置新的文件名</span></div><div class="line">        String newFileName = <span class="keyword">this</span>.generateFileName(exclFileName);</div><div class="line">        String saveFilePath = realPath + File.separator + newFileName;</div><div class="line">        FileUtils.copyFile(excl, <span class="keyword">new</span> File(saveFilePath));</div><div class="line">        </div><div class="line">        <span class="comment">//读取Excel文件</span></div><div class="line">        <span class="keyword">this</span>.import_xls(<span class="keyword">new</span> File(saveFilePath));</div><div class="line">            </div><div class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">        setMessage(<span class="string">"导入失败！"</span>);</div><div class="line">        log(ex);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> SUCCESS;</div><div class="line">&#125;</div><div class="line"><span class="comment">/** 省略getter and setting method */</span></div></pre></td></tr></table></figure></p>
<p><strong>文件重命名</strong></p>
<p>由于本人项目中上传的文件都有一个固定的约定格式，是这样的：xxx-2010-09-09-admin.xls即，原文件名+日期+上传者.xls<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line">**</div><div class="line"> * 重命名上传文件</div><div class="line"> * <span class="meta">@param</span> oldFileName 旧文件名</div><div class="line"> * <span class="meta">@return</span> 新文件名</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">generateFileName</span><span class="params">(String oldFileName)</span> </span></div><div class="line">&#123;</div><div class="line">        <span class="comment">//xxxxx-2013-11-07-admin.xls</span></div><div class="line">        Date dateNow=<span class="keyword">new</span> Date();  </div><div class="line">        SimpleDateFormat  dateFormat=<span class="keyword">new</span> SimpleDateFormat (<span class="string">"yyyy-MM-dd"</span>);  </div><div class="line">        String dateNowStr=dateFormat.format(dateNow);  </div><div class="line">        <span class="comment">//获取文件名（不带后缀）</span></div><div class="line">        String fileBaseName = FilenameUtils.getBaseName(oldFileName);</div><div class="line">        <span class="comment">//获取文件后缀</span></div><div class="line">        String extension = FilenameUtils.getExtension(oldFileName);</div><div class="line">        <span class="comment">//新文件名</span></div><div class="line">        String newFileName = fileBaseName+<span class="string">"-"</span>+dateNowStr+<span class="string">"-"</span>+WebConstant.getSessionUser().getFxUsername()</div><div class="line">            +<span class="string">"."</span>+extension;</div><div class="line">        <span class="keyword">return</span> newFileName;</div><div class="line">&#125;</div><div class="line">四、下面是解析Excel，导入Excel的代码：</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 导入Excel源文件</div><div class="line"> * <span class="doctag">@param</span> file 要导入的Excel源文件</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">import_xls</span><span class="params">(File file)</span> </span>&#123;</div><div class="line">    Workbook workbook = <span class="keyword">null</span>;</div><div class="line">    List&lt;ShoppingUimCard&gt; uim_list = <span class="keyword">new</span> ArrayList&lt;ShoppingUimCard&gt;();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(file); </div><div class="line">        <span class="comment">//获取工作薄和第一个工作单</span></div><div class="line">        workbook = Workbook.getWorkbook(is);</div><div class="line">        Sheet sheet = workbook.getSheet(<span class="number">0</span>);</div><div class="line">        <span class="comment">// 拿到列，行 </span></div><div class="line">        <span class="comment">//int column = sheet.getColumns(); </span></div><div class="line">        <span class="keyword">int</span> row = sheet.getRows();</div><div class="line">            </div><div class="line">        <span class="comment">//定义开始的一行</span></div><div class="line">        <span class="keyword">int</span> rowStart = <span class="number">1</span>;</div><div class="line">            </div><div class="line">        <span class="comment">//获取第一行的标题行,并判断顺序是否正确</span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.checkTitleRule(sheet))&#123;</div><div class="line">            <span class="comment">//循环行,标题行的下一行开始</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = rowStart; i &lt; row; i++) &#123;</div><div class="line">                <span class="comment">//输入一张卡的信息</span></div><div class="line">                ShoppingUimCard uim = <span class="keyword">new</span> ShoppingUimCard();</div><div class="line">                Cell[] cells = sheet.getRow(i); </div><div class="line">                <span class="comment">//int cellsLength = cells.length;</span></div><div class="line">                    </div><div class="line">                <span class="comment">//天翼靓号</span></div><div class="line">                uim.setUimCard(<span class="keyword">this</span>.checkDataFormat(<span class="string">"UIM_CARD"</span>,cells[<span class="number">0</span>]));    </div><div class="line">                <span class="comment">//预存话费</span></div><div class="line">                uim.setUimMoney(<span class="keyword">new</span> BigDecimal(<span class="keyword">this</span>.checkDataFormat(<span class="string">"NUMBER"</span>,cells[<span class="number">1</span>])));    </div><div class="line">                <span class="comment">//每月最低消费金额</span></div><div class="line">                uim.setUimMin(<span class="keyword">new</span> BigDecimal(<span class="keyword">this</span>.checkDataFormat(<span class="string">"NUMBER"</span>,cells[<span class="number">2</span>])));        </div><div class="line">                <span class="comment">//签约时长</span></div><div class="line">                uim.setUimTime(<span class="keyword">new</span> BigDecimal(<span class="keyword">this</span>.checkDataFormat(<span class="string">"DATE"</span>,cells[<span class="number">3</span>])));   </div><div class="line">                <span class="comment">//号池方向</span></div><div class="line">                uim.setUimKind(<span class="keyword">this</span>.checkDataFormat(<span class="string">"NUMBER"</span>,cells[<span class="number">4</span>]));    </div><div class="line">               <span class="comment">//UIM_ICCID</span></div><div class="line">             uim.setUimIccid(<span class="keyword">this</span>.checkDataFormat(<span class="string">"NUMBER"</span>,cells[<span class="number">5</span>]));                    </div><div class="line">                    </div><div class="line">                <span class="comment">//UIM卡其他信息</span></div><div class="line">                uim.setCreateDate(<span class="keyword">new</span> Date());</div><div class="line">                uim.setUpdateDate(<span class="keyword">new</span> Date());</div><div class="line">                uim.setIsActive(<span class="string">"1"</span>);</div><div class="line">                uim.setUimType(<span class="keyword">new</span> BigDecimal(uim.getUimCard().length()));</div><div class="line">                uim.setUserId(WebConstant.getSessionUser().getId()+<span class="string">""</span>);</div><div class="line">                uim.setDel(<span class="keyword">null</span>);</div><div class="line">                uim.setBookTime(<span class="keyword">null</span>);</div><div class="line">                uim.setUimShow(<span class="keyword">null</span>);</div><div class="line">                uim.setOrderId(<span class="keyword">null</span>);</div><div class="line">                uim.setUimShopType(<span class="keyword">null</span>);</div><div class="line">                uim.setComboId(<span class="keyword">null</span>);</div><div class="line">                uim.setAssProfit(<span class="keyword">null</span>);</div><div class="line">                uim.setItemCompany(<span class="keyword">null</span>);</div><div class="line">                uim.setUimShowDetail(<span class="keyword">null</span>);</div><div class="line">                uim.setCityName(<span class="keyword">null</span>);</div><div class="line">                uim.setProvince(<span class="keyword">null</span>);</div><div class="line">                uim.setShopid(<span class="keyword">null</span>);</div><div class="line">                    </div><div class="line">                uim_list.add(uim);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//插入数据到数据库</span></div><div class="line">            uimManageService.insertUimCard(uim_list);</div><div class="line">            setMessage(<span class="string">"导入成功！"</span>);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ShopManageException(<span class="string">"导入UIM基础信息时出现错误:模板标题顺序不符合要求"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        setMessage(<span class="string">"导入失败，读取Excel文件失败！"</span>);</div><div class="line">        System.err.println(<span class="string">"插入Excel表格数据到数据库失败！：UimManageAction.insert_uim_card()"</span>);</div><div class="line">        deleteFile(file);</div><div class="line">        log(e);</div><div class="line">    &#125;<span class="keyword">finally</span>&#123;</div><div class="line">        workbook.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>五、获取第一行的标题行,并判断顺序是否正确：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">  * 获取第一行的标题行,并判断顺序是否正确</div><div class="line">  * @param sheet</div><div class="line">  */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkTitleRule</span><span class="params">(Sheet sheet)</span> </span>&#123;</div><div class="line">    Cell[] cells = sheet.getRow(<span class="number">0</span>);</div><div class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line">    <span class="comment">//规定的标题顺序</span></div><div class="line">    String[] title = WebConstant.IMPORT_XLS;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cells.length;i++)&#123;</div><div class="line">        System.out.print(cells[i].getContents() + <span class="string">"\t"</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;title.length;j++)&#123;</div><div class="line">            <span class="keyword">if</span>(!cells[<span class="number">0</span>].getContents().equalsIgnoreCase(title[<span class="number">0</span>].toString()))&#123;</div><div class="line">                flag = <span class="keyword">false</span>;</div><div class="line">                System.err.println(<span class="string">"Error:模板标题'"</span>+cells[i].getContents()+<span class="string">"'顺序不符合要求"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> flag;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>六、检查每个单元格数据是否符合要求：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 检查数据是否符合要求</div><div class="line"> * <span class="doctag">@param</span> contents 列值</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">checkDataFormat</span><span class="params">(String title,Cell cells)</span> </span>&#123;</div><div class="line">    String contents = cells.getContents();</div><div class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</div><div class="line">    <span class="comment">//检查天翼靓号</span></div><div class="line">    <span class="keyword">if</span>(<span class="string">"UIM_CARD"</span>.equalsIgnoreCase(title) &amp;&amp; cells.getType()==CellType.NUMBER)&#123;</div><div class="line">        Pattern p = Pattern.compile(<span class="string">"^((13[0-9])|(15[^4,\\D])|(18[0,5-9]))\\d&#123;8&#125;$"</span>);  </div><div class="line">        Matcher m = p.matcher(contents);</div><div class="line">        <span class="keyword">if</span>(!m.matches())&#123;</div><div class="line">           flag = <span class="keyword">false</span>;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> ShopManageException(<span class="string">"导入UIM基础信息时出现错误:天翼靓号不符合格式要求"</span>);</div><div class="line">         &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//检查是否是数字,整数或者小数</span></div><div class="line">    <span class="keyword">if</span>(<span class="string">"NUMBER"</span>.equalsIgnoreCase(title) || <span class="string">"DATE"</span>.equalsIgnoreCase(title))&#123;</div><div class="line">         <span class="keyword">if</span>(cells.getType()!=CellType.NUMBER)&#123;</div><div class="line">         flag = <span class="keyword">false</span>;</div><div class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ShopManageException(<span class="string">"导入UIM基础信息时出现错误:检查数据是否符合要求没通过"</span>);</div><div class="line">         &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//检查时间日期(签约时长)</span></div><div class="line"><span class="comment">//        if("DATE".equalsIgnoreCase(title))&#123;</span></div><div class="line"><span class="comment">//            if(cells.getType() != CellType.DATE)&#123;</span></div><div class="line"><span class="comment">//                flag = false;</span></div><div class="line"><span class="comment">//                throw new ShopManageException("导入UIM基础信息时出现错误:日期格式错误");</span></div><div class="line"><span class="comment">//            &#125;</span></div><div class="line"><span class="comment">//        &#125;</span></div><div class="line">    <span class="keyword">if</span>(!flag)&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ShopManageException(<span class="string">"导入UIM基础信息时出现错误:检查数据是否符合要求没有通过，请检查数据!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> contents;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>七、当操作出错时删除服务器上的文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 删除文件</div><div class="line"> * <span class="doctag">@param</span> fileName 源文件</div><div class="line"> * <span class="doctag">@return</span> false and true</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">deleteFile</span><span class="params">(File fileName)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(fileName.isFile() &amp;&amp; fileName.exists())&#123;</div><div class="line">        fileName.delete();</div><div class="line">        System.err.println(<span class="string">"删除单个文件"</span>+fileName.getName()+<span class="string">"成功！"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        System.err.println(<span class="string">"删除单个文件"</span>+fileName.getName()+<span class="string">"失败！"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>八、过滤文件类型</p>
<p>本人使用JS控制，当然你要可以使用Struts2框架进行校验：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"#btn_submit"</span>).click(function()&#123;</div><div class="line">    var excl = $(<span class="string">"#excl"</span>);</div><div class="line">    var suffix = excl.val().split(<span class="string">"."</span>)[<span class="number">1</span>];</div><div class="line">    <span class="keyword">if</span>(excl.val() == <span class="string">""</span>)&#123;</div><div class="line">        $(<span class="string">"#picMsg"</span>).text(<span class="string">"请选择上传的Excl文件！"</span>);</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(suffix!=<span class="string">"xls"</span>)&#123;</div><div class="line">        $(<span class="string">"#picMsg"</span>).text(<span class="string">"格式不正确，请选择上传的Excl文件！"</span>);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        $(<span class="string">"#uploadUimDataForm"</span>).submit();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这个JS校验只是简单的判断文件后缀是否正确，当这是不够严谨的，你可以做的更好</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 组件使用 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[System.out.println与System.err.println的区别]]></title>
      <url>/2013/10/29/System-out-println%E4%B8%8ESystem-err-println%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p><code>System.out.println</code>能重定向到别的输出流，这样的话你在屏幕上将看不到打印的东西了， 而<code>System.err.println</code>只能在屏幕上实现打印，即使你重定向了也一样。<br><a id="more"></a><br>当向控制台输出信息时，开发者有两个选择：<code>System.out</code>和<code>System.err</code>。使用者更倾向于输出的是<code>System.out</code>，而如果是<code>System.err</code>则输出“error”。尽管这看起来是显而易见的，但很多开发者都不了解为什么出错和调试时使用<code>System.err</code>。</p>
<p>当输出一个流时，JVM和操作系统共同决定何时输出这个流。也就是说，尽管开发者键入了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.print(<span class="string">"Test   Output:"</span>);</div></pre></td></tr></table></figure></p>
<p>JVM和操作系统的组合体并不会立即输出这个流。相反，它将保持等待状态直到将要输出的东西达到一定的量。   </p>
<p>假设输入以下指令：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(<span class="string">"Debugging Info."</span>);</div></pre></td></tr></table></figure></p>
<p>JVM可能同意输出；然而，操作系统可能决定暂不输出。   </p>
<p>由于这个原因，在调试程序时想要发现出错的位置就有可能成为问题。考虑以下的程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span>   i=<span class="number">0</span>;   i&lt;<span class="number">56</span>;   i++)   &#123;   </div><div class="line">    System.out.println(i);   </div><div class="line">    ...   </div><div class="line">    <span class="comment">//   containing   an   error   </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>错误可能出现在i等于54时，但是可能JVM在i等于49时就结束输出了。50到54仍然存在于缓存中，结果也就丢失了。使用<code>System.err</code>来报告错误、调试程序就可以避免这种情况出现，它将使每一次操作的结果都输出出来。例如以下程序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span>   i=<span class="number">0</span>;   i&lt;<span class="number">56</span>;   i++)   &#123;   </div><div class="line">     System.err.println(i);   </div><div class="line">     ...   </div><div class="line">     <span class="comment">//   containing   an   error   </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在每一次i等于54时都将显示错误信息。</p>
<p><code>System.out.println</code>可能会被缓冲,而<code>System.err.println</code>不会.</p>
<p><code>System.err和System.out</code>就是错误输出和标准输出。如果你用LOG4J记录日志的话,且设定错误等级的话，<code>System.err</code>的输出是将记录到日志中。</p>
<p>输出设备是一样的所以你看到的是一样的<code>System.setErr()</code>，<code>System.setOut()</code>是重定向两个流的方法。</p>
<p><code>System.err.println()</code>是要缓冲的,所以优先级会高点,而<code>System.out.println()</code>是不需要缓冲的,所以优先级会低点.</p>
<p>另外，特别的，当你使用MyEclipse和Tomcat6以上时，输出<code>System.err.println(&quot;aaaa&quot;)</code>到控制台是红色显示的，在控制台很显眼，一下就能找到，非常适合输出调试信息，这个我个人比较喜欢用，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    System.err.println(<span class="string">"aaaaaaaaaaaaaaaa"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://img2.ph.126.net/2QNPPl8D_-byOjzPHYzKKA==/6599275386981696242.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> javase </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BigDecimal互转Integer]]></title>
      <url>/2013/10/26/BigDecimal-conversion-Integer/</url>
      <content type="html"><![CDATA[<h2 id="一、Integer类型"><a href="#一、Integer类型" class="headerlink" title="一、Integer类型"></a>一、Integer类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Integer a=<span class="keyword">new</span> Integer(<span class="keyword">int</span> value); </div><div class="line">Integer a=<span class="keyword">new</span> Integer(String value);</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>转换：</strong></p>
<ol>
<li>定义中就可以将int型和String型的转换为Integer型  </li>
<li><p>String类型转换为Integer型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Integer.valueOf(<span class="string">""</span>);</div><div class="line">Integer.getInteger(<span class="string">""</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>String、Integer类型转换为int型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Integer.parseInt(<span class="string">""</span>);</div><div class="line">Integer a;</div><div class="line">a.intValue();</div></pre></td></tr></table></figure>
</li>
<li><p>上面定义的Integer a转换为float, double, long</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a.floatValue();</div><div class="line">a.doubleValue();</div><div class="line">a.longValue();</div></pre></td></tr></table></figure>
</li>
<li><p>Integer a转换为String(其它的类型转换为String都可通用以下方法)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">toString();</div><div class="line">String.valueOf(a);</div></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>比较（比较的数Integer a）：</strong></p>
<ol>
<li><code>Int num=a.compareTo(Integer anotherInteger);</code></li>
</ol>
<p>如果该 Integer 等于 Integer 参数，则返回 0 值;如果该 Integer 在数字上小于 Integer 参数，则返回小于 0 的值;如果 Integer 在数字上大于 Integer 参数，则返回大于 0 的值(有符号的比较)。</p>
<ol>
<li>转换为int型再比较<br>a.intValue()与b.intValue比较大小；</li>
</ol>
<h2 id="二、BigDecimal"><a href="#二、BigDecimal" class="headerlink" title="二、BigDecimal"></a>二、BigDecimal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">BigDecimal a=<span class="keyword">new</span> BigDecimal(String; val)</div><div class="line">BigDecimal a=<span class="keyword">new</span> BigDecimal(<span class="keyword">double</span> val);</div></pre></td></tr></table></figure>
<p><strong>转换：</strong></p>
<ol>
<li>定义中就可以将String型和double 型的转换为BigDecimal型</li>
<li><p><code>Int,float, double, long转换为BigDecimal</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a.floatValue();</div><div class="line">a.doubleValue();</div><div class="line">a.longValue();</div><div class="line">a.intValue();</div></pre></td></tr></table></figure>
</li>
<li><p>BigDecimal a转换为String(其它的类型转换为String都通用以下方法)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">toString();</div><div class="line">String.valueOf(a);</div></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>比较(比较的数BigDecimal a)</strong></p>
<ol>
<li><code>Int num=a.compareTo(BigDecimal anotherBigDecimal);</code><br>当此BigDecimal在数字上小于、等于或大于 val 时，返回 -1、0 或 1。<br>BigDecimal取其中最大、最小值、绝对值、相反数:<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">当此BigDecimal在数字上小于、等于或大于 val 时，返回 -<span class="number">1</span>、<span class="number">0</span> 或 <span class="number">1</span>。</div><div class="line">BigDecimal取其中最大、最小值、绝对值、相反数:</div></pre></td></tr></table></figure>
</li>
</ol>
<p>计算：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">加: a.add(b);</div><div class="line">减: a.subtract(b);</div><div class="line">乘: a.multiply(b);</div><div class="line">除: a.divide(b,<span class="number">2</span>);<span class="comment">//2为精度取值</span></div></pre></td></tr></table></figure></p>
<p>int 、long、double、 float的取绝对值和同类型间比较大小都可用以下Math方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Math.max(a,b);<span class="comment">//比较取最大值</span></div><div class="line">Math.min(a,b);<span class="comment">//比较取最小值</span></div><div class="line">Math.abs(a); <span class="comment">//取最绝对值</span></div></pre></td></tr></table></figure></p>
<ol>
<li></li>
</ol>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> javase </tag>
            
            <tag> 备忘 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Struts2图片上传(回显、多图上传、格式控制、多图上传分别保存路径到数据库不同的列)]]></title>
      <url>/2013/10/12/Struts2%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0-%E5%9B%9E%E6%98%BE%E3%80%81%E5%A4%9A%E5%9B%BE%E4%B8%8A%E4%BC%A0%E3%80%81%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6%E3%80%81%E5%A4%9A%E5%9B%BE%E4%B8%8A%E4%BC%A0%E5%88%86%E5%88%AB%E4%BF%9D%E5%AD%98%E8%B7%AF%E5%BE%84%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8D%E5%90%8C%E7%9A%84%E5%88%97/</url>
      <content type="html"><![CDATA[<p>页面如下：<br><img src="http://img1.ph.126.net/TVKU0tPhhtVlVvBH3D4mlw==/2249548013971633168.png" alt=""></p>
<p>需求：</p>
<ol>
<li>选中店铺后，选中上传LOGO或者页脚、或者一次LOGO和页脚都上传</li>
<li>上传后，LOGO和页脚保存到表的两个列</li>
</ol>
<p>关键：<br>单张图上传、怎么判断上传的是LOGO还是页脚</p>
<p>表如下：<br><img src="http://img1.ph.126.net/EbZYUj6vb_vtr18JVa1ZBQ==/6597968067658220923.png" alt=""></p>
<p>upload.jsp<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">……….</div><div class="line">&lt;s:hidden id="img_type" name="imgType" value="" /&gt;</div><div class="line">&lt;tr&gt;</div><div class="line">    &lt;td class="STYLE1"&gt;上传LOGO：&lt;s:file id="img" name="img"/&gt;&lt;/td&gt;</div><div class="line">&lt;/tr&gt;</div><div class="line">&lt;tr&gt;</div><div class="line">    &lt;td class="STYLE1"&gt;上传页脚：&lt;s:file id="foot" name="img"/&gt;&lt;/td&gt;</div><div class="line">&lt;/tr&gt;</div><div class="line">&lt;tr&gt;</div><div class="line">    &lt;td align="left"&gt;</div><div class="line">    &lt;input type="button" id="img_btn" value="上传" /&gt;</div><div class="line">    &lt;span style="color:red;"&gt;</div><div class="line">    &lt;s:actionerror/&gt;</div><div class="line">    &lt;s:fielderror /&gt;</div><div class="line">    &lt;s:if test="message!= null"&gt;</div><div class="line">    &lt;s:property value="message" /&gt;</div><div class="line">    &lt;/s:if&gt;</div><div class="line">    &lt;/span&gt;</div><div class="line">    &lt;/td&gt;</div><div class="line">&lt;/tr&gt;</div><div class="line">&lt;tr&gt;</div><div class="line">    &lt;td class="STYLE1" align="left"&gt;预览：&lt;/td&gt;</div><div class="line">&lt;/tr&gt;</div><div class="line">&lt;tr&gt;</div><div class="line">    &lt;td class="STYLE1" align="left"&gt;</div><div class="line">    &lt;img src="$&#123;pageContext.request.contextPath&#125;/$&#123;imgSrcLogo&#125;" alt="这是LOGO" title="这是LOGO" width="100" height="100" /&gt;</div><div class="line">&lt;/td&gt;</div><div class="line">&lt;/tr&gt;</div><div class="line">&lt;tr&gt;</div><div class="line">    &lt;td class="STYLE1" align="left"&gt;</div><div class="line">    &lt;img src="$&#123;pageContext.request.contextPath&#125;/$&#123;imgSrcFoot&#125;" alt="这是页脚" title="这是页脚" width="600" height="350" /&gt;</div><div class="line">    &lt;/td&gt;</div><div class="line">&lt;/tr&gt;</div></pre></td></tr></table></figure></p>
<p>这里面有个隐藏表单域<code>&lt;s:hidden id=&quot;img_type&quot; name=&quot;imgType&quot; value=&quot;&quot; /&gt;</code>，用来区分上传的是logo还是foot页脚</p>
<p>这些控制需要用JS来做：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 图片上传 */</span></div><div class="line">$(<span class="string">"#img_btn"</span>).click(function()&#123;</div><div class="line">  var img = $(<span class="string">"#img"</span>);</div><div class="line">  var foot = $(<span class="string">"#foot"</span>);</div><div class="line">  var shopId = $(<span class="string">"#shopIdSelect"</span>);</div><div class="line">  var msg=<span class="string">""</span>;</div><div class="line">  <span class="keyword">if</span>(shopId.val()&lt;<span class="string">"0"</span>)&#123;</div><div class="line">     msg += <span class="string">"请选择店铺！"</span>;</div><div class="line">     shopId.focus();</div><div class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(img.val()==<span class="string">""</span> &amp;&amp; foot.val()==<span class="string">""</span>)&#123;</div><div class="line">     msg += <span class="string">"请选择要上传的图片！"</span>;</div><div class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(img.val()!=<span class="string">""</span> &amp;&amp; foot.val()==<span class="string">""</span>)&#123;    <span class="comment">//如果上传的是LOGO</span></div><div class="line">     document.getElementById(<span class="string">'img_type'</span>).value=<span class="string">"logo"</span>;</div><div class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(img.val()==<span class="string">""</span> &amp;&amp; foot.val()!=<span class="string">""</span>)&#123;    <span class="comment">//如果上传的是页脚</span></div><div class="line">     document.getElementById(<span class="string">'img_type'</span>).value=<span class="string">"foot"</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (msg != <span class="string">""</span>)&#123;</div><div class="line">     alert(msg);</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">  <span class="comment">// 表单提交</span></div><div class="line">     $(<span class="string">"#uploadForm"</span>).submit();</div><div class="line">  &#125;        </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>在这里使用<code>document.getElementById(&#39;img_type&#39;).value=&quot;logo&quot;;</code>进行复制，传递到后台</p>
<p>Action：uploadLogoAction.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">uploadLogoAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span></span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1590947402900249195L</span>;</div><div class="line"><span class="comment">/** 注入业务层*/</span></div><div class="line"><span class="keyword">private</span> SystemManageService systemManageService;</div><div class="line"><span class="keyword">private</span> ShoppingMerchantShop shoppingMerchantShop;</div><div class="line"><span class="keyword">private</span> List&lt;ShoppingMerchantShop&gt; shoppingMerchantShopList;</div><div class="line"><span class="comment">/** 图片上传的三个属性 */</span></div><div class="line"><span class="keyword">private</span> File[] img;</div><div class="line"><span class="keyword">private</span> String[] imgFileName;</div><div class="line"><span class="keyword">private</span> String[] imgContentType;</div><div class="line"><span class="comment">/** 店铺ID */</span></div><div class="line"><span class="keyword">private</span> String shopId;</div><div class="line"><span class="keyword">private</span> String imgType;</div><div class="line"><span class="comment">/** 图片上传 只要一张不符合要求另一张也不能上传*/</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">uploadPic</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//设定拖存储在服务器的路径</span></div><div class="line">        String realPath = <span class="string">"/skin/"</span>+shopId+<span class="string">"/sitemesh"</span>;</div><div class="line">        String savePath = ServletActionContext.getServletContext().getRealPath(realPath);</div><div class="line">        System.err.println(<span class="string">"项目部署的路径："</span>+savePath);</div><div class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(File file : img)&#123;</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.filterTypes(imgContentType))&#123;</div><div class="line">                </div><div class="line">                FileUtils.copyFile(file, <span class="keyword">new</span> File(savePath+File.separator+imgFileName[index]));</div><div class="line">                <span class="comment">//图片路径</span></div><div class="line">                String picPath = realPath+<span class="string">"/"</span>+imgFileName[index];</div><div class="line">                </div><div class="line">                ActionContext.getContext().put(<span class="string">"shopId"</span>,shopId );                </div><div class="line">                <span class="comment">//上传成功后保存图片路劲到店铺表</span></div><div class="line">                shoppingMerchantShop = <span class="keyword">new</span> ShoppingMerchantShop();</div><div class="line">                shoppingMerchantShop.setShopId(shopId);</div><div class="line">                <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;    <span class="comment">//如果是LOGO</span></div><div class="line">                    <span class="keyword">if</span>(imgType.equals(<span class="string">"foot"</span>))&#123;    <span class="comment">//如果只上传了一个，如果上传的是页脚</span></div><div class="line">                        shoppingMerchantShop.setShopFoot(picPath);</div><div class="line">                        <span class="comment">//保存上传后的路径、用于页面上回显</span></div><div class="line">                        ActionContext.getContext().put(<span class="string">"imgSrcFoot"</span>,picPath);</div><div class="line">                    &#125;<span class="keyword">else</span>&#123;</div><div class="line">                        shoppingMerchantShop.setShopLogo(picPath);                        </div><div class="line">                        <span class="comment">//保存上传后的路径、用于页面上回显</span></div><div class="line">                        ActionContext.getContext().put(<span class="string">"imgSrcLogo"</span>,picPath);</div><div class="line">                    &#125;</div><div class="line">                &#125;<span class="keyword">else</span>&#123;    <span class="comment">//如果是页脚</span></div><div class="line">                    shoppingMerchantShop.setShopFoot(picPath);</div><div class="line">                    ActionContext.getContext().put(<span class="string">"imgSrcFoot"</span>,picPath);</div><div class="line">                &#125;</div><div class="line">                index++;                </div><div class="line"></div><div class="line">                systemManageService.updateMerchantShop(shoppingMerchantShop);</div><div class="line">                setMessage(<span class="string">"上传成功！"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">        setMessage(<span class="string">"上传失败！"</span>);</div><div class="line">        log(ex);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> SUCCESS;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 判断图片格式是否符合要求</div><div class="line"> * <span class="doctag">@param</span> types 图片格式</div><div class="line"> * <span class="doctag">@return</span></div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filterTypes</span><span class="params">(String[] types)</span></span>&#123;</div><div class="line">    <span class="comment">//WebConstant.uploadImgTypes是一个数组，存放图片格式&#123;"image/png","image/jpeg"...&#125;</span></div><div class="line">    String[] imgTypes = WebConstant.uploadImgTypes;</div><div class="line">    Boolean flag =<span class="keyword">true</span>;</div><div class="line">    <span class="keyword">for</span>(String type : types)&#123;</div><div class="line">        <span class="keyword">for</span>(String trueType : imgTypes)&#123;</div><div class="line">            <span class="keyword">if</span>(!trueType.equals(type))&#123;</div><div class="line">                flag = <span class="keyword">false</span>;</div><div class="line">                setMessage(<span class="string">"上传的图片类型是不被允许的！"</span>);</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                flag = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> flag;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/** get and set  */</span></div><div class="line">......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> struts </tag>
            
            <tag> 文件上传 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Struts2的视图转发类型总结]]></title>
      <url>/2013/09/21/Struts2-view-forwarding-type-summary/</url>
      <content type="html"><![CDATA[<h2 id="dispatcher方式"><a href="#dispatcher方式" class="headerlink" title="dispatcher方式"></a>dispatcher方式</h2><p>这种方式是struts2中默认的转发类型，即内部请求转发，类似于forward的方式。用于指定使用JSP作为视图的结果类型。</p>
<h2 id="redirect方式"><a href="#redirect方式" class="headerlink" title="redirect方式"></a>redirect方式</h2><p>用于直接跳转到其他URL的结果类型。这种结果类型与dispatcher结果类相对，dispatcher结果类型是将请求forword（转发）到指定的JSP资源；而redirect结果类型，则意味着将请求redirect（重定向）到指定的视图资源。</p>
<p>dispatcher与redirect的差别就是重定向和转发的差别：重定向会丢失所以的参数、请求属性–当然也就丢失了Action的出来结果。</p>
<p>使用redirect结果类型的效果是，系统将调用<code>HttpServletResponse</code>的s<code>endRedirect（String）</code>方法来重定向指定视图资源，这种重定向的效果就是重新产生一个请求，因此所有的请求参数、请求属性、Action实例和Action中封装的属性全部丢失。地址栏的URL会发生改变。</p>
<p>配置一个redirect类型结果，可以指定如下两个参数。</p>
<ul>
<li>location：改参数指定Action处理完用户请求后跳转的地址。</li>
<li>parse：改参数指定是否允许在location参数值中使用表达式，改参数默认为true。与前面的类似，通常无需指定parse属性值。</li>
</ul>
<p>使用这个类型也可以指定跳到一个Action，只是需要添加<code>.action</code>后缀，已达到redirectAction结果类型效果。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;action name="redirect"&gt;</div><div class="line">    &lt;result type="redirect"&gt;/add.jsp&lt;/result&gt;</div><div class="line">&lt;/action&gt;</div><div class="line"></div><div class="line">&lt;action name="redirect"&gt;</div><div class="line">    &lt;result type="redirect"&gt;addUser.action&lt;/result&gt;</div><div class="line">&lt;/action&gt;</div></pre></td></tr></table></figure>
<h2 id="redirectAction"><a href="#redirectAction" class="headerlink" title="redirectAction"></a>redirectAction</h2><p>这种方式可以简单的理解成转向到另一个Action。这种配置往往在下面的情况下需要用到：例如，当管理员添加完一个用户后，系统自动跳转到用户列表的界面。</p>
<p>这种结果类型与redirect类型非常相似，一样是重新生成一个全新的请求。但与redirect结果类型区别在于：redirectAction使用ActionMapperFactory提供的ActionMapper来重定向请求。</p>
<p>配置一个redirect类型的结果，可以指定如下两个参数。（针对不在同一个配置文件中）</p>
<ul>
<li>actionName：该参数指定重定向的Action名。</li>
<li>namespace：该参数需要指定需要重定向的Action所在命名空间。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;action name="redirectAction"&gt;</div><div class="line">   &lt;result type="redirectAction"&gt;listAction&lt;/result&gt;</div><div class="line">&lt;/action&gt;</div></pre></td></tr></table></figure>
<p>该action必须和redirectAction处在同一个package下面。那么如果不在同一个包下，则需进行如下配置：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;result type="redirectAction"&gt;</div><div class="line">   &lt;param name="actionName"&gt;XXX&lt;/param&gt;</div><div class="line">   &lt;param name="namespace"&gt;YYY&lt;/param&gt;</div><div class="line">&lt;/result&gt;</div></pre></td></tr></table></figure></p>
<p>使用redirectAction结果类型时，系统将重新生成一个请求，只是改请求的URL不是一个具体的视图资源，而是另一个Action。因此前一个Action处理结果、请求参数、请求属性会全部丢失。</p>
<h2 id="chain"><a href="#chain" class="headerlink" title="chain"></a>chain</h2><p>这个视图类型也用了跳转到另一个Action，与前面的不同的是，他的请求参数和属性都可以保留，比如，系统中的删除功能，回到之前查询的action，要保存页码回到之前删除记录的当前页，用<code>chain</code>就可以做到，几乎几乎就是前面两种的增强版。推荐开发中直接忽略redirect和redirectAction类型，直接用这个chain就好了。但很奇怪，在MyEclipse8.6下会报错，这个可能就比较坑爹了，令人郁闷！但并不影响运行结果。可能是Myeclipse8.6的Bug吧。</p>
<h2 id="plainText"><a href="#plainText" class="headerlink" title="plainText"></a>plainText</h2><p>这种方式一般来说使用的比较少，可能用到的情况：原样输出源代码。配置如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;action name="abc" &gt;</div><div class="line">   &lt;result type="plainText"&gt;</div><div class="line">       &lt;param name="location"&gt;/index.jsp&lt;/param&gt;</div><div class="line">       &lt;param name="charSet"&gt;UTF-8&lt;/param&gt;</div><div class="line">   &lt;/result&gt;</div><div class="line">&lt;/action&gt;</div></pre></td></tr></table></figure></p>
<p>这时，index.jsp的源代码则会以文本方式显示在浏览器中。</p>
<h2 id="freeMarker、Velocity"><a href="#freeMarker、Velocity" class="headerlink" title="freeMarker、Velocity"></a>freeMarker、Velocity</h2><p>用于指定使用FreeMarker、Velocity模板作为视图结果类型。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;result name="success"type="freemarker"&gt;foo.ftl&lt;/result&gt;</div></pre></td></tr></table></figure></p>
<h2 id="HttpHeader"><a href="#HttpHeader" class="headerlink" title="HttpHeader"></a>HttpHeader</h2><p>用来控制特殊的Http行为。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;result name="success"type="httpheader"&gt;   </div><div class="line">       &lt;paramname="status"&gt;204&lt;/param&gt; </div><div class="line">       &lt;paramname="headers.a"&gt;a custom header value&lt;/param&gt;  </div><div class="line">       &lt;paramname="headers.b"&gt;another custom header value&lt;/param&gt;  </div><div class="line">&lt;/result&gt;  </div><div class="line"></div><div class="line">&lt;result name="proxyRequired"type="httpheader"&gt;   </div><div class="line">       &lt;paramname="error"&gt;305&lt;/param&gt; </div><div class="line">      &lt;paramname="errorMessage"&gt;this action must be accessed through aprozy&lt;/param&gt;  </div><div class="line">&lt;/result&gt;</div></pre></td></tr></table></figure></p>
<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>向浏览器发送InputSream对象，通常用来处理文件下载。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;result name="success"type="stream"&gt;   </div><div class="line">      &lt;paramname="contentType"&gt;image/jpeg&lt;/param&gt;  </div><div class="line">      &lt;paramname="inputName"&gt;imageStream&lt;/param&gt;  </div><div class="line">      &lt;paramname="contentDisposition"&gt;attachment;filename="document.pdf"&lt;/param&gt;   </div><div class="line">      &lt;paramname="bufferSize"&gt;1024&lt;/param&gt;  </div><div class="line">&lt;/result&gt;</div></pre></td></tr></table></figure></p>
<h2 id="xslt"><a href="#xslt" class="headerlink" title="xslt"></a>xslt</h2><p>用于与XML/XSLT整合的结果类型。</p>
<p>以上这么多，对于普通的项目来说，一般开发中直接用chain类型就好了，其他的本人认为几乎就是鸡肋。。。。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 备忘 </tag>
            
            <tag> 总结 </tag>
            
            <tag> struts </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用jquery.from.js+Struts2实现图片异步上传]]></title>
      <url>/2013/09/19/%E4%BD%BF%E7%94%A8jquery-from-js-Struts2%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%BC%82%E6%AD%A5%E4%B8%8A%E4%BC%A0/</url>
      <content type="html"><![CDATA[<p>jquery.form.js是jQuery的一个官方用语支持异步上传文件的插件。官方网站：<a href="http://plugins.jquery.com/form/" target="_blank" rel="external">http://plugins.jquery.com/form/</a> ，结合Struts2三步轻松实现文件上传。</p>
<p>一般是针对一个页面可能不止一个Form表单，所以在一个面提交表单会影响到另一个表单，为此，图片上传表单就可以使用无刷新提交方式上传，也就是异步上传，这时jquery.from.js就派上用场了。</p>
<p><strong>在HTML页面上导入JS</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/jquery.form.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">!—图片上传</span> <span class="attr">--</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">s:form</span> <span class="attr">id</span>=<span class="string">"picForm"</span> <span class="attr">name</span>=<span class="string">"picForm"</span> <span class="attr">action</span>=<span class="string">"/notice/showAddNotice.action"</span> <span class="attr">method</span>=<span class="string">"post"</span></span></div><div class="line">   <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"pic"</span>  <span class="attr">size</span>=<span class="string">"30"</span>/&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"上传"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">s:form</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>写JS</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 为表单绑定异步上传的事件</span></div><div class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// 为表单绑定异步上传的事件</span></div><div class="line">    $(<span class="string">"#picForm"</span>).ajaxForm(&#123;</div><div class="line">        <span class="attr">url</span> : <span class="string">"$&#123;pageContext.request.contextPath&#125;/notice/uploadPic.action"</span>, <span class="comment">// 请求的url</span></div><div class="line">        type : <span class="string">"post"</span>, <span class="comment">// 请求方式</span></div><div class="line">        dataType : <span class="string">"text"</span>, <span class="comment">// 响应的数据类型</span></div><div class="line">        <span class="keyword">async</span> :<span class="literal">true</span>, <span class="comment">// 异步</span></div><div class="line">        success : <span class="function"><span class="keyword">function</span>(<span class="params">imageUrl</span>)</span>&#123;</div><div class="line">        <span class="comment">//alert(imageUrl);</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">error</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            alert(<span class="string">"数据加载失败！"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">// 为提交按钮绑定事件</span></div><div class="line">    $(<span class="string">"#saveBtn"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// 表单输入较验</span></div><div class="line">    <span class="keyword">var</span> title = $(<span class="string">"#title"</span>);</div><div class="line">    <span class="comment">// 获取textarea的内容</span></div><div class="line">    <span class="keyword">var</span> content = tinyMCE.get(<span class="string">'content'</span>).getContent();</div><div class="line">    <span class="keyword">var</span> msg = <span class="string">""</span>;</div><div class="line">    <span class="keyword">if</span> ($.trim(title.val()) == <span class="string">""</span>)&#123;</div><div class="line">       msg = <span class="string">"公告标题不能为空！"</span>;</div><div class="line">       title.focus();</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ($.trim(content) == <span class="string">""</span>)&#123;</div><div class="line">       msg = <span class="string">"内容不能为空！"</span>;</div><div class="line">    &#125;</div><div class="line">         msg = <span class="string">""</span>;</div><div class="line">    <span class="keyword">if</span> (msg != <span class="string">""</span>)&#123;</div><div class="line">        alert(msg);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="comment">// 表单提交</span></div><div class="line">    $(<span class="string">"#noticeForm"</span>).submit();</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>写Struts2代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">uploadPicAjax</span> <span class="keyword">extends</span> <span class="title">AbstractAjaxAction</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4742151106080093662L</span>;</div><div class="line"><span class="comment">/** Struts2文件上传的三个属性 */</span></div><div class="line"><span class="keyword">private</span> File pic;</div><div class="line"><span class="keyword">private</span> String picFileName;</div><div class="line"><span class="keyword">private</span> String picContentType;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getJson</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">     <span class="comment">//获取项目部署的路径</span></div><div class="line">     String realPath = ServletActionContext.getServletContext().getRealPath(<span class="string">"/images/notice"</span>);</div><div class="line">     <span class="comment">//生成新的文件名</span></div><div class="line">     <span class="comment">//获取文件的后缀名 aa.jpg --&gt; jpg</span></div><div class="line">     String newFileName=UUID.randomUUID().toString()+<span class="string">"."</span>+FilenameUtils.getExtension(picFileName);</div><div class="line">     FileUtils.copyFile(pic, <span class="keyword">new</span> File(realPath + File.separator + newFileName));</div><div class="line">     <span class="keyword">return</span> <span class="string">"/images/notice/"</span> + newFileName;</div><div class="line">&#125;</div><div class="line"><span class="comment">/** setter and getter method  **/</span></div><div class="line">        ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我这里继承了一个抽象的的处理Ajax的基类，所以直接返图片地址回到页面。你可以return到一个视图。</p>
<p><strong>配置Struts2.xml</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 图片的异步上传 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"uploadPic"</span> <span class="attr">class</span>=<span class="string">"com.wise.hrm.action.notice.uploadPicAjax"</span>&gt;</span><span class="tag">&lt;/<span class="name">action</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>好了，从页面到后台就已经写完了、、、、这样就可以上传了。完毕！</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> struts </tag>
            
            <tag> 文件上传 </tag>
            
            <tag> jquery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring IOC(依赖注入、控制反转)概念理解]]></title>
      <url>/2013/08/21/Spring-IOC-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E3%80%81%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC-%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>假设A组件依赖B组件</p>
<ol>
<li>自己new一个。(主动)</li>
<li>找工厂去要一个。(主动)</li>
<li>等，等容器为我们提供一个被依赖组件。(被动)<a id="more"></a>
传统模式下，无论是A去new一个B组件，还是通过工厂去获取B组件，都要需要A组件主动去获取被依赖的B组件。</li>
</ol>
<p>用了Spring之后， Spring容器会负责把被依赖的B组件注入到A组件中，A只要被动地等待即可。</p>
<p>——此时A对B的控制关系，由原来的主动变成了被动，Johnson将之成为IoC（从A组件角度起名字）。</p>
<p>Martine Fowler —— IoC难理解，又给这个技术一个名字：依赖注入（DI，从Spring容器角度起名字）。</p>
<p>IoC和DI是同一个事情的两个不同说法。</p>
<p>依赖注入分为三种：</p>
<ul>
<li>接口注入：很少使用。</li>
<li>设值注入：就是通过property元素控制调用setter方法，就是所谓的设值注入。</li>
<li>构造注入：就是constructor-arg控制调用有参数的构造器，由构造器来注入被依赖组件。就是所谓的构造器注入。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[String、StringBuffer、StringBuilder的性能区别]]></title>
      <url>/2013/08/18/String%E3%80%81StringBuffer%E3%80%81StringBuilder/</url>
      <content type="html"><![CDATA[<p>String 字符串常量<br>StringBuffer 字符串变量（线程安全）<br>StringBuilder 字符串变量（非线程安全）</p>
<p>简要的说，<code>String</code>类型和<code>StringBuffer</code>类型的主要性能区别其实在于<code>String</code>是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。<br><a id="more"></a><br>而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String S1 = “This is only a” + “ simple” + “ test”;</div><div class="line">StringBuffer Sb = <span class="keyword">new</span> StringBuilder(“This is only a”).append(“ simple”).append(“ test”);</div></pre></td></tr></table></figure></p>
<p>你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String S1 = “This is only a” + “ simple” + “test”;</div></pre></td></tr></table></figure></p>
<p>其实就是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String S1 = “This is only a simple test”;</div></pre></td></tr></table></figure></p>
<p>所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String S2 = “This is only a”;</div><div class="line">String S3 = “ simple”;</div><div class="line">String S4 = “ test”;</div><div class="line">String S1 = S2 +S3 + S4;</div></pre></td></tr></table></figure></p>
<p>这时候 JVM 会规规矩矩的按照原来的方式去做<br>在大部分情况下 <code>StringBuffer &gt; String</code></p>
<p><strong>Java.lang.StringBuffer</strong><br>线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。</p>
<p>可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。</p>
<p>StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。</p>
<p>例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 <code>z.append(&quot;le&quot;)</code> 会使字符串缓冲区包含“startle”，而 <code>z.insert(4, &quot;le&quot;)</code> 将更改字符串缓冲区，使之包含“starlet”。</p>
<p>在大部分情况下 <code>StringBuilder &gt; StringBuffer</code></p>
<p><strong>java.lang.StringBuilde</strong><br>java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> javase </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据库优化(一)：索引及索引合理利用]]></title>
      <url>/2013/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96(%E4%B8%80)%E7%B4%A2%E5%BC%95%E5%8F%8A%E7%B4%A2%E5%BC%95%E5%90%88%E7%90%86%E5%88%A9%E7%94%A8/</url>
      <content type="html"><![CDATA[<p><strong>1、什么是索引</strong></p>
<p>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可以快速访问数据库表中特定的信息。<br>索引也是用来定位的。<br>索引分为聚集索引和非聚集索引两种。<br><a id="more"></a><br><strong>2、索引的优点</strong></p>
<p>聚集索引是按照数据存放的物理位置为顺序的，而非聚集索引就不样了；聚集索引能提高多行检索的速度，而非聚集索引对单行索引的速度很快。</p>
<ol>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；</li>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因；</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义；</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间；</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
</ol>
<p><strong>3、索引的缺点</strong></p>
<p>一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。</p>
<ol>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加;</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚集索引，那么需要的空间就会更大。</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li>
</ol>
<p><strong>4、哪些列适合建索引？</strong></p>
<p>1）在经常需要搜索的列上，可以加快搜索的速度；<br>2）在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；<br>3）在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；<br>4）在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；<br>5）在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；<br>6）在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。  </p>
<p><strong>5、不应该创建索引的的这些列具有下列特点</strong><br>1）对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p>
<p>2）对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p>
<p>3）对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少,不利于使用索引。</p>
<p>4）当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改操作远远多于检索操作时，不应该创建索引。</p>
]]></content>
      
        <categories>
            
            <category> 数据库&amp;SQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[抽象类与接口完全释疑]]></title>
      <url>/2012/09/08/abstract-class-and-interface/</url>
      <content type="html"><![CDATA[<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h3 id="抽象方法和抽象类"><a href="#抽象方法和抽象类" class="headerlink" title="抽象方法和抽象类"></a>抽象方法和抽象类</h3><p>抽象类与抽象方法必须使用<code>abstract</code>修饰符来定义，有抽象方法的类只能被定义成抽象类，抽象类里可以没有抽象方法。<br><a id="more"></a><br>抽象方法和抽象类的规则如下：</p>
<ul>
<li>抽象类必须使用<code>abstract</code>修饰符来修饰，抽象方法也必须使用<code>abstract</code>修饰符来修饰，抽象方法不能有方法体。</li>
<li>抽象类不能被实例化，无法使用<code>new</code>关键字来调用抽象类的构造器创建抽象类的实例。即使抽象类里不包含抽象方法，这个抽象类也不能创建实例。</li>
<li>抽象类可以包含Field、方法（普通方法和抽象方法都可以）、构造器、初始化块、内部类、枚举类6种成分。抽象类的构造器不能用于创建实例，主要是用于被其子类调用。</li>
<li>含有抽象方法的类（包括直接定义了一个抽象方法；继承了一个抽象父类，但没有完全实现父类包含的抽象方法，以及实现了一个接口，但没有完全实现接口包含的抽象方法3种情况）只能被定义成抽象类。</li>
</ul>
<p>归纳起来，可以用“有得有失“4个字来描述抽象类。”得“指的是抽象类多了一个能力：抽象类可以包含抽象方法；”失“指的是抽象类失去了一个能力：抽象类不能用于创建实例。</p>
<p>定义抽象方法只需在普通方法上增加一个<code>abstract</code>修饰符，并把普通方法的方法体（也就会方法后花括号括起来的部分）全部去掉，并在方法后增加分号即可。</p>
<p>抽象方法和空方法体的方法不是同一个概念。例如:<code>public abstract void test();</code>是一个抽象方法，他根本没有方法体，即方法定以后没有一对花括号；但<code>public viod test(){}</code>方法回一个普通方法，他已经定义了方法体，只是方法体为空，即他的方法体什么也不做，因此这个方法不可以使用<code>abstract</code>来修饰。</p>
<p>定义抽象类只需要在普通类上增加<code>abstract</code>修饰符即可。甚至一个普通类（没有包含抽象方法的类）增加abstract修饰符后也将变成抽象类。</p>
<p>抽象类不能创建实例，只能被当做父类被其他子类继承。</p>
<p>利用抽象类和抽象方法的优势，我们可以更好的发挥多态的优势，使得程序更加灵活。</p>
<p>当使用<code>abstract</code>修饰类时，表名这个类只能被继承；当使用<code>abstract</code>修饰方法时，表名这个方法必须由只能提供实现（即重写）。而<code>final</code>修饰的类不能被继承，<code>final</code>修饰的方法不能被重写。因此，<strong>final和abstract永远不能同时使用</strong>。</p>
<blockquote>
<p> <code>abstract</code>不能用于修饰Field，不能用于修饰局部变量，即没有抽象变量、没有抽象Field等说法；abstract也不能用于修饰构造器，没有抽象构造器，抽象类里定义的构造器只能是普通构造器。</p>
</blockquote>
<p>除此之外，当使用<code>static</code>修饰一个方法时，表名这个方法属于该类本身，即通过类就可以调用该方法，但如果该方法被定义成抽象方法，则将导致通过该类来调用该方法时出现错误（调用一个没有方法体的方法肯定会引起错误）。<strong>因此<code>static</code>和<code>abstract</code>不能同时修饰某个方法，即没有所谓的类抽象方法</strong>。</p>
<p><code>abstract</code>修饰的方法必须被其子类重写才有意义，否则这个方法将永远不会有方法体，因此<code>abstract</code>方法不能被定义为<code>private</code>访问权限，<strong>即<code>private</code>和<code>abstract</code>也不能同时使用。</strong></p>
<h3 id="抽象类的作用"><a href="#抽象类的作用" class="headerlink" title="抽象类的作用"></a>抽象类的作用</h3><p>从前面可以看出，抽象类不能创建实例，只能被当成父类来被继承。从语义的角度来看，抽象类是从多个具体类里抽象出来的父类，它具有更高层次的抽象。从多个具有相同特征的类中抽象出一个抽象类，以这类作为其子类的模板，从而避免了子类设计的随意性。</p>
<p>抽象类提现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会大致保留抽象类的行为方式。</p>
<p>如果编写一个抽象父类，父类提供了多个子类通用的方法，并把一个或多个方法留给其子类实现，这就是一个钟模板模式，模板模式也是非常常见的简单设计模式之一。</p>
<p>模板模式在面向对象的软件中很常用，其原理很简单，实现也很简单。下面是使用模板模式的一些简单规则：</p>
<ul>
<li>抽象父类可以只定义需要使用的某些方法，把不能实现的部分抽象成抽象成抽象方法，留给其子类去实现。</li>
<li>父类中可能包含需要调用的其他系列方法的方法，这些被调用的订单既可以由父类实现，也可以又其子类实现。父类里提供的方法只是定义了一个通用算法，其实现也许并不完全由自身实现，而必须依赖其子类的辅助。</li>
</ul>
<h2 id="更彻底的抽象-接口"><a href="#更彻底的抽象-接口" class="headerlink" title="更彻底的抽象-接口"></a>更彻底的抽象-接口</h2><p>接口的语法详细说明：</p>
<ul>
<li>修饰符可以是public或者省略，如果省略了public反问控制符，则默认采用包权限反问控制符，即只要在相同的包下才可以反问改接口。</li>
<li>接口名应该与类名采用相同的命名规则</li>
<li>一个接口可以有多个直接父接口，但接口只能继承接口，不能继承类。</li>
</ul>
<p>由于接口定义的是一种规范，因此接口里不能包含构造器和初始化块定义。接口里可以包含Field(只能是常量)、方法（只能是抽象实例方法）、内部类（包括内部接口、枚举）定义。</p>
<p>对比接口和类的定义方式不难发现接口的成员比类少了两种成员，而且接口里的Field只能是常量，接口里的方法只能是抽象方法。</p>
<p>前面已经说过了，接口里定义的是多个类共同的公共行为规范，因此接口里的所有成员，包括常量、方法、内部类和枚举都是public反问权限。地故意接口的成员时，可以省略反问控制修饰符，如果指定反问控制修饰符，则只能使用public反问控制修饰符。</p>
<p>对于接口里定义的常量Field而言，他们是接口相关的，而且他们只能是常量，因此系统会自动为这些Feild增加static和Final两个修饰符。也就是说，在接口里定义Feild时，不管是否使用public static final修饰符，接口里的Feild总将使用这个三个修饰符来修饰。而且，接口里没有构造器和初始化块，因此接口里的Feild只能在定义时指定默认值。</p>
<p>接口里定义Feild采用如下两行代码的结果完全一样。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//系统自动为接口里定义的Feild增加public static final修饰符</span></div><div class="line"><span class="keyword">int</span> MAX_SIZE=<span class="number">50</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE=<span class="number">50</span>;</div></pre></td></tr></table></figure></p>
<p>接口的继承：接口的继承和类继承不一样，接口完全支持多继承，即一个接口可以有多个直接付接口。和类继承相似，子接口扩展某个父类接口，将会获得接口里定义的所有抽象方法、常量Feild、内部类和枚举类定义。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>接口和抽象类很像，他们都有如下特征：</p>
<ul>
<li>接口和抽象类都不能被实例化，他们都位于继承树的顶端，用于被其他类实现和继承。</li>
<li>接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。</li>
</ul>
<p>但接口和抽象类之间差别非大，这种差别主要体现在二者设计目的上。下面具体分析二者的差别。</p>
<p>接口作为系统与外界交互的窗口，接口体现的是一种规范。对于接口的实现者而言，接口规定了实现者必须向外提供哪些服务（一方法的形式来提供）；对于接口的调用者来说，接口规定了调用者可以调用哪些服务，以及如何调用这些服务（就是如何来调用方法）。当在一盒程序中使用接口时，接口是多个模块间的耦合标准；当在多个应用程序之间使用接口时，接口是多个程序之间通信标准。</p>
<p>从某个程度上来讲，接口类似于整个系统的“总纲”，他制定了系统个模块应该遵循的标准，因此一个系统中接口不应该经常改变。一旦接口改变，对整个系统甚至其他系统的影响将是辐射式的，导致系统中大部分类都需要改写。</p>
<p>抽象类则不一样，抽象类作为系统中多个子类的共同父类，他 所体现的是一种模板模式设计。抽象类作为多个系统中子类的抽象父类，可以被当成系统实现过程中的中间产品，这个中间产品已经实现了系统的部分功能（那些已经提供实现的方法），但这个产品依然不能当成最终产品，必须有更进一步的完善，这种完善可能有几种不同的方式。</p>
<p>除此之外，接口和抽象类在用法上还有如下差别：</p>
<ul>
<li>接口里只能保护抽象方法，不包含已经提供实现的方法；抽象类则完全可以包含普通方法。</li>
<li>接口里不能定义静态常；不可以定义普通Feild； 抽象类则既可以定义常量Feild，也可以定义普通Feild。</li>
<li>接口里不包含构造器；抽象类里可以包含构造器，抽象类的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化造作。</li>
<li>接口里不能包含初始化块；但抽象类完全可以包含初始化块。</li>
<li>一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承的不足。</li>
</ul>
<p><del>~完毕</del>~</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> javase </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[==和equals方法终极解析]]></title>
      <url>/2012/09/02/==%E5%92%8Cequals%E6%96%B9%E6%B3%95%E7%BB%88%E6%9E%81%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>Java程序中测试两个变量是否相等有两种方式，一种是利用==运算符，另一种是利用equals方法。</p>
<p>当使用==来判断两个变量是否相等时，<strong>如果两个变量都是基本类型变量，且都是数字类型</strong>（不要求数据类严格相同），则只要两个变量的值相等，就会返回true。</p>
<p><strong>但对于两个引用类型变量</strong>，他们必须指向同一个对象时，==判断才会返回true。==可用于比较两个类型上没有父子关系的两个对象。下面的程序示范了使用==来判断两种类型变量对否相等的结果。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EqualsTest</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> it = <span class="number">65</span>;</div><div class="line">        <span class="keyword">float</span> fl=<span class="number">65.0f</span>;</div><div class="line">        System.out.println(<span class="string">"65和65.0f是否相等？"</span>+(it == fl));      <span class="comment">//输出true;</span></div><div class="line"></div><div class="line">        <span class="keyword">char</span> ch = <span class="string">'A'</span>;</div><div class="line">        System.out.println(<span class="string">"65和'A'是否相等？"</span>+(it == ch));      <span class="comment">//输出true;</span></div><div class="line"></div><div class="line">        String str1= <span class="keyword">new</span> String(<span class="string">"hello"</span>);</div><div class="line">        String str2 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</div><div class="line">        System.out.println(<span class="string">"str1和str2是否相等？"</span>+(str1 == str2));      <span class="comment">//输出false;</span></div><div class="line">        System.out.println(<span class="string">"str1是否equals str2？"</span>+(str1.equals(str2)));      <span class="comment">//输出true;</span></div><div class="line"></div><div class="line">        <span class="comment">//由于java.lang.string与EqualsTest类没有继承关系</span></div><div class="line">        <span class="comment">//所以下面的语句导致编译错误</span></div><div class="line">        <span class="comment">// System.out.println("hello"==new EqualsTest());</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行上面的程序，可以看到65、65.0f和’A’相等。但对于str1和str2，因为他们都是引用类型变量，他们分别指向两个通过new关键字创建的String对象，因此str1和str2两个变量不相等。</p>
<p>对于Java菜鸟而言，String还有一个非常容易迷惑人的地方：’’hello’’直接量和 new String(“hello”)有什么区别呢？当Java程序中直接使用形如“hello”的字符串直接量（包括子编译时就可以计算出来的字符串值）时，JVM将会使用常量池来管理这些字符串；当使用new String(“hello”)时，JVM先会使用常量池来管理”hello”直接量，再调用String类的构造器来创建一个新的String对象，新创建的String对象被保存在对内存中。换句话说<code>new String(&quot;hello&quot;)</code>一共产生了两个对象。</p>
<p><strong>提示</strong> </p>
<blockquote>
<p>常量池，专门用于管理在编译期被确定并保存在编译的.class文件中的一些数据，它包括了关于类、方法、接口中的常量，还包括字符串常量。</p>
</blockquote>
<p>下面程序示范了JVM使用常量池管理字符串直接量的情形。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">stringCompareTest</span></span>&#123;</div><div class="line">    <span class="comment">//下面程序示范了JVM使用常量池管理字符串直接量的情形</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="comment">//s1直接引用常量池中的''你好Java"</span></div><div class="line">        String s1 = <span class="string">"你好Java"</span>;</div><div class="line">        String s2 = <span class="string">"你好"</span>;</div><div class="line">        String s3 = <span class="string">"Java"</span>;</div><div class="line"></div><div class="line">            <span class="comment">//s4后面的字符串值可以在编译期就确定下来</span></div><div class="line">            <span class="comment">//s4直接引用常量池中的“你好Java”</span></div><div class="line">        String  s4=<span class="string">"你好"</span>+<span class="string">"Java"</span>;</div><div class="line"></div><div class="line">        <span class="comment">//s5后面的字符串值可以在编译期就确定下来</span></div><div class="line">        <span class="comment">//s5直接引用常量池中的“你好Java”</span></div><div class="line">        String s5 = <span class="string">"你"</span> + <span class="string">"好"</span> + <span class="string">"Java"</span>;</div><div class="line"></div><div class="line">        <span class="comment">//s6后面的字符串值不能在编译期就确定下来</span></div><div class="line">        <span class="comment">//不能引用常量池中字符串</span></div><div class="line">        String s6 =s2+s3;</div><div class="line"></div><div class="line">        <span class="comment">//使用new调用构造器将会创建一个新的string对象</span></div><div class="line">        <span class="comment">//s7引用对内存中新创建的string对象</span></div><div class="line">        String s7 = <span class="keyword">new</span> String(<span class="string">"你好Java"</span>);</div><div class="line"></div><div class="line">        System.out.println(s1==s4);   <span class="comment">//true</span></div><div class="line">        System.out.println(s1==s5);   <span class="comment">//true</span></div><div class="line">        System.out.println(s1==s6);   <span class="comment">//false</span></div><div class="line">        System.out.println(s1==s7);   <span class="comment">//false</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>JVM常量池保证相同的字符串直接量只有一个，不会产生多个副本。例子中的s1、s4、s5所引用的字符串可以在编译期就确定下来，因此他们都讲引用常量池的同一个字符窜对象。</p>
<p>使用<code>new String()</code>创建的字符串对象是运行时创建出来的，他被保存在运行时内存内（即对内存），不会放入常量池中。</p>
<p>但在很多时候，程序判断两个引用变量是否相等时，也希望有一种类似于“值相等”的判断规则，并不严格要求两个引用变量指向同一个对象。例如对于两个字符串变量，可能只是要求他们的引用字符串对象里包含的字符串序列相同即可认为相等。此时就可以利用String对象的equals反法来进行判断，例如上面程序中<code>str1.equals(str2)</code>将返回true。</p>
<p>equals方法是Object类提供的一个实例方法，因此所有引用变量都可以调用该方法来判断是否与其他引用变量相等。但是用这个方法判断两个对象相等的标准与==运输符没有区别，同样要求两个引用变量指向同一个对象才会返回true。因此这个Object类提供的equals反法没有太大的意义，如果希望采用自定义的相等标准，则可采用重写equals方法来实现。  </p>
<p><strong>提示</strong></p>
<blockquote>
<p>String已经重写了Object的equals()方法，String的equals()方法判断两个字符串相等的标准是：只要两个字符串所包含的字符序列相同，通过equals比较将返回true，否则将返回false。</p>
<p>网上很多地方和书上都说equals反法是判断两个对象值相等。这个说法是相当错误的，什么叫对象值呢？对象的值如何相等？实际上，重写equals方法就提供了自定义相等标准，你认为怎样是相等，那就怎样相等，一切都是你做主！</p>
</blockquote>
<p>重写equals反法就不再说明，写着太累了、、、。</p>
<p>Object默认提供的<code>equals()</code>只是比较地址，即Object类的equals方法比较的结果与==比较的结果完全相同。因此，在实际应用中常常需要重写equals方法，重写equals方法时，相等条件是又系统要求决定的，因此equals方法的实现也是又系统要求决定的。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
            <tag> javase </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[手把手教你GlassFish与Eclipse的集成安装、配置]]></title>
      <url>/2012/08/02/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0GlassFish%E4%B8%8EEclipse%E7%9A%84%E9%9B%86%E6%88%90%E5%AE%89%E8%A3%85%E3%80%81%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>不说开场白介绍了，不太会说，直接进入主题<br><a id="more"></a></p>
<h2 id="一、GlassFish安装配置之前需要先安装配置好JDK和Ant。"><a href="#一、GlassFish安装配置之前需要先安装配置好JDK和Ant。" class="headerlink" title="一、GlassFish安装配置之前需要先安装配置好JDK和Ant。"></a>一、GlassFish安装配置之前需要先安装配置好JDK和Ant。</h2><p>下面先介绍JDK和Ant的下载、安装和配置 </p>
<h3 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h3><p>这一步没什么好说的，基础的东西</p>
<p>[下载地址]：java.sun.com/javase/downloads/index.jsp这里有各个版本的JDK的下载，选择相应适合的版本下载， 下载完成是.exe格式文件，直接安装即可。注意：安装路径最好不要有空格。<br><img src="http://img5.ph.126.net/bho77jJ8VAD-UsAahDPG5Q==/591941876040217375.jpg" alt=""></p>
<p>配置环境：Windows下Java用到的环境变量主要有3个，JAVA_HOME,CLASSPATH,path </p>
<blockquote>
<p>JAVA_HOME设置：指向JDK的安装路径，这里假设是 D:\JDK6<br>path设置：保留原来的path内容，在其最后加上 %JAVA_HOME%\bin,别忘了中间用 ; 隔开。<br>CLASSPATH设置：”.;%JAVA_HOME%\lib\dt.jsr;%JAVA_HOME%\tools.jar;%JAVA_HOME%\bin”</p>
</blockquote>
<p>最前面的<code>.</code>是告诉JDK搜索class时先查找当前目录的class文件，至于classpath后面制定的具 体文件是由Java语言的import机制和jar机制决定的 </p>
<p>此时本人机器的配置如下：<br><img src="http://img7.ph.126.net/lgNyski4l6c6wvv_vQ8aBg==/1585267068852204137.jpg" alt=""></p>
<p>classpath的值：<code>.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar</code></p>
<h3 id="配置Ant-，很简单"><a href="#配置Ant-，很简单" class="headerlink" title="配置Ant ，很简单"></a>配置Ant ，很简单</h3><p>[下载]apache-ant-1.8.3-bin的下载请看附件2<br>[配置环境]: </p>
<ul>
<li>解压ant包到本地目录 </li>
<li>设置ANT_HOME=（实际解压缩的目录） </li>
<li>设置path，保留path原来的内容在其最后加上%ANT_HOME%\bin </li>
</ul>
<p>如上图ANT_HOME的值</p>
<h2 id="二、下面就真正开始GlassFish安装"><a href="#二、下面就真正开始GlassFish安装" class="headerlink" title="二、下面就真正开始GlassFish安装"></a>二、下面就真正开始GlassFish安装</h2><p>[下载地址]：GlassFish.dev.java.net/public/downloadsindex.html （如不能下载或下载不能用请下载附件4）</p>
<p>下载的GlassFish是一个jar包，例如：GlassFish-v2ur2-b04-windows.jar，下载后放在某个目录下，在设置好JDK和Ant相关的环境变量后转到命令行状态，</p>
<p><strong>解压：执行以下命令</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -Xmx256m -jar &quot;目标文件&quot;  即：java -Xmx256m -jar GlassFish-v2ur2-b04-windows.jar</div></pre></td></tr></table></figure></p>
<p>此步骤进行解压缩操作。会弹出一个确认对话框，窗口可能出现在最底层，现实桌面会发现窗口。另外，你需要拖动下滚动条才让您点击同意。或者一段时间后才可以下一步。 </p>
<p>正常解压情形：<br><img src="http://img0.ph.126.net/8pREaWt6t0RZPlyBb_b9OQ==/1355864962833028180.jpg" alt=""></p>
<p>成功后会在当前目录生成一个glassFish文件夹</p>
<p><strong>安装</strong><br>进入GlassFish主目录，会发现有一个setup.xml文件，继续执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">D:\&gt;glassfish&gt;ant -f setup.xml</div></pre></td></tr></table></figure></p>
<p>此命令完成GlassFish的安装 ,如图：<br><img src="http://img4.ph.126.net/C9SK7xe6aNgyOLP0X--CcQ==/612771024316790124.jpg" alt=""></p>
<p><strong>启动GlassFish服务</strong><br>进入GlassFish目录下的bin目录，执行以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">C:\user&gt;d:</div><div class="line">D:\&gt;cd glassfish\bin\</div><div class="line">D:\&gt;glassfish\bin&gt;asadmin start-domain</div></pre></td></tr></table></figure></p>
<p>如果执行成功，如下图：<br><img src="http://img6.ph.126.net/FWUDj3AaOmR60GKKGSbm2Q==/1360368562460394446.jpg" alt=""></p>
<p>如果这里出现问题，请到安装目录下查看，在bin同目录下是否有domains这个文件夹。如果没有，需要手动创建一个服务域， 代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\user&gt;asadmin create-domain --adminport 4848 domain1</div></pre></td></tr></table></figure></p>
<p>端口是4848，建议用户名是：admin，密码是adminadmin 和默认的统一。 </p>
<p><strong>测试</strong><br>GlassFish默认管理端口为4848，默认管理员为：admin，默认口令为：adminadmin,在浏览器上输入localhost:4848,就会出现管理控制台。输入<a href="http://localhost:4848" target="_blank" rel="external">http://localhost:4848</a></p>
<p><img src="http://img0.ph.126.net/LEQD6slh10QMVR-lyycjfw==/3074269695651578150.jpg" alt=""></p>
<p>如果能成功登陆，即这一步OK！接下里继续往下看：<br>停止GlassFish服务，同样进入GlassFish目录下的bin目录，执行以下命令<br>asadmin stop-domain<br><img src="http://img4.ph.126.net/g68YKkGemIiMS7XNUE-Mxw==/1094093234492008584.jpg" alt=""></p>
<p>GlassFish是通过ant来安装的，安装在脚本setup.xml下，在里面可以修改一下配置，比如端口等等<br>在setup.xml中主要有以下设置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"domain.name"</span> <span class="attr">value</span>=<span class="string">"domain1"</span>/&gt;</span>域名<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"instance.name"</span> <span class="attr">value</span>=<span class="string">"server"</span>/&gt;</span> </div><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"admin.user"</span> <span class="attr">value</span>=<span class="string">"admin"</span>/&gt;</span>管理员用户名</div><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"admin.password"</span> <span class="attr">value</span>=<span class="string">"adminadmin"</span>/&gt;</span>管理员密码</div><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"admin.port"</span> <span class="attr">value</span>=<span class="string">"4848"</span>/&gt;</span>管理平台端口</div><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"instance.port"</span> <span class="attr">value</span>=<span class="string">"8080"</span>/&gt;</span>实例端口，也就是通过这个端口来访问web应用<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"orb.port"</span> <span class="attr">value</span>=<span class="string">"3700"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"imq.port"</span> <span class="attr">value</span>=<span class="string">"7676"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"https.port"</span> <span class="attr">value</span>=<span class="string">"8181"</span>/&gt;</span>https端口</div></pre></td></tr></table></figure></p>
<p>根据需要修改以上设置，执行：ant -f setup.xml,如果系统没有安装ant，在GlassFish\lib\ant下有一个ant，安装结束后，进入GlassFish/bin下，在控制台下面命令启动GlassFish </p>
<p>asadmin start-domain domain1        //domain1是上面设置的domain.name,系统默认domain1 </p>
<p>启动结束后，asadmain stop-domain domain1        //停止服务器 </p>
<h2 id="三、在GlassFish中部署web应用"><a href="#三、在GlassFish中部署web应用" class="headerlink" title="三、在GlassFish中部署web应用"></a>三、在GlassFish中部署web应用</h2><p>有3种方式</p>
<p>第一种，可以直接将war或ear放在GlassFish/domain/autodeploy目录下，GlassFish启动后会自动部署 </p>
<p>第二是通过命令asadmain deploy部署应用，另外asadmain updeploy 可以卸载应用 </p>
<p>通过asadmain deploy –help 和 asadmain undeploy –help 获得更多帮助 </p>
<p>第三是通过GlassFish管理控制台 </p>
<p>以上3种我讲讲第2种，用命令行的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">进入glassfish的主目录下的bin目录：d: --&gt;cd glassfish\bin</div><div class="line">启动glassfish：asadmin start-domain</div><div class="line">部署项目：asadmin deploydir --name 你项目名 你项目的WebContent的绝对路径</div></pre></td></tr></table></figure></p>
<p>例如，我本人的情况，项目名li555（可以随便取，只是个标识）<br><img src="http://img8.ph.126.net/LTu_swIpWajwY8AmSVmDjQ==/2527645290879480998.jpg" alt=""></p>
<p>这样，你的glassfish服务器就开启了，项目可以运行了，你也可以在浏览器的管理控制台上看到和启动你的项目：<br>刷新你的管理控制台，在左边找到 “Web Applications”<br><img src="http://img1.ph.126.net/n6wVuF1uWqHY6HwxyEiVGA==/2537496915064435871.jpg" alt=""></p>
<p>不好意思，说错了，Action里的launch才是启动项目</p>
<h2 id="四、GlassFish与Eclipse的集成"><a href="#四、GlassFish与Eclipse的集成" class="headerlink" title="四、GlassFish与Eclipse的集成"></a>四、GlassFish与Eclipse的集成</h2><p>打开你的Eclipse，访问菜单 新建一个Server<br><img src="http://img1.ph.126.net/RHMguhfxnT7u1Kjc4k3o-Q==/600104650364813321.jpg" alt=""></p>
<p>下载雾服务器适配链接<br><img src="http://img6.ph.126.net/dbTpgcxVmnTGym8IvWtI5w==/45317471268111776.jpg" alt=""></p>
<p>找到GlassFish，其实我这个Eclipse还是没有的，我就截个图让你们看看，解决你的Eclipse获取不到GlassFish的方法再这节后面再讲，可能是Eclipse的版本问题，我的干开始很郁闷的，希望你们没我悲催<br><img src="http://img5.ph.126.net/lN1axopd6Ty1by2w6vyekg==/1033857589476030495.jpg" alt=""></p>
<p>接下来就可以在新建Serv里的看到GlassFish了，点一下部去配置<br><img src="http://img6.ph.126.net/kfd-VPsUvgD_j2_yX6Y0vA==/91479367448757146.jpg" alt=""></p>
<p>设置Dmain目录，指定你的GlassFish\domains,<br><img src="http://img1.ph.126.net/tt_6v2TfppGiOxfCRqR8fg==/6597214902192138631.jpg" alt=""></p>
<p>下一步（添加项目到服务器），也可以直接Finis完成了，我点完成，在Serv视图总就可一看到如图<br><img src="http://img8.ph.126.net/whMmttyYZruAU0Xy0Bw9zQ==/187462334507038538.jpg" alt=""></p>
<p>Ok！大功告成，恭喜你做到最后一部！点小虫子就可以启动了，不需要在DOS窗口用命令行了，就和用Tomcat一样的了。 </p>
<h2 id="五、热部署"><a href="#五、热部署" class="headerlink" title="五、热部署"></a>五、热部署</h2><p>目标就是像MyEclipse一样，有redeploy功能。不用手动重新部署。 </p>
<p>我这里只写步骤，遇到问题了请参考<a href="http://www.iteye.com/topic/141589，如果需要用到touch.exe文件，请到附件里去下载。" target="_blank" rel="external">http://www.iteye.com/topic/141589，如果需要用到touch.exe文件，请到附件里去下载。</a> </p>
<ol>
<li>在Eclipse里，把项目的编译的.class输出到WebContent/WEB-INF目录下。具体做法在项目右击到properties–Java Build Path – source –Default output folder，选择WebContent/WEB-INF，在里面建一个classes，把.class保存在里面。 </li>
<li>按照目录部署，让glassfish启动，目录部署命令如下，asadmin deploydir –name 你项目名 你项目的WebContent的绝对路径 </li>
<li>在WebContent下新建一个.reload文件， 把touch.exe也拷贝到这个目录下。 </li>
<li>在Eclipse里Run–External Tools – External tools configuration<br>Main 里的location:${project_loc}/WebContent/touch.exe </li>
</ol>
<blockquote>
<p>如：D:\ExamWorkspace\li555\WebContent\touch.exe</p>
</blockquote>
<p>Working directory:${project_loc}/WebContent<br>Arguments:.reload<br>Common里的Display in Favorites menu选中Extends tools。<br>以后每次修改.java文件都可以通过touch.exe直接热部署。<br><img src="http://img8.ph.126.net/9fURLJcRV_rUqIBYc2RMDQ==/6598278129935877148.jpg" alt=""></p>
<h2 id="六、GlassFish配置jdbc数据源"><a href="#六、GlassFish配置jdbc数据源" class="headerlink" title="六、GlassFish配置jdbc数据源"></a>六、GlassFish配置jdbc数据源</h2><p>对于Java EE应用，经常需要事先设定数据源，否则部署时会报：javax.naming.NameNouFoundException<br>配置方法是进入Resources -&gt; JDBC ,会看到JDBC Resources 和 Connection pools</p>
<p>先设定Connection pools，以MySql为例，点击New，命名为MySqlPools,ResourceType选择javax.sql.ConnectionPoolDataSource, Database vendor 肯定选择mysql，然后点击next进入下一页面 </p>
<p>最主要是设定Additional Properties,也就是jdbc连接配置，设定好url,user,password,其他保持默认值，也可以根据需要自己添加属性。<br>设定好连接池后，接着设定JDBC Resources，新建一个JDBC，名称要和web应用里的持久化单元采用的数据源的名称一致。 </p>
<p>然后再次部署web应用，就会正常运行了。 </p>
<p>以上是我查询网上的资料，然后根据自己的动手实践整理的，希望对大家有用。 </p>
<p>下面来说说前面配置你可能会出现的错误：</p>
<ul>
<li>你的Eclipse在新建Server的时候，可能并不能获取到GlassFish,也就是说Download additional server adapters获取不到Glassfish,其他常规方法还是不行，我试过了，我的Eclipse就怎么也不行，后来我下载了另一个Eclipse的版本，叫JUNO(朱诺)，我机器上之前是HELOIS（太阳神）</li>
</ul>
<p>Eclipse Juno的下载地址：<a href="http://www.eclipse.org/downloads/" target="_blank" rel="external">http://www.eclipse.org/downloads/</a><br><img src="http://img7.ph.126.net/eN6ZtOC4UtPM8e3ojwXqLQ==/6597259982168916947.jpg" alt="JUNO(朱诺)"></p>
<p><img src="http://img7.ph.126.net/eexnB6Z8kW1ZuZTIc_ht3Q==/6597469988888721707.jpg" alt="HELIOS(太阳神)"></p>
<p>让后用它去获取，能获取的到，在打开你的Eclipse Helios，很奇怪，此时helios自动出来了。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
